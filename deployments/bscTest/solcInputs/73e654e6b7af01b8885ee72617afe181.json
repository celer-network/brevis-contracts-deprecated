{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/apps/friendship/Friendship.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../../verifiers/interfaces/ITxVerifier.sol\";\n\ncontract Friendship {\n    ITxVerifier public txVerifier;\n\n    // (chainId, sender, receiver) -> timestamp of latest tx\n    mapping(uint64 => mapping(address => mapping(address => uint64))) public lastestTxTimestamps;\n\n    event VerifiedFriendship(uint64 chainId, address from, address to, uint64 timestamp);\n\n    constructor(ITxVerifier _txVerifier) {\n        txVerifier = _txVerifier;\n    }\n\n    function submitFriendshipProof(\n        bytes calldata _tx,\n        bytes calldata _proof,\n        bytes calldata _auxiBlkVerifyInfo\n    ) external {\n        ITxVerifier.TxInfo memory txInfo = txVerifier.verifyTx(_tx, _proof, _auxiBlkVerifyInfo);\n        require(txInfo.blkTime > lastestTxTimestamps[txInfo.chainId][txInfo.from][txInfo.to], \"not latest tx\");\n        lastestTxTimestamps[txInfo.chainId][txInfo.from][txInfo.to] = txInfo.blkTime;\n        emit VerifiedFriendship(txInfo.chainId, txInfo.from, txInfo.to, txInfo.blkTime);\n    }\n}\n"
    },
    "contracts/apps/uniswap-volume/UniswapVolume.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../verifiers/interfaces/ITxVerifier.sol\";\n\ninterface IBrevisUniNFT {\n    function mint(address to) external;\n}\n\ncontract UniswapVolume is Ownable {\n    ITxVerifier public txVerifier;\n\n    mapping(uint64 => address) uniswapV2Router;\n    mapping(uint64 => address) uniswapV3Router;\n\n    mapping(address => uint256) swapAmount;\n\n    enum TierName {\n        Stone,\n        Bronze,\n        Silver,\n        Gold,\n        Platinum,\n        Diamond\n    }\n    mapping(TierName => uint256) public tierAmounts;\n    mapping(TierName => address) public tierNFTs;\n\n    event VerifiedUniswapAmount(uint64 chainId, address trader, uint64 timestamp, uint256 amount);\n\n    constructor(ITxVerifier _txVerifier) {\n        txVerifier = _txVerifier;\n    }\n\n    function submitUniswapTxProof(bytes calldata _tx, bytes calldata _proof, TierName tier, bytes calldata _auxiBlkVerifyInfo) external {\n        ITxVerifier.TxInfo memory txInfo = txVerifier.verifyTx(_tx, _proof, _auxiBlkVerifyInfo);\n        require(txInfo.to != address(0), \"invalid to address\");\n        require(txInfo.from == msg.sender, \"invalid from address\");\n        require(swapAmount[txInfo.from] == 0, \"swap already proved for this user\");\n\n        uint256 amount;\n        if (txInfo.to == uniswapV2Router[txInfo.chainId]) {\n            amount = decodeSwapV2Info(txInfo.data);\n        } else if (txInfo.to == uniswapV3Router[txInfo.chainId]) {\n            amount = decodeSwapV3Info(txInfo.data);\n        } else {\n            revert(\"not uniswap tx\");\n        }\n        swapAmount[txInfo.from] = amount;\n        require(amount >= tierAmounts[tier], \"wrong tier\");\n        IBrevisUniNFT(tierNFTs[tier]).mint(txInfo.from);\n\n        emit VerifiedUniswapAmount(txInfo.chainId, txInfo.from, txInfo.blkTime, amount);\n    }\n\n    function decodeSwapV2Info(bytes memory _data) private pure returns (uint256 amount) {\n        // TODO\n    }\n\n    function decodeSwapV3Info(bytes memory _data) private pure returns (uint256 amount) {\n        // TODO\n    }\n\n    function setUniswapV2Router(uint64 _chainId, address _router) external onlyOwner {\n        uniswapV2Router[_chainId] = _router;\n    }\n\n    function setUniswapV3Router(uint64 _chainId, address _router) external onlyOwner {\n        uniswapV3Router[_chainId] = _router;\n    }\n\n    function setTierAmounts(TierName[] calldata _names, uint256[] calldata _amounts) external onlyOwner {\n        require(_names.length == _amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _names.length; i++) {\n            tierAmounts[_names[i]] = _amounts[i];\n        }\n    }\n\n    function setTierNFTs(TierName[] calldata _names, address[] calldata _nfts) external onlyOwner {\n        require(_names.length == _nfts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _names.length; i++) {\n            tierNFTs[_names[i]] = _nfts[i];\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/BSCValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./Initializable.sol\";\nimport \"./System.sol\";\nimport \"./interfaces/IApplication.sol\";\nimport \"./interfaces/IBSCValidatorSet.sol\";\nimport \"./lib/CmnPkg.sol\";\nimport \"./lib/Memory.sol\";\nimport \"./lib/RLPDecode.sol\";\n\ncontract BSCValidatorSet is Initializable, IApplication, IBSCValidatorSet {\n    using RLPDecode for *;\n\n    uint8 public constant VALIDATORS_UPDATE_MESSAGE_TYPE = 0;\n\n    uint256 public constant EXPIRE_TIME_SECOND_GAP = 1000;\n    uint256 public constant MAX_NUM_OF_VALIDATORS = 41;\n\n    uint32 public constant ERROR_UNKNOWN_PACKAGE_TYPE = 101;\n    uint32 public constant ERROR_FAIL_CHECK_VALIDATORS = 102;\n    uint32 public constant ERROR_LEN_OF_VAL_MISMATCH = 103;\n\n    uint256 public constant INIT_NUM_OF_CABINETS = 21;\n    uint256 public constant EPOCH = 200;\n\n    /*********************** state of the contract **************************/\n    Validator[] public currentValidatorSet;\n    uint256 public expireTimeSecondGap;\n\n    System private system;\n\n    // key is the `consensusAddress` of `Validator`,\n    // value is the 1-based index of the element in `currentValidatorSet`.\n    mapping(address => uint256) public currentValidatorSetMap;\n\n    struct Validator {\n        address consensusAddress;\n        address payable feeAddress;\n        address BBCFeeAddress;\n        uint64 votingPower;\n        // only in state\n        bool jailed;\n        uint256 incoming;\n    }\n\n    /*********************** cross chain package **************************/\n    struct IbcValidatorSetPackage {\n        uint8 packageType;\n        Validator[] validatorSet;\n    }\n\n    /*********************** events **************************/\n    event ValidatorSetUpdated();\n    event UnexpectedPackage(uint8 channelId, bytes msgBytes);\n    event FailedWithReasonStr(string message);\n\n    /*********************** init **************************/\n    function init(address _system, bytes memory _initValidatorSetBytes) external onlyUninitialized {\n        (IbcValidatorSetPackage memory validatorSetPkg, bool valid) = decodeValidatorSetSynPackage(\n            _initValidatorSetBytes\n        );\n        require(valid, \"failed to parse init validatorSet\");\n        for (uint256 i; i < validatorSetPkg.validatorSet.length; ++i) {\n            currentValidatorSet.push(validatorSetPkg.validatorSet[i]);\n            currentValidatorSetMap[validatorSetPkg.validatorSet[i].consensusAddress] = i + 1;\n        }\n        expireTimeSecondGap = EXPIRE_TIME_SECOND_GAP;\n\n        system = System(_system);\n\n        _initialized = true;\n    }\n\n    /*********************** Cross Chain App Implement **************************/\n    function handleSynPackage(\n        uint8,\n        bytes calldata msgBytes\n    ) external override onlyInitialized returns (bytes memory responsePayload) {\n        require(msg.sender == System(system).crossChain(), \"not cross chain contract\");\n\n        (IbcValidatorSetPackage memory validatorSetPackage, bool ok) = decodeValidatorSetSynPackage(msgBytes);\n        if (!ok) {\n            return CmnPkg.encodeCommonAckPackage(system.ERROR_FAIL_DECODE());\n        }\n        uint32 resCode;\n        if (validatorSetPackage.packageType == VALIDATORS_UPDATE_MESSAGE_TYPE) {\n            resCode = updateValidatorSet(validatorSetPackage.validatorSet);\n        } else {\n            resCode = ERROR_UNKNOWN_PACKAGE_TYPE;\n        }\n        if (resCode == system.CODE_OK()) {\n            return new bytes(0);\n        } else {\n            return CmnPkg.encodeCommonAckPackage(resCode);\n        }\n    }\n\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external override {\n        require(msg.sender == system.crossChain(), \"not cross chain contract\");\n\n        // should not happen\n        emit UnexpectedPackage(channelId, msgBytes);\n    }\n\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external override {\n        require(msg.sender == system.crossChain(), \"not cross chain contract\");\n\n        // should not happen\n        emit UnexpectedPackage(channelId, msgBytes);\n    }\n\n    function updateValidatorSet(Validator[] memory validatorSet) internal returns (uint32) {\n        {\n            // do verify.\n            (bool valid, string memory errMsg) = checkValidatorSet(validatorSet);\n            if (!valid) {\n                emit FailedWithReasonStr(errMsg);\n                return ERROR_FAIL_CHECK_VALIDATORS;\n            }\n        }\n\n        // update validator set state\n        doUpdateState(validatorSet);\n\n        emit ValidatorSetUpdated();\n        return system.CODE_OK();\n    }\n\n    /*********************** Internal Functions **************************/\n\n    function checkValidatorSet(Validator[] memory validatorSet) private pure returns (bool, string memory) {\n        if (validatorSet.length > MAX_NUM_OF_VALIDATORS) {\n            return (false, \"the number of validators exceed the limit\");\n        }\n        for (uint256 i; i < validatorSet.length; ++i) {\n            for (uint256 j = 0; j < i; j++) {\n                if (validatorSet[i].consensusAddress == validatorSet[j].consensusAddress) {\n                    return (false, \"duplicate consensus address of validatorSet\");\n                }\n            }\n        }\n        return (true, \"\");\n    }\n\n    function doUpdateState(Validator[] memory validatorSet) private {\n        uint256 n = currentValidatorSet.length;\n        uint256 m = validatorSet.length;\n\n        for (uint256 i; i < n; ++i) {\n            bool stale = true;\n            Validator memory oldValidator = currentValidatorSet[i];\n            for (uint256 j = 0; j < m; j++) {\n                if (oldValidator.consensusAddress == validatorSet[j].consensusAddress) {\n                    stale = false;\n                    break;\n                }\n            }\n            if (stale) {\n                delete currentValidatorSetMap[oldValidator.consensusAddress];\n            }\n        }\n\n        if (n > m) {\n            for (uint256 i = m; i < n; ++i) {\n                currentValidatorSet.pop();\n            }\n        }\n        uint256 k = n < m ? n : m;\n        for (uint256 i; i < k; ++i) {\n            if (!isSameValidator(validatorSet[i], currentValidatorSet[i])) {\n                currentValidatorSetMap[validatorSet[i].consensusAddress] = i + 1;\n                currentValidatorSet[i] = validatorSet[i];\n            }\n        }\n    }\n\n    function isSameValidator(Validator memory v1, Validator memory v2) private pure returns (bool) {\n        return\n            v1.consensusAddress == v2.consensusAddress &&\n            v1.feeAddress == v2.feeAddress &&\n            v1.BBCFeeAddress == v2.BBCFeeAddress &&\n            v1.votingPower == v2.votingPower;\n    }\n\n    //rlp encode & decode function\n    function decodeValidatorSetSynPackage(\n        bytes memory msgBytes\n    ) internal pure returns (IbcValidatorSetPackage memory, bool) {\n        IbcValidatorSetPackage memory validatorSetPkg;\n\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validatorSetPkg.packageType = uint8(iter.next().toUint());\n            } else if (idx == 1) {\n                RLPDecode.RLPItem[] memory items = iter.next().toList();\n                validatorSetPkg.validatorSet = new Validator[](items.length);\n                for (uint256 j; j < items.length; ++j) {\n                    (Validator memory val, bool ok) = decodeValidator(items[j]);\n                    if (!ok) {\n                        return (validatorSetPkg, false);\n                    }\n                    validatorSetPkg.validatorSet[j] = val;\n                }\n                success = true;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        return (validatorSetPkg, success);\n    }\n\n    function decodeValidator(RLPDecode.RLPItem memory itemValidator) internal pure returns (Validator memory, bool) {\n        Validator memory validator;\n        RLPDecode.Iterator memory iter = itemValidator.iterator();\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                validator.consensusAddress = iter.next().toAddress();\n            } else if (idx == 1) {\n                validator.feeAddress = payable(iter.next().toAddress());\n            } else if (idx == 2) {\n                validator.BBCFeeAddress = iter.next().toAddress();\n            } else if (idx == 3) {\n                validator.votingPower = uint64(iter.next().toUint());\n                success = true;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        return (validator, success);\n    }\n\n    function isCurrentValidator(address valAddress) external view returns (bool) {\n        return currentValidatorSetMap[valAddress] != 0;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/CrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./interfaces/IApplication.sol\";\nimport \"./interfaces/ICrossChain.sol\";\nimport \"./interfaces/ITendermintLightClient.sol\";\nimport \"./lib/Bytes.sol\";\nimport \"./lib/Memory.sol\";\nimport \"./lib/Tendermint.sol\";\nimport \"./lib/ics23/ics23.sol\";\nimport \"./Initializable.sol\";\nimport \"./System.sol\";\nimport {PROOFS_PROTO_GLOBAL_ENUMS, CommitmentProof, ProofSpec, InnerSpec, LeafOp, InnerOp} from \"./lib/proto/Proofs.sol\";\n\ncontract CrossChain is Initializable, ICrossChain {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for TmHeader.Data;\n    using TendermintHelper for ConsensusState.Data;\n    using TendermintHelper for ValidatorSet.Data;\n\n    // constant variables\n    string public constant STORE_NAME = \"ibc\";\n    uint256 public constant CROSS_CHAIN_KEY_PREFIX = 0x01006000; // last 6 bytes\n    uint8 public constant SYN_PACKAGE = 0x00;\n    uint8 public constant ACK_PACKAGE = 0x01;\n    uint8 public constant FAIL_ACK_PACKAGE = 0x02;\n    uint256 public constant INIT_BATCH_SIZE = 50;\n\n    // governable parameters\n    uint256 public batchSizeForOracle;\n\n    //state variables\n    uint256 public previousTxHeight;\n    uint256 public txCounter;\n    int64 public oracleSequence;\n    mapping(uint8 => address) public channelHandlerContractMap;\n    mapping(address => mapping(uint8 => bool)) public registeredContractChannelMap;\n    mapping(uint8 => uint64) public channelSendSequenceMap;\n    mapping(uint8 => uint64) public channelReceiveSequenceMap;\n    System private system;\n\n    struct ChannelInit {\n        uint8 channelId;\n        uint64 sequence;\n    }\n\n    ProofSpec.Data private _tmProofSpec =\n        ProofSpec.Data({\n            leaf_spec: LeafOp.Data({\n                hash: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256,\n                prehash_key: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.NO_HASH,\n                prehash_value: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256,\n                length: PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.VAR_PROTO,\n                prefix: hex\"00028cc3f922\"\n            }),\n            inner_spec: InnerSpec.Data({\n                child_order: getTmChildOrder(),\n                child_size: 32,\n                min_prefix_length: 1,\n                max_prefix_length: 128,\n                empty_child: abi.encodePacked(),\n                hash: PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256\n            }),\n            min_depth: 0,\n            max_depth: 0\n        });\n\n    // event\n    event CrossChainPackage(\n        uint16 chainId,\n        uint64 indexed oracleSequence,\n        uint64 indexed packageSequence,\n        uint8 indexed channelId,\n        bytes payload\n    );\n    event ReceivedPackage(uint8 packageType, uint64 indexed packageSequence, uint8 indexed channelId);\n    event UnsupportedPackage(uint64 indexed packageSequence, uint8 indexed channelId, bytes payload);\n    event UnexpectedRevertInPackageHandler(address indexed contractAddr, string reason);\n    event UnexpectedFailureAssertionInPackageHandler(address indexed contractAddr, bytes lowLevelData);\n\n    modifier sequenceInOrder(uint64 _sequence, uint8 _channelID) {\n        uint64 expectedSequence = channelReceiveSequenceMap[_channelID];\n        require(_sequence == expectedSequence, \"sequence not in order\");\n\n        channelReceiveSequenceMap[_channelID] = expectedSequence + 1;\n        _;\n    }\n\n    modifier blockSynced(uint64 _height) {\n        require(\n            ITendermintLightClient(system.tmLightClient()).isHeaderSynced(_height),\n            \"light client not sync the block yet\"\n        );\n        _;\n    }\n\n    modifier channelSupported(uint8 _channelID) {\n        require(channelHandlerContractMap[_channelID] != address(0x0), \"channel is not supported\");\n        _;\n    }\n\n    modifier onlyRegisteredContractChannel(uint8 channelId) {\n        require(\n            registeredContractChannelMap[msg.sender][channelId],\n            \"the contract and channel have not been registered\"\n        );\n        _;\n    }\n\n    // | length   | prefix | sourceChainID| destinationChainID | channelID | sequence |\n    // | 32 bytes | 1 byte | 2 bytes      | 2 bytes            |  1 bytes  | 8 bytes  |\n    function generateKey(uint64 _sequence, uint8 _channelID) internal pure returns (bytes memory) {\n        uint256 fullCROSS_CHAIN_KEY_PREFIX = CROSS_CHAIN_KEY_PREFIX | _channelID;\n        bytes memory key = new bytes(14);\n\n        uint256 ptr;\n        assembly {\n            ptr := add(key, 14)\n        }\n        assembly {\n            mstore(ptr, _sequence)\n        }\n        ptr -= 8;\n        assembly {\n            mstore(ptr, fullCROSS_CHAIN_KEY_PREFIX)\n        }\n        ptr -= 6;\n        assembly {\n            mstore(ptr, 14)\n        }\n        return key;\n    }\n\n    function init(address _system, ChannelInit[] memory receiveChannelInit) external onlyUninitialized {\n        system = System(_system);\n        require(system.bscValidatorSet() != address(0), \"system uninitialized\");\n\n        channelHandlerContractMap[system.STAKING_CHANNEL_ID()] = system.bscValidatorSet();\n        registeredContractChannelMap[system.bscValidatorSet()][system.STAKING_CHANNEL_ID()] = true;\n\n        batchSizeForOracle = INIT_BATCH_SIZE;\n\n        oracleSequence = -1;\n        previousTxHeight = 0;\n        txCounter = 0;\n\n        for (uint256 i = 0; i < receiveChannelInit.length; i++) {\n            ChannelInit memory channelInit = receiveChannelInit[i];\n            channelReceiveSequenceMap[channelInit.channelId] = channelInit.sequence;\n        }\n\n        _initialized = true;\n    }\n\n    function encodePayload(\n        uint8 packageType,\n        uint256 relayFee,\n        bytes memory msgBytes\n    ) public pure returns (bytes memory) {\n        uint256 payloadLength = msgBytes.length + 33;\n        bytes memory payload = new bytes(payloadLength);\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n        ptr += 33;\n\n        assembly {\n            mstore(ptr, relayFee)\n        }\n\n        ptr -= 32;\n        assembly {\n            mstore(ptr, packageType)\n        }\n\n        ptr -= 1;\n        assembly {\n            mstore(ptr, payloadLength)\n        }\n\n        ptr += 65;\n        (uint256 src, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(src, ptr, msgBytes.length);\n\n        return payload;\n    }\n\n    // | type   | relayFee   |package  |\n    // | 1 byte | 32 bytes   | bytes    |\n    function decodePayloadHeader(bytes memory payload) internal pure returns (bool, uint8, uint256, bytes memory) {\n        if (payload.length < 33) {\n            return (false, 0, 0, new bytes(0));\n        }\n\n        uint256 ptr;\n        assembly {\n            ptr := payload\n        }\n\n        uint8 packageType;\n        ptr += 1;\n        assembly {\n            packageType := mload(ptr)\n        }\n\n        uint256 relayFee;\n        ptr += 32;\n        assembly {\n            relayFee := mload(ptr)\n        }\n\n        ptr += 32;\n        bytes memory msgBytes = new bytes(payload.length - 33);\n        (uint256 dst, ) = Memory.fromBytes(msgBytes);\n        Memory.copy(ptr, dst, payload.length - 33);\n\n        return (true, packageType, relayFee, msgBytes);\n    }\n\n    function handlePackage(\n        bytes calldata payload,\n        bytes calldata proof,\n        uint64 height,\n        uint64 packageSequence,\n        uint8 channelId\n    )\n        external\n        onlyInitialized\n        sequenceInOrder(packageSequence, channelId)\n        blockSynced(height)\n        channelSupported(channelId)\n    {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        bytes memory payloadLocal = payload; // fix error: stack too deep, try removing local variables\n        bytes memory proofLocal = proof; // fix error: stack too deep, try removing local variables\n        // TODO: Enable after BSC switches to ics-23 proofs\n        // require(\n        //     verifyMembership(\n        //         proofLocal,\n        //         ITendermintLightClient(system.tmLightClient()).getAppHash(height).toBytes(),\n        //         \"\",\n        //         bytes(generateKey(packageSequence, channelId))),\n        //         payloadLocal\n        //     )\n        // );\n\n        uint8 channelIdLocal = channelId; // fix error: stack too deep, try removing local variables\n        (bool success, uint8 packageType, , bytes memory msgBytes) = decodePayloadHeader(payloadLocal);\n        if (!success) {\n            emit UnsupportedPackage(packageSequence, channelIdLocal, payloadLocal);\n            return;\n        }\n        emit ReceivedPackage(packageType, packageSequence, channelIdLocal);\n        if (packageType == SYN_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleSynPackage(channelIdLocal, msgBytes) returns (\n                bytes memory responsePayload\n            ) {\n                if (responsePayload.length != 0) {\n                    sendPackage(\n                        channelSendSequenceMap[channelIdLocal],\n                        channelIdLocal,\n                        encodePayload(ACK_PACKAGE, 0, responsePayload)\n                    );\n                    channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                }\n            } catch Error(string memory reason) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                sendPackage(\n                    channelSendSequenceMap[channelIdLocal],\n                    channelIdLocal,\n                    encodePayload(FAIL_ACK_PACKAGE, 0, msgBytes)\n                );\n                channelSendSequenceMap[channelIdLocal] = channelSendSequenceMap[channelIdLocal] + 1;\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        } else if (packageType == FAIL_ACK_PACKAGE) {\n            address handlerContract = channelHandlerContractMap[channelIdLocal];\n            try IApplication(handlerContract).handleFailAckPackage(channelIdLocal, msgBytes) {} catch Error(\n                string memory reason\n            ) {\n                emit UnexpectedRevertInPackageHandler(handlerContract, reason);\n            } catch (bytes memory lowLevelData) {\n                emit UnexpectedFailureAssertionInPackageHandler(handlerContract, lowLevelData);\n            }\n        }\n    }\n\n    function sendPackage(uint64 packageSequence, uint8 channelId, bytes memory payload) internal {\n        if (block.number > previousTxHeight) {\n            oracleSequence++;\n            txCounter = 1;\n            previousTxHeight = block.number;\n        } else {\n            txCounter++;\n            if (txCounter > batchSizeForOracle) {\n                oracleSequence++;\n                txCounter = 1;\n            }\n        }\n        emit CrossChainPackage(system.bscChainID(), uint64(oracleSequence), packageSequence, channelId, payload);\n    }\n\n    function sendSynPackage(\n        uint8 channelId,\n        bytes calldata msgBytes,\n        uint256 relayFee\n    ) external override onlyInitialized onlyRegisteredContractChannel(channelId) {\n        uint64 sendSequence = channelSendSequenceMap[channelId];\n        sendPackage(sendSequence, channelId, encodePayload(SYN_PACKAGE, relayFee, msgBytes));\n        sendSequence++;\n        channelSendSequenceMap[channelId] = sendSequence;\n    }\n\n    function getTmChildOrder() internal pure returns (int32[] memory) {\n        int32[] memory childOrder = new int32[](2);\n        childOrder[0] = 0;\n        childOrder[1] = 1;\n\n        return childOrder;\n    }\n\n    function verifyMembership(\n        bytes memory proof,\n        bytes memory root,\n        bytes memory prefix,\n        bytes memory slot,\n        bytes memory expectedValue\n    ) internal view returns (bool) {\n        CommitmentProof.Data memory commitmentProof = CommitmentProof.decode(proof);\n\n        Ics23.VerifyMembershipError vCode = Ics23.verifyMembership(\n            _tmProofSpec,\n            root,\n            commitmentProof,\n            slot,\n            expectedValue\n        );\n\n        return vCode == Ics23.VerifyMembershipError.None;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/Ed25519Verifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n\ncontract Ed25519Verifier {\n    using Pairing for *;\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(16537564926561257518103578528440315215453761258292367362288728531966371995874),\n            uint256(17745573146004211534248579212526935789334969204993357645263388924661264974187)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(18681724724964420256656295617462445194520232343683657023020438565197998259673),\n                uint256(12193837689525487485139416036830252517228166559922434453026243184766751424223)\n            ],\n            [\n                uint256(1142689458690077585879713419885020952718961581248594394197708921155425831615),\n                uint256(21176592749741182389767016778519001156128344286592614375719960199144776585881)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(19799290104465580933750348548810731188007606239377683243716104715153013203241),\n                uint256(11029356377690007782073139603897274721732913650225177555357052135977173817932)\n            ],\n            [\n                uint256(14853413044533073822755393458984382667328640010571213879456567827440818416559),\n                uint256(1410171095280489347779850966561512432991607061868962673896369110725284404185)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(14033331354156232558698818931400566889727401262494703861181881854810319611656),\n                uint256(1803778019251118312050232705802652879152144501576771122000761003085527364548)\n            ],\n            [\n                uint256(19177018991900245360077248204991378509575348272931358571227777389261756980021),\n                uint256(13491338816347045964487197971132020169975241104757177444019867803073686189354)\n            ]\n        );\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[57] calldata input\n    ) public view returns (bool r) {\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(9462447710939432742848424196697728822687813011479891122131648160830275921458); // vk.K[0].X\n        vk_x.Y = uint256(11473376488241810165831757536366836850027784981839089792021378256861687455964); // vk.K[0].Y\n        mul_input[0] = uint256(2648510173551830043068139172354933052408112984889271406750039349551232576549); // vk.K[1].X\n        mul_input[1] = uint256(12122054635554892818275346487442913112730051679642997892313491753063522521582); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(7061394255936047678059253317568688117856036320639226956214975754160049295333); // vk.K[2].X\n        mul_input[1] = uint256(14145671141784595839380141874940651481054054987062620771942604522524338984737); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(8218011998118573873686464766508340825013181970169509029207170044008261486193); // vk.K[3].X\n        mul_input[1] = uint256(4808589679893008233603109916014512606401750471929338771914335778004460444360); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(6078662146959222742143128212552101384988335461422265821062667538426926541518); // vk.K[4].X\n        mul_input[1] = uint256(14225787497847862685225784260006515346740700745306082959617044081310626314439); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(15225699490833575811570520695447458343846017972639836494871931441485526096787); // vk.K[5].X\n        mul_input[1] = uint256(15569415315038112005525705058718435821481109166559557245122292405605719408925); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(3942281303299556918937442887343925623486733341136969568571582227745440173807); // vk.K[6].X\n        mul_input[1] = uint256(4138173571813503741513576149284418571266189111210058243046675207337729400955); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(723953850260184913681651686455204823265776604606646409438367197633827064461); // vk.K[7].X\n        mul_input[1] = uint256(20977669267739599281940138230527850695064911563027213490970977450491160080036); // vk.K[7].Y\n        mul_input[2] = input[6];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(15017582390282569744856651205092622236708068694757044392807758501545223739943); // vk.K[8].X\n        mul_input[1] = uint256(1265991120483539619897036121722423769988535691692111441020055552301420911354); // vk.K[8].Y\n        mul_input[2] = input[7];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(5221873433181937410686676698706306071488292331003715940336123836669316677478); // vk.K[9].X\n        mul_input[1] = uint256(14426879645470087966651542997861483039122804778202333350123336907198495445103); // vk.K[9].Y\n        mul_input[2] = input[8];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(20573069687094669083259174171204052569713827743866845162450148699057547764918); // vk.K[10].X\n        mul_input[1] = uint256(19125182916367006002072229187347273947735042422948150051314675975432464674658); // vk.K[10].Y\n        mul_input[2] = input[9];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(653108268157101410313141643706313813985558592438699399282213422712029889715); // vk.K[11].X\n        mul_input[1] = uint256(920655015136053252820652067829010626746362759835559920517492343709532195466); // vk.K[11].Y\n        mul_input[2] = input[10];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(20917639943585713768528304284726936606521085966431546157561891168025022757887); // vk.K[12].X\n        mul_input[1] = uint256(8262496391990750367129442871845474963121866167295779784485121209123609128682); // vk.K[12].Y\n        mul_input[2] = input[11];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(21382382741426387778276445265980446660720522906365157168723787305555966928178); // vk.K[13].X\n        mul_input[1] = uint256(20304725605418784279352839016897739647529600560330484467516988594075783844854); // vk.K[13].Y\n        mul_input[2] = input[12];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(6205744815043738292440949022257329596826099473730575848275490097888497842377); // vk.K[14].X\n        mul_input[1] = uint256(14621389881302722659870997782918885566955239423536368018214245647671237084390); // vk.K[14].Y\n        mul_input[2] = input[13];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(15814307705747507442630842462045602926477319899462506430805053181751486077929); // vk.K[15].X\n        mul_input[1] = uint256(20719845899119367288065102841494811826814842176184748936398855427173476589603); // vk.K[15].Y\n        mul_input[2] = input[14];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(13115514590566800662313134167308526149064497604562804026503299495382170121521); // vk.K[16].X\n        mul_input[1] = uint256(1332307969280655731716061244811863427539380178344062557717239827752566800649); // vk.K[16].Y\n        mul_input[2] = input[15];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(21831548148156992003553031892913267462010789037401082515443630438407722663969); // vk.K[17].X\n        mul_input[1] = uint256(6734282036223126997206695046254381537591284089119495472525380311105692037149); // vk.K[17].Y\n        mul_input[2] = input[16];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(19824054054568150451544715245329533752342566872920996747743887644800176138756); // vk.K[18].X\n        mul_input[1] = uint256(17444883232483823314330637172782524563336237772974332017836978912923943288044); // vk.K[18].Y\n        mul_input[2] = input[17];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(11203846533369587519929291820435945242235455090413432458828659220572895771832); // vk.K[19].X\n        mul_input[1] = uint256(16148158018136729384412794294904585957329060422316919194693060478106477584261); // vk.K[19].Y\n        mul_input[2] = input[18];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(21371926577928441304164289543024513366951022486217703908520862772671592138220); // vk.K[20].X\n        mul_input[1] = uint256(18107932227339892218168366645185506844179114579625951614458742714985063933868); // vk.K[20].Y\n        mul_input[2] = input[19];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(2078836125811363606455079208654269542518183191401138318514557936552194691549); // vk.K[21].X\n        mul_input[1] = uint256(20289036517453961776720656852506924474500493189617637737320825721964408623696); // vk.K[21].Y\n        mul_input[2] = input[20];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(20684528615338806451021356191176017140605638913507543305045224022571493583399); // vk.K[22].X\n        mul_input[1] = uint256(3903056905414345066553250327072636225389082733080503032794283501727725353966); // vk.K[22].Y\n        mul_input[2] = input[21];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(13854622650680331791998959936965711435732154320243563610773598319176375507733); // vk.K[23].X\n        mul_input[1] = uint256(1293023507593941743631670346894908106668220179131184101706263206018361614455); // vk.K[23].Y\n        mul_input[2] = input[22];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(3806178131996244443364939020206141693542459073159601454749540496458558677609); // vk.K[24].X\n        mul_input[1] = uint256(11373982291360652938998008416691951950539326147900435417838815437650728107752); // vk.K[24].Y\n        mul_input[2] = input[23];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(2956423360991834768742742798077214208812640276852161493833529280831095074781); // vk.K[25].X\n        mul_input[1] = uint256(1036790067266635965218530400023441211296511606457139237137911024262932772523); // vk.K[25].Y\n        mul_input[2] = input[24];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(3522982602799278288450494299627381578769489328186449628808472144237402446412); // vk.K[26].X\n        mul_input[1] = uint256(13124545182856888320922946645561369145471456600466254299605996043152521299609); // vk.K[26].Y\n        mul_input[2] = input[25];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(10203021712642579290406260398074627148768959317126130666994877932179153487975); // vk.K[27].X\n        mul_input[1] = uint256(19220206362979524452868254497284191194377622625329987254755474419246348464504); // vk.K[27].Y\n        mul_input[2] = input[26];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(13656479319858575241396965583832757201969209361023293619085267873236508281324); // vk.K[28].X\n        mul_input[1] = uint256(18653894887361004227161091206020531090371042692329436200109497793456818170297); // vk.K[28].Y\n        mul_input[2] = input[27];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(20667457304256598973369559213600706490691854322307004623522066355950536986052); // vk.K[29].X\n        mul_input[1] = uint256(10166524048179842305027932295420555626140631584017768928975471213820747864954); // vk.K[29].Y\n        mul_input[2] = input[28];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(14451586832169158165406346103518705733160542436336769287947890488919305713536); // vk.K[30].X\n        mul_input[1] = uint256(15677358351240766490224933957331428778606486522363230169083418720895728674937); // vk.K[30].Y\n        mul_input[2] = input[29];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(8815343788891391302884218656640023092689342750375488785771313089418754129780); // vk.K[31].X\n        mul_input[1] = uint256(13009618795398702701706372843804296988960880281370027843016246576371783417574); // vk.K[31].Y\n        mul_input[2] = input[30];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(7794542304670317906972413815443657110555785749184277557959662453473304832135); // vk.K[32].X\n        mul_input[1] = uint256(13613183423982157012686848485088999158423912294590394357601874166998596036708); // vk.K[32].Y\n        mul_input[2] = input[31];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(13829063270265614122932776384418402417255253559219713892264763147960420595663); // vk.K[33].X\n        mul_input[1] = uint256(1394492787369205690940389079323334412434996525623614329408676573910762151803); // vk.K[33].Y\n        mul_input[2] = input[32];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n        mul_input[0] = uint256(13250480124160751683662026425319692126614649754704623898304284468074453566914); // vk.K[34].X\n        mul_input[1] = uint256(5842667319974085537473375237026886465714130878203887186671280383692949371367); // vk.K[34].Y\n        mul_input[2] = input[33];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[34] * input[33]\n        mul_input[0] = uint256(4244396663084445939427850030230353204559612848770696182862006916130063961075); // vk.K[35].X\n        mul_input[1] = uint256(5567117583761251190183987315357290694204768312790348596534705058755423324166); // vk.K[35].Y\n        mul_input[2] = input[34];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[35] * input[34]\n        mul_input[0] = uint256(16468214890309010196842237213567005731971554524310253342503592222181911831216); // vk.K[36].X\n        mul_input[1] = uint256(13015440355627709680447076370593216495840212097545614001751347318260304962870); // vk.K[36].Y\n        mul_input[2] = input[35];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[36] * input[35]\n        mul_input[0] = uint256(1710502514829787762068790998518593585732164832507101474241328558660469459552); // vk.K[37].X\n        mul_input[1] = uint256(6641523787174944064207070430739280224248149581740606756642107112326594132092); // vk.K[37].Y\n        mul_input[2] = input[36];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[37] * input[36]\n        mul_input[0] = uint256(13873688322349022545411654259743538242310790895509577137595893668751435535182); // vk.K[38].X\n        mul_input[1] = uint256(2743144454147776739466147084712345009024223781055121185226575029717710864182); // vk.K[38].Y\n        mul_input[2] = input[37];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[38] * input[37]\n        mul_input[0] = uint256(5515207890157998771775835819329897799964342326708529575708915192914192717763); // vk.K[39].X\n        mul_input[1] = uint256(6830846512538057603246995968366818367160206190590285682644456335384380744224); // vk.K[39].Y\n        mul_input[2] = input[38];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[39] * input[38]\n        mul_input[0] = uint256(12084319035206948715397631350220429569745624512314143843439943565130003131475); // vk.K[40].X\n        mul_input[1] = uint256(19823940921149166526761280180611360195654754479337467436765527950957403100421); // vk.K[40].Y\n        mul_input[2] = input[39];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[40] * input[39]\n        mul_input[0] = uint256(1707966742483292923663665240004271093118893352464133867701833789750341568293); // vk.K[41].X\n        mul_input[1] = uint256(2059830066597637963266616577934465643861703524384620495213365657208172372127); // vk.K[41].Y\n        mul_input[2] = input[40];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[41] * input[40]\n        mul_input[0] = uint256(4335683960535202743801100378397366667909285456099227829020337934512681970900); // vk.K[42].X\n        mul_input[1] = uint256(7163760264613823569250071408872840488100394969233714572137432343600611323243); // vk.K[42].Y\n        mul_input[2] = input[41];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[42] * input[41]\n        mul_input[0] = uint256(18579130060975771189412379077269037710625635418528267671299513425013575199707); // vk.K[43].X\n        mul_input[1] = uint256(7413439674648248746853580336851465886481116161464911636828558414649648473619); // vk.K[43].Y\n        mul_input[2] = input[42];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[43] * input[42]\n        mul_input[0] = uint256(16042514199832592968247672418295024202640592240955629633937928114942675433499); // vk.K[44].X\n        mul_input[1] = uint256(9176210646934564968216912647498279795139899070579664859952976743279140133749); // vk.K[44].Y\n        mul_input[2] = input[43];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[44] * input[43]\n        mul_input[0] = uint256(4605826036674863045915848920224687279865356012358913781882485214370608375866); // vk.K[45].X\n        mul_input[1] = uint256(16433469797022838005221089589473953566885756258639853768294415623922164207114); // vk.K[45].Y\n        mul_input[2] = input[44];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[45] * input[44]\n        mul_input[0] = uint256(21291606718216838223612806394353023159167853021188903625675694115824239986243); // vk.K[46].X\n        mul_input[1] = uint256(13861976516244796326502185111204736567218465632382198677006716558365310272234); // vk.K[46].Y\n        mul_input[2] = input[45];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[46] * input[45]\n        mul_input[0] = uint256(13608539239013691835986711410119733227388008030702193689279242935664405256689); // vk.K[47].X\n        mul_input[1] = uint256(21464993448394658273854216484684266808321160947909209851055873325887050492293); // vk.K[47].Y\n        mul_input[2] = input[46];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[47] * input[46]\n        mul_input[0] = uint256(14508762627123999549076601587501227009682636970076636367483491513461822793735); // vk.K[48].X\n        mul_input[1] = uint256(13086806823222303647760776079580932758835172518633536905189386855031527005867); // vk.K[48].Y\n        mul_input[2] = input[47];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[48] * input[47]\n        mul_input[0] = uint256(19620443629871450449905318328661357670363144885276650727854684127004979439411); // vk.K[49].X\n        mul_input[1] = uint256(13512145302109135260648622069026293634594965443783681487284540332451024150941); // vk.K[49].Y\n        mul_input[2] = input[48];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[49] * input[48]\n        mul_input[0] = uint256(20059550415468532205827328714175420183638104824341229821332085226225097782116); // vk.K[50].X\n        mul_input[1] = uint256(12050042602361465175864197068892829808531398334073641526653775817012796904920); // vk.K[50].Y\n        mul_input[2] = input[49];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[50] * input[49]\n        mul_input[0] = uint256(13306511629433317473594641621219799176423215443967411203563081150777664297203); // vk.K[51].X\n        mul_input[1] = uint256(675454852156663320769111000409074913392067853038809175892444203322319080285); // vk.K[51].Y\n        mul_input[2] = input[50];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[51] * input[50]\n        mul_input[0] = uint256(12076096047127155639652324319628370078197547570757038002713853288385847397853); // vk.K[52].X\n        mul_input[1] = uint256(20063073818109035475283913336465472637670645911136973171672153316960017020047); // vk.K[52].Y\n        mul_input[2] = input[51];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[52] * input[51]\n        mul_input[0] = uint256(7070926176971266168429945375853092488155813841418560246899144119253540102350); // vk.K[53].X\n        mul_input[1] = uint256(18608632252819735218114751983460803259577541150988320712643403458973379890618); // vk.K[53].Y\n        mul_input[2] = input[52];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[53] * input[52]\n        mul_input[0] = uint256(8787738969091605771927429510050738225462363969120867850034866515919420616153); // vk.K[54].X\n        mul_input[1] = uint256(280860041417881042842953968111093793049575926737744905886029164850711931023); // vk.K[54].Y\n        mul_input[2] = input[53];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[54] * input[53]\n        mul_input[0] = uint256(17470729458746471811553625923859580633403777304482076029136929287269138561286); // vk.K[55].X\n        mul_input[1] = uint256(11077695780520668039728878524992441159739768910332004302025495828550310823044); // vk.K[55].Y\n        mul_input[2] = input[54];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[55] * input[54]\n        mul_input[0] = uint256(18820732662126470829529155830450341599504017356119489964316929892787212659148); // vk.K[56].X\n        mul_input[1] = uint256(18398462213470099652091858533789910876899706114418611429055433371437676169588); // vk.K[56].Y\n        mul_input[2] = input[55];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[56] * input[55]\n        mul_input[0] = uint256(10979958723839781582509983389549268556375745246890018812028152329350660809099); // vk.K[57].X\n        mul_input[1] = uint256(8614377901484706884530978841565040782347190141813157341928120361805065861265); // vk.K[57].Y\n        mul_input[2] = input[56];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[57] * input[56]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/Initializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nabstract contract Initializable {\n    bool internal _initialized;\n\n    modifier onlyUninitialized() {\n        require(!_initialized, \"already initialized\");\n        _;\n    }\n\n    modifier onlyInitialized() {\n        require(_initialized, \"not initialized\");\n        _;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/interfaces/IApplication.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IApplication {\n    /**\n     * @dev Handle syn package\n     */\n    function handleSynPackage(uint8 channelId, bytes calldata msgBytes) external returns (bytes memory responsePayload);\n\n    /**\n     * @dev Handle ack package\n     */\n    function handleAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n\n    /**\n     * @dev Handle fail ack package\n     */\n    function handleFailAckPackage(uint8 channelId, bytes calldata msgBytes) external;\n}\n"
    },
    "contracts/bsc-tendermint/interfaces/IBSCValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IBSCValidatorSet {\n    function isCurrentValidator(address valAddress) external view returns (bool);\n}\n"
    },
    "contracts/bsc-tendermint/interfaces/ICrossChain.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ICrossChain {\n    /**\n     * @dev Send package to Binance Chain\n     */\n    function sendSynPackage(uint8 channelId, bytes calldata msgBytes, uint256 relayFee) external;\n}\n"
    },
    "contracts/bsc-tendermint/interfaces/ITendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface ITendermintLightClient {\n    function isHeaderSynced(uint64 height) external view returns (bool);\n\n    function getAppHash(uint64 height) external view returns (bytes32);\n}\n"
    },
    "contracts/bsc-tendermint/lib/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nlibrary Bytes {\n    function toBytes32(bytes memory bz) internal pure returns (bytes32 ret) {\n        require(bz.length == 32, \"Bytes: toBytes32 invalid size\");\n        assembly {\n            ret := mload(add(bz, 32))\n        }\n    }\n\n    function toBytes(bytes32 data) public pure returns (bytes memory) {\n        return abi.encodePacked(data);\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64 ret) {\n        require(_bytes.length >= _start + 8, \"Bytes: toUint64 out of bounds\");\n        assembly {\n            ret := mload(add(add(_bytes, 0x8), _start))\n        }\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"Bytes: toUint256 out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes) internal pure returns (address addr) {\n        // convert last 20 bytes of keccak hash (bytes32) to address\n        bytes32 hash = keccak256(_bytes);\n        assembly {\n            mstore(0, hash)\n            addr := mload(0)\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/CmnPkg.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./RLPEncode.sol\";\nimport \"./RLPDecode.sol\";\n\nlibrary CmnPkg {\n    using RLPEncode for *;\n    using RLPDecode for *;\n\n    struct CommonAckPackage {\n        uint32 code;\n    }\n\n    function encodeCommonAckPackage(uint32 code) internal pure returns (bytes memory) {\n        bytes[] memory elements = new bytes[](1);\n        elements[0] = uint256(code).encodeUint();\n        return elements.encodeList();\n    }\n\n    function decodeCommonAckPackage(bytes memory msgBytes) internal pure returns (CommonAckPackage memory, bool) {\n        CommonAckPackage memory ackPkg;\n        RLPDecode.Iterator memory iter = msgBytes.toRLPItem().iterator();\n\n        bool success = false;\n        uint256 idx = 0;\n        while (iter.hasNext()) {\n            if (idx == 0) {\n                ackPkg.code = uint32(iter.next().toUint());\n                success = true;\n            } else {\n                break;\n            }\n            idx++;\n        }\n        return (ackPkg, success);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/crypto/MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"../proto/TendermintHelper.sol\";\nimport {SimpleValidator, Validator} from \"../proto/TendermintLight.sol\";\n\nlibrary MerkleTree {\n    /**\n     * @dev returns empty hash\n     */\n    function emptyHash() internal pure returns (bytes32) {\n        return sha256(abi.encode());\n    }\n\n    /**\n     * @dev returns tmhash(0x00 || leaf)\n     *\n     */\n    function leafHash(bytes memory leaf) internal pure returns (bytes32) {\n        uint8 leafPrefix = 0x00;\n        return sha256(abi.encodePacked(leafPrefix, leaf));\n    }\n\n    /**\n     * @dev returns tmhash(0x01 || left || right)\n     */\n    function innerHash(bytes32 leaf, bytes32 right) internal pure returns (bytes32) {\n        uint8 innerPrefix = 0x01;\n        return sha256(abi.encodePacked(innerPrefix, leaf, right));\n    }\n\n    /**\n     * @dev returns the largest power of 2 less than length\n     *\n     * TODO: This function can be optimized with bit shifting approach:\n     * https://www.baeldung.com/java-largest-power-of-2-less-than-number\n     */\n    function getSplitPoint(uint256 input) internal pure returns (uint256) {\n        require(input > 1, \"MerkleTree: invalid input\");\n\n        uint256 result = 1;\n        for (uint256 i = input - 1; i > 1; i--) {\n            if ((i & (i - 1)) == 0) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are validators, in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(\n        Validator.Data[] memory validators,\n        uint256 start,\n        uint256 total\n    ) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            bytes memory encodedValidator = SimpleValidator.encode(\n                TendermintHelper.toSimpleValidator(validators[start])\n            );\n            return leafHash(encodedValidator);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n\n    /**\n     * @dev computes a Merkle tree where the leaves are the byte slice in the provided order\n     * Follows RFC-6962\n     */\n    function merkleRootHash(bytes[14] memory validators, uint256 start, uint256 total) internal pure returns (bytes32) {\n        if (total == 0) {\n            return emptyHash();\n        } else if (total == 1) {\n            return leafHash(validators[start]);\n        } else {\n            uint256 k = getSplitPoint(total);\n            bytes32 left = merkleRootHash(validators, start, k); // validators[:k]\n            bytes32 right = merkleRootHash(validators, start + k, total - k); // validators[k:]\n            return innerHash(left, right);\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/ics23/ics23.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {BatchProof, CompressedBatchProof, CommitmentProof, ProofSpec, ExistenceProof, NonExistenceProof} from \"../proto/Proofs.sol\";\nimport {Compress} from \"./ics23Compress.sol\";\nimport {Proof} from \"./ics23Proof.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Ics23 {\n    enum VerifyMembershipError {\n        None,\n        ExistenceProofIsNil,\n        ProofVerify\n    }\n\n    // verifyMembership, throws an exception in case anything goes wrong\n    function verifyMembership(\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        CommitmentProof.Data memory proof,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (VerifyMembershipError) {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        ExistenceProof.Data memory exiProof = getExistProofForKey(decoProof, key);\n\n        //require(ExistenceProof.isNil(exiProof) == false); // dev: getExistProofForKey not available\n        if (ExistenceProof.isNil(exiProof)) return VerifyMembershipError.ExistenceProofIsNil;\n        Proof.VerifyExistenceError vCode = Proof.verify(exiProof, spec, commitmentRoot, key, value);\n        if (vCode != Proof.VerifyExistenceError.None) return VerifyMembershipError.ProofVerify;\n\n        return VerifyMembershipError.None;\n    }\n\n    enum VerifyNonMembershipError {\n        None,\n        NonExistenceProofIsNil,\n        ProofVerify\n    }\n\n    function verifyNonMembership(\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) internal pure returns (VerifyNonMembershipError) {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        NonExistenceProof.Data memory nonProof = getNonExistProofForKey(decoProof, key);\n        //require(NonExistenceProof.isNil(nonProof) == false); // dev: getNonExistProofForKey not available\n        if (NonExistenceProof.isNil(nonProof)) return VerifyNonMembershipError.NonExistenceProofIsNil;\n        Proof.VerifyNonExistenceError vCode = Proof.verify(nonProof, spec, commitmentRoot, key);\n        if (vCode != Proof.VerifyNonExistenceError.None) return VerifyNonMembershipError.ProofVerify;\n\n        return VerifyNonMembershipError.None;\n    }\n\n    /* -- temporarily disabled as they are not covered by unit tests\n    struct BatchItem {\n        bytes key;\n        bytes value;\n    }\n    function batchVerifyMembership(ProofSpec.Data memory spec, bytes memory commitmentRoot, CommitmentProof.Data memory proof, BatchItem[] memory items ) internal pure {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        for (uint i = 0; i < items.length; i++) {\n            verifyMembership(spec, commitmentRoot, decoProof, items[i].key, items[i].value);\n        }\n    }\n\n    function batchVerifyNonMembership(ProofSpec.Data memory spec, bytes memory commitmentRoot, CommitmentProof.Data memory proof, bytes[] memory keys ) internal pure {\n        CommitmentProof.Data memory decoProof = Compress.decompress(proof);\n        for (uint i = 0; i < keys.length; i++) {\n            verifyNonMembership(spec, commitmentRoot, decoProof, keys[i]);\n        }\n    }\n*/\n\n    // private\n    function getExistProofForKey(\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) private pure returns (ExistenceProof.Data memory) {\n        if (ExistenceProof.isNil(proof.exist) == false) {\n            if (BytesLib.equal(proof.exist.key, key) == true) {\n                return proof.exist;\n            }\n        } else if (BatchProof.isNil(proof.batch) == false) {\n            for (uint256 i = 0; i < proof.batch.entries.length; i++) {\n                if (\n                    ExistenceProof.isNil(proof.batch.entries[i].exist) == false &&\n                    BytesLib.equal(proof.batch.entries[i].exist.key, key)\n                ) {\n                    return proof.batch.entries[i].exist;\n                }\n            }\n        }\n        return ExistenceProof.nil();\n    }\n\n    function getNonExistProofForKey(\n        CommitmentProof.Data memory proof,\n        bytes memory key\n    ) private pure returns (NonExistenceProof.Data memory) {\n        if (NonExistenceProof.isNil(proof.nonexist) == false) {\n            if (isLeft(proof.nonexist.left, key) && isRight(proof.nonexist.right, key)) {\n                return proof.nonexist;\n            }\n        } else if (BatchProof.isNil(proof.batch) == false) {\n            for (uint256 i = 0; i < proof.batch.entries.length; i++) {\n                if (\n                    NonExistenceProof.isNil(proof.batch.entries[i].nonexist) == false &&\n                    isLeft(proof.batch.entries[i].nonexist.left, key) &&\n                    isRight(proof.batch.entries[i].nonexist.right, key)\n                ) {\n                    return proof.batch.entries[i].nonexist;\n                }\n            }\n        }\n        return NonExistenceProof.nil();\n    }\n\n    function isLeft(ExistenceProof.Data memory left, bytes memory key) private pure returns (bool) {\n        // ExistenceProof.isNil does not work\n        return ExistenceProof._empty(left) || Ops.compare(left.key, key) < 0;\n    }\n\n    function isRight(ExistenceProof.Data memory right, bytes memory key) private pure returns (bool) {\n        // ExistenceProof.isNil does not work\n        return ExistenceProof._empty(right) || Ops.compare(right.key, key) > 0;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/ics23/ics23Compress.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {InnerOp, ExistenceProof, NonExistenceProof, CommitmentProof, CompressedBatchEntry, CompressedBatchProof, CompressedExistenceProof, BatchEntry, BatchProof} from \"../proto/Proofs.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nlibrary Compress {\n    function decompress(CommitmentProof.Data memory proof) internal pure returns (CommitmentProof.Data memory) {\n        //CompressedBatchProof.isNil() does not work\n        if (CompressedBatchProof._empty(proof.compressed) == true) {\n            return proof;\n        }\n        return\n            CommitmentProof.Data({\n                exist: ExistenceProof.nil(),\n                nonexist: NonExistenceProof.nil(),\n                batch: BatchProof.Data({entries: decompress(proof.compressed)}),\n                compressed: CompressedBatchProof.nil()\n            });\n    }\n\n    // private\n    function decompress(CompressedBatchProof.Data memory proof) private pure returns (BatchEntry.Data[] memory) {\n        BatchEntry.Data[] memory entries = new BatchEntry.Data[](proof.entries.length);\n        for (uint256 i = 0; i < proof.entries.length; i++) {\n            entries[i] = decompressEntry(proof.entries[i], proof.lookup_inners);\n        }\n        return entries;\n    }\n\n    function decompressEntry(\n        CompressedBatchEntry.Data memory entry,\n        InnerOp.Data[] memory lookup\n    ) private pure returns (BatchEntry.Data memory) {\n        //CompressedExistenceProof.isNil does not work\n        if (CompressedExistenceProof._empty(entry.exist) == false) {\n            return BatchEntry.Data({exist: decompressExist(entry.exist, lookup), nonexist: NonExistenceProof.nil()});\n        }\n        return\n            BatchEntry.Data({\n                exist: ExistenceProof.nil(),\n                nonexist: NonExistenceProof.Data({\n                    key: entry.nonexist.key,\n                    left: decompressExist(entry.nonexist.left, lookup),\n                    right: decompressExist(entry.nonexist.right, lookup)\n                })\n            });\n    }\n\n    function decompressExist(\n        CompressedExistenceProof.Data memory proof,\n        InnerOp.Data[] memory lookup\n    ) private pure returns (ExistenceProof.Data memory) {\n        if (CompressedExistenceProof._empty(proof)) {\n            return ExistenceProof.nil();\n        }\n        ExistenceProof.Data memory decoProof = ExistenceProof.Data({\n            key: proof.key,\n            value: proof.value,\n            leaf: proof.leaf,\n            path: new InnerOp.Data[](proof.path.length)\n        });\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            require(proof.path[i] >= 0); // dev: proof.path < 0\n            uint256 step = SafeCast.toUint256(proof.path[i]);\n            require(step < lookup.length); // dev: step >= lookup.length\n            decoProof.path[i] = lookup[step];\n        }\n        return decoProof;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/ics23/ics23Ops.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {LeafOp, InnerOp, PROOFS_PROTO_GLOBAL_ENUMS, ProofSpec} from \"../proto/Proofs.sol\";\nimport {ProtoBufRuntime} from \"../proto/ProtoBufRuntime.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Ops {\n    bytes constant empty = new bytes(0);\n\n    enum ApplyLeafOpError {\n        None,\n        KeyLength,\n        ValueLength,\n        DoHash,\n        PrepareLeafData\n    }\n\n    // LeafOp operations\n    function applyOp(\n        LeafOp.Data memory leafOp,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (bytes memory, ApplyLeafOpError) {\n        //require(key.length > 0); // dev: Leaf op needs key\n        if (key.length == 0) return (empty, ApplyLeafOpError.KeyLength);\n        //require(value.length > 0); // dev: Leaf op needs value\n        if (value.length == 0) return (empty, ApplyLeafOpError.ValueLength);\n        (bytes memory pKey, PrepareLeafDataError pCode1) = prepareLeafData(leafOp.prehash_key, leafOp.length, key);\n        if (pCode1 != PrepareLeafDataError.None) return (empty, ApplyLeafOpError.PrepareLeafData);\n        (bytes memory pValue, PrepareLeafDataError pCode2) = prepareLeafData(\n            leafOp.prehash_value,\n            leafOp.length,\n            value\n        );\n        if (pCode2 != PrepareLeafDataError.None) return (empty, ApplyLeafOpError.PrepareLeafData);\n        bytes memory data = abi.encodePacked(leafOp.prefix, pKey, pValue);\n        (bytes memory hashed, DoHashError hCode) = doHash(leafOp.hash, data);\n        if (hCode != DoHashError.None) return (empty, ApplyLeafOpError.DoHash);\n        return (hashed, ApplyLeafOpError.None);\n    }\n\n    enum PrepareLeafDataError {\n        None,\n        DoHash,\n        DoLengthOp\n    }\n\n    // preapare leaf data for encoding\n    function prepareLeafData(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp lenOp,\n        bytes memory data\n    ) internal pure returns (bytes memory, PrepareLeafDataError) {\n        (bytes memory hased, DoHashError hCode) = doHashOrNoop(hashOp, data);\n        if (hCode != DoHashError.None) return (empty, PrepareLeafDataError.DoHash);\n        (bytes memory res, DoLengthOpError lCode) = doLengthOp(lenOp, hased);\n        if (lCode != DoLengthOpError.None) return (empty, PrepareLeafDataError.DoLengthOp);\n\n        return (res, PrepareLeafDataError.None);\n    }\n\n    enum CheckAgainstSpecError {\n        None,\n        Hash,\n        PreHashKey,\n        PreHashValue,\n        Length,\n        MinPrefixLength,\n        HasPrefix,\n        MaxPrefixLength\n    }\n\n    function checkAgainstSpec(\n        LeafOp.Data memory leafOp,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        require(leafOp.hash == spec.leaf_spec.hash, \"checkAgainstSpec for LeafOp - Unexpected HashOp\"); // dev: checkAgainstSpec for LeafOp - Unexpected HashOp\n        if (leafOp.hash != spec.leaf_spec.hash) return CheckAgainstSpecError.Hash;\n        require(\n            leafOp.prehash_key == spec.leaf_spec.prehash_key,\n            \"checkAgainstSpec for LeafOp - Unexpected PrehashKey\"\n        ); // dev: checkAgainstSpec for LeafOp - Unexpected PrehashKey\n        if (leafOp.prehash_key != spec.leaf_spec.prehash_key) return CheckAgainstSpecError.PreHashKey;\n        require(\n            leafOp.prehash_value == spec.leaf_spec.prehash_value,\n            \"checkAgainstSpec for LeafOp - Unexpected PrehashValue\"\n        ); // dev: checkAgainstSpec for LeafOp - Unexpected PrehashValue\");\n        if (leafOp.prehash_value != spec.leaf_spec.prehash_value) return CheckAgainstSpecError.PreHashValue;\n        require(leafOp.length == spec.leaf_spec.length, \"checkAgainstSpec for LeafOp - Unexpected lengthOp\"); // dev: checkAgainstSpec for LeafOp - Unexpected lengthOp\n        if (leafOp.length != spec.leaf_spec.length) return CheckAgainstSpecError.Length;\n        bool hasprefix = hasPrefix(leafOp.prefix, spec.leaf_spec.prefix);\n        require(hasprefix, \"checkAgainstSpec for LeafOp - Leaf Prefix doesn't start with\"); // dev: checkAgainstSpec for LeafOp - Leaf Prefix doesn't start with\n        if (hasprefix == false) return CheckAgainstSpecError.HasPrefix;\n\n        return CheckAgainstSpecError.None;\n    }\n\n    enum ApplyInnerOpError {\n        None,\n        ChildLength,\n        DoHash\n    }\n\n    // InnerOp operations\n    function applyOp(\n        InnerOp.Data memory innerOp,\n        bytes memory child\n    ) internal pure returns (bytes memory, ApplyInnerOpError) {\n        //require(child.length > 0); // dev: Inner op needs child value\n        if (child.length == 0) return (empty, ApplyInnerOpError.ChildLength);\n        bytes memory preImage = abi.encodePacked(innerOp.prefix, child, innerOp.suffix);\n        (bytes memory hashed, DoHashError code) = doHash(innerOp.hash, preImage);\n        if (code != DoHashError.None) return (empty, ApplyInnerOpError.DoHash);\n\n        return (hashed, ApplyInnerOpError.None);\n    }\n\n    function checkAgainstSpec(\n        InnerOp.Data memory innerOp,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        // require(innerOp.hash == spec.inner_spec.hash, \"checkAgainstSpec for InnerOp - Unexpected HashOp\"); // dev: checkAgainstSpec for InnerOp - Unexpected HashOp\n        if (innerOp.hash != spec.inner_spec.hash) return CheckAgainstSpecError.Hash;\n        uint256 minPrefixLength = SafeCast.toUint256(spec.inner_spec.min_prefix_length);\n        // require(innerOp.prefix.length >= minPrefixLength, \"InnerOp prefix too short\"); // dev: InnerOp prefix too short\n        if (innerOp.prefix.length < minPrefixLength) return CheckAgainstSpecError.MinPrefixLength;\n        bytes memory leafPrefix = spec.leaf_spec.prefix;\n        bool hasprefix = hasPrefix(innerOp.prefix, leafPrefix);\n        // require(hasprefix == false, \"Inner Prefix starts with wrong value\"); // dev: Inner Prefix starts with wrong value\n        if (hasprefix) return CheckAgainstSpecError.HasPrefix;\n        uint256 childSize = SafeCast.toUint256(spec.inner_spec.child_size);\n        uint256 maxLeftChildBytes = (spec.inner_spec.child_order.length - 1) * childSize;\n        uint256 maxPrefixLength = SafeCast.toUint256(spec.inner_spec.max_prefix_length);\n        // require(innerOp.prefix.length <= maxPrefixLength + maxLeftChildBytes, \"InnerOp prefix too long\"); // dev: InnerOp prefix too long\n        if (innerOp.prefix.length > maxPrefixLength + maxLeftChildBytes) return CheckAgainstSpecError.MaxPrefixLength;\n\n        return CheckAgainstSpecError.None;\n    }\n\n    function doHashOrNoop(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        bytes memory preImage\n    ) internal pure returns (bytes memory, DoHashError) {\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.NO_HASH) {\n            return (preImage, DoHashError.None);\n        }\n        return doHash(hashOp, preImage);\n    }\n\n    enum DoHashError {\n        None,\n        Sha512,\n        Sha512_256,\n        Unsupported\n    }\n\n    function doHash(\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hashOp,\n        bytes memory preImage\n    ) internal pure returns (bytes memory, DoHashError) {\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA256) {\n            return (abi.encodePacked(sha256(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.KECCAK) {\n            return (abi.encodePacked(keccak256(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.RIPEMD160) {\n            return (abi.encodePacked(ripemd160(preImage)), DoHashError.None);\n        }\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.BITCOIN) {\n            bytes memory tmp = abi.encodePacked(sha256(preImage));\n            return (abi.encodePacked(ripemd160(tmp)), DoHashError.None);\n        }\n        //require(hashOp != PROOFS_PROTO_GLOBAL_ENUMS.HashOp.Sha512); // dev: SHA512 not supported\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA512) {\n            return (empty, DoHashError.Sha512);\n        }\n        //require(hashOp != PROOFS_PROTO_GLOBAL_ENUMS.HashOp.Sha512_256); // dev: SHA512_256 not supported\n        if (hashOp == PROOFS_PROTO_GLOBAL_ENUMS.HashOp.SHA512_256) {\n            return (empty, DoHashError.Sha512_256);\n        }\n        //revert(); // dev: Unsupported hashOp\n        return (empty, DoHashError.Unsupported);\n    }\n\n    function compare(bytes memory a, bytes memory b) internal pure returns (int256) {\n        uint256 minLen = Math.min(a.length, b.length);\n        for (uint256 i = 0; i < minLen; i++) {\n            if (uint8(a[i]) < uint8(b[i])) {\n                return -1;\n            } else if (uint8(a[i]) > uint8(b[i])) {\n                return 1;\n            }\n        }\n        if (a.length > minLen) {\n            return 1;\n        }\n        if (b.length > minLen) {\n            return -1;\n        }\n        return 0;\n    }\n\n    // private\n    enum DoLengthOpError {\n        None,\n        Require32DataLength,\n        Require64DataLength,\n        Unsupported\n    }\n\n    function doLengthOp(\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp lenOp,\n        bytes memory data\n    ) private pure returns (bytes memory, DoLengthOpError) {\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.NO_PREFIX) {\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.VAR_PROTO) {\n            uint256 sz = ProtoBufRuntime._sz_varint(data.length);\n            bytes memory encoded = new bytes(sz);\n            ProtoBufRuntime._encode_varint(data.length, 32, encoded);\n            return (abi.encodePacked(encoded, data), DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.REQUIRE_32_BYTES) {\n            //require(data.length == 32); // dev: data.length != 32\n            if (data.length != 32) return (empty, DoLengthOpError.Require32DataLength);\n\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.REQUIRE_64_BYTES) {\n            //require(data.length == 64); // dev: data.length != 64\"\n            if (data.length != 64) return (empty, DoLengthOpError.Require64DataLength);\n\n            return (data, DoLengthOpError.None);\n        }\n        if (lenOp == PROOFS_PROTO_GLOBAL_ENUMS.LengthOp.FIXED32_LITTLE) {\n            uint32 size = SafeCast.toUint32(data.length);\n            // maybe some assembly here to make it faster\n            bytes4 sizeB = bytes4(size);\n            bytes memory littleE = new bytes(4);\n            //unfolding for loop is cheaper\n            littleE[0] = sizeB[3];\n            littleE[1] = sizeB[2];\n            littleE[2] = sizeB[1];\n            littleE[3] = sizeB[0];\n            return (abi.encodePacked(littleE, data), DoLengthOpError.None);\n        }\n        //revert(); // dev: Unsupported lenOp\n        return (empty, DoLengthOpError.Unsupported);\n    }\n\n    function hasPrefix(bytes memory element, bytes memory prefix) private pure returns (bool) {\n        if (prefix.length == 0) {\n            return true;\n        }\n        if (prefix.length > element.length) {\n            return false;\n        }\n        bytes memory slice = BytesLib.slice(element, 0, prefix.length);\n        return BytesLib.equal(prefix, slice);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/ics23/ics23Proof.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport {LeafOp, CompressedBatchProof, ExistenceProof, NonExistenceProof, BatchEntry, BatchProof, ProofSpec, InnerOp, InnerSpec, CommitmentProof} from \"../proto/Proofs.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {Compress} from \"./ics23Compress.sol\";\nimport {Ops} from \"./ics23Ops.sol\";\n\nlibrary Proof {\n    bytes constant empty = new bytes(0);\n\n    enum VerifyExistenceError {\n        None,\n        KeyNotMatching,\n        ValueNotMatching,\n        CheckSpec,\n        CalculateRoot,\n        RootNotMatching\n    }\n\n    // ExistenceProof\n    function verify(\n        ExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        bytes memory key,\n        bytes memory value\n    ) internal pure returns (VerifyExistenceError) {\n        //require(BytesLib.equal(proof.key, key)); // dev: Provided key doesn't match proof\n        bool keyMatch = BytesLib.equal(proof.key, key);\n        if (keyMatch == false) return VerifyExistenceError.KeyNotMatching;\n        //require(BytesLib.equal(proof.value, value)); // dev: Provided value doesn't match proof\n        bool valueMatch = BytesLib.equal(proof.value, value);\n        if (valueMatch == false) return VerifyExistenceError.ValueNotMatching;\n        CheckAgainstSpecError cCode = checkAgainstSpec(proof, spec);\n        if (cCode != CheckAgainstSpecError.None) return VerifyExistenceError.CheckSpec;\n        (bytes memory root, CalculateRootError rCode) = calculateRoot(proof);\n        if (rCode != CalculateRootError.None) return VerifyExistenceError.CalculateRoot;\n        //require(BytesLib.equal(root, commitmentRoot)); // dev: Calculated root doesn't match provided root\n        bool rootMatch = BytesLib.equal(root, commitmentRoot);\n        if (rootMatch == false) return VerifyExistenceError.RootNotMatching;\n\n        return VerifyExistenceError.None;\n    }\n\n    enum CalculateRootError {\n        None,\n        LeafNil,\n        LeafOp,\n        PathOp,\n        BatchEntriesLength,\n        BatchEntryEmpty,\n        EmptyProof\n    }\n\n    function calculateRoot(ExistenceProof.Data memory proof) internal pure returns (bytes memory, CalculateRootError) {\n        //require(LeafOp.isNil(proof.leaf) == false); // dev: Existence Proof needs defined LeafOp\n        if (LeafOp.isNil(proof.leaf)) return (empty, CalculateRootError.LeafNil);\n        (bytes memory root, Ops.ApplyLeafOpError lCode) = Ops.applyOp(proof.leaf, proof.key, proof.value);\n        if (lCode != Ops.ApplyLeafOpError.None) return (empty, CalculateRootError.LeafOp);\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            Ops.ApplyInnerOpError iCode;\n            (root, iCode) = Ops.applyOp(proof.path[i], root);\n            if (iCode != Ops.ApplyInnerOpError.None) return (empty, CalculateRootError.PathOp);\n        }\n\n        return (root, CalculateRootError.None);\n    }\n\n    enum CheckAgainstSpecError {\n        None,\n        EmptyLeaf,\n        OpsCheckAgainstSpec,\n        InnerOpsDepthTooShort,\n        InnerOpsDepthTooLong\n    }\n\n    function checkAgainstSpec(\n        ExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec\n    ) internal pure returns (CheckAgainstSpecError) {\n        // LeafOp.isNil does not work\n        //require(LeafOp._empty(proof.leaf) == false); // dev: Existence Proof needs defined LeafOp\n        if (LeafOp._empty(proof.leaf)) return CheckAgainstSpecError.EmptyLeaf;\n        Ops.CheckAgainstSpecError cCode = Ops.checkAgainstSpec(proof.leaf, spec);\n        if (cCode != Ops.CheckAgainstSpecError.None) return CheckAgainstSpecError.OpsCheckAgainstSpec;\n        if (spec.min_depth > 0) {\n            bool innerOpsDepthTooShort = proof.path.length < SafeCast.toUint256(int256(spec.min_depth));\n            //require(innerOpsDepthTooShort == false); // dev: InnerOps depth too short\n            if (innerOpsDepthTooShort) return CheckAgainstSpecError.InnerOpsDepthTooShort;\n        }\n        if (spec.max_depth > 0) {\n            bool innerOpsDepthTooLong = proof.path.length > SafeCast.toUint256(int256(spec.max_depth));\n            //require(innerOpsDepthTooLong == false); // dev: InnerOps depth too long\n            if (innerOpsDepthTooLong) return CheckAgainstSpecError.InnerOpsDepthTooLong;\n        }\n        for (uint256 i = 0; i < proof.path.length; i++) {\n            Ops.CheckAgainstSpecError cCode = Ops.checkAgainstSpec(proof.path[i], spec);\n            if (cCode != Ops.CheckAgainstSpecError.None) return CheckAgainstSpecError.OpsCheckAgainstSpec;\n        }\n    }\n\n    enum VerifyNonExistenceError {\n        None,\n        VerifyLeft,\n        VerifyRight,\n        LeftAndRightKeyEmpty,\n        RightKeyRange,\n        LeftKeyRange,\n        RightProofLeftMost,\n        LeftProofRightMost,\n        IsLeftNeighbor\n    }\n\n    // NonExistenceProof\n    function verify(\n        NonExistenceProof.Data memory proof,\n        ProofSpec.Data memory spec,\n        bytes memory commitmentRoot,\n        bytes memory key\n    ) internal pure returns (VerifyNonExistenceError) {\n        bytes memory leftKey;\n        bytes memory rightKey;\n        // ExistenceProof.isNil does not work\n        if (ExistenceProof._empty(proof.left) == false) {\n            VerifyExistenceError eCode = verify(proof.left, spec, commitmentRoot, proof.left.key, proof.left.value);\n            if (eCode != VerifyExistenceError.None) return VerifyNonExistenceError.VerifyLeft;\n\n            leftKey = proof.left.key;\n        }\n        if (ExistenceProof._empty(proof.right) == false) {\n            VerifyExistenceError eCode = verify(proof.right, spec, commitmentRoot, proof.right.key, proof.right.value);\n            if (eCode != VerifyExistenceError.None) return VerifyNonExistenceError.VerifyRight;\n\n            rightKey = proof.right.key;\n        }\n        // If both proofs are missing, this is not a valid proof\n        //require(leftKey.length > 0 || rightKey.length > 0); // dev: both left and right proofs missing\n        if (leftKey.length == 0 && rightKey.length == 0) return VerifyNonExistenceError.LeftAndRightKeyEmpty;\n        // Ensure in valid range\n        if (rightKey.length > 0 && Ops.compare(key, rightKey) >= 0) {\n            //require(Ops.compare(key, rightKey) < 0); // dev: key is not left of right proof\n            return VerifyNonExistenceError.RightKeyRange;\n        }\n        if (leftKey.length > 0 && Ops.compare(key, leftKey) <= 0) {\n            //require(Ops.compare(key, leftKey) > 0); // dev: key is not right of left proof\n            return VerifyNonExistenceError.LeftKeyRange;\n        }\n        if (leftKey.length == 0) {\n            //require(isLeftMost(spec.inner_spec, proof.right.path)); // dev: left proof missing, right proof must be left-most\n            if (isLeftMost(spec.inner_spec, proof.right.path) == false)\n                return VerifyNonExistenceError.RightProofLeftMost;\n        } else if (rightKey.length == 0) {\n            //require(isRightMost(spec.inner_spec, proof.left.path)); // dev: isRightMost: right proof missing, left proof must be right-most\n            if (isRightMost(spec.inner_spec, proof.left.path) == false)\n                return VerifyNonExistenceError.LeftProofRightMost;\n        } else {\n            //require(isLeftNeighbor(spec.inner_spec, proof.left.path, proof.right.path)); // dev: isLeftNeighbor: right proof missing, left proof must be right-most\n            bool isLeftNeigh = isLeftNeighbor(spec.inner_spec, proof.left.path, proof.right.path);\n            if (isLeftNeigh == false) return VerifyNonExistenceError.IsLeftNeighbor;\n        }\n\n        return VerifyNonExistenceError.None;\n    }\n\n    function calculateRoot(\n        NonExistenceProof.Data memory proof\n    ) internal pure returns (bytes memory, CalculateRootError) {\n        if (ExistenceProof._empty(proof.left) == false) {\n            return calculateRoot(proof.left);\n        }\n        if (ExistenceProof._empty(proof.right) == false) {\n            return calculateRoot(proof.right);\n        }\n        //revert(); // dev: Nonexistence proof has empty Left and Right proof\n        return (empty, CalculateRootError.EmptyProof);\n    }\n\n    // commitment proof\n    function calculateRoot(CommitmentProof.Data memory proof) internal pure returns (bytes memory, CalculateRootError) {\n        if (ExistenceProof._empty(proof.exist) == false) {\n            return calculateRoot(proof.exist);\n        }\n        if (NonExistenceProof._empty(proof.nonexist) == false) {\n            return calculateRoot(proof.nonexist);\n        }\n        if (BatchProof._empty(proof.batch) == false) {\n            //require(proof.batch.entries.length > 0); // dev: batch proof has no entry\n            if (proof.batch.entries.length == 0) return (empty, CalculateRootError.BatchEntriesLength);\n            //require(BatchEntry._empty(proof.batch.entries[0]) == false); // dev: batch proof has empty entry\n            if (BatchEntry._empty(proof.batch.entries[0])) return (empty, CalculateRootError.BatchEntryEmpty);\n            if (ExistenceProof._empty(proof.batch.entries[0].exist) == false) {\n                return calculateRoot(proof.batch.entries[0].exist);\n            }\n            if (NonExistenceProof._empty(proof.batch.entries[0].nonexist) == false) {\n                return calculateRoot(proof.batch.entries[0].nonexist);\n            }\n        }\n        if (CompressedBatchProof._empty(proof.compressed) == false) {\n            return calculateRoot(Compress.decompress(proof));\n        }\n        //revert(); // dev: calculateRoot(CommitmentProof) empty proof\n        return (empty, CalculateRootError.EmptyProof);\n    }\n\n    // private\n    function isLeftMost(InnerSpec.Data memory spec, InnerOp.Data[] memory path) private pure returns (bool) {\n        (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError gCode) = getPadding(spec, 0);\n        if (gCode != GetPaddingError.None) return false;\n        for (uint256 i = 0; i < path.length; i++) {\n            if (hasPadding(path[i], minPrefix, maxPrefix, suffix) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function isRightMost(InnerSpec.Data memory spec, InnerOp.Data[] memory path) private pure returns (bool) {\n        uint256 last = spec.child_order.length - 1;\n        (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError gCode) = getPadding(spec, last);\n        if (gCode != GetPaddingError.None) return false;\n        for (uint256 i = 0; i < path.length; i++) {\n            if (hasPadding(path[i], minPrefix, maxPrefix, suffix) == false) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function isLeftStep(\n        InnerSpec.Data memory spec,\n        InnerOp.Data memory left,\n        InnerOp.Data memory right\n    ) private pure returns (bool) {\n        (uint256 leftIdx, OrderFromPaddingError lCode) = orderFromPadding(spec, left);\n        if (lCode != OrderFromPaddingError.None) return false;\n        (uint256 rightIdx, OrderFromPaddingError rCode) = orderFromPadding(spec, right);\n        if (lCode != OrderFromPaddingError.None) return false;\n        if (rCode != OrderFromPaddingError.None) return false;\n\n        return rightIdx == leftIdx + 1;\n    }\n\n    function isLeftNeighbor(\n        InnerSpec.Data memory spec,\n        InnerOp.Data[] memory left,\n        InnerOp.Data[] memory right\n    ) private pure returns (bool) {\n        uint256 leftIdx = left.length - 1;\n        uint256 rightIdx = right.length - 1;\n        while (leftIdx >= 0 && rightIdx >= 0) {\n            if (\n                BytesLib.equal(left[leftIdx].prefix, right[rightIdx].prefix) &&\n                BytesLib.equal(left[leftIdx].suffix, right[rightIdx].suffix)\n            ) {\n                leftIdx -= 1;\n                rightIdx -= 1;\n                continue;\n            }\n            break;\n        }\n        if (isLeftStep(spec, left[leftIdx], right[rightIdx]) == false) {\n            return false;\n        }\n        // slicing does not work for ``memory`` types\n        if (isRightMost(spec, sliceInnerOps(left, 0, leftIdx)) == false) {\n            return false;\n        }\n        if (isLeftMost(spec, sliceInnerOps(right, 0, rightIdx)) == false) {\n            return false;\n        }\n        return true;\n    }\n\n    enum OrderFromPaddingError {\n        None,\n        NotFound,\n        GetPadding\n    }\n\n    function orderFromPadding(\n        InnerSpec.Data memory spec,\n        InnerOp.Data memory op\n    ) private pure returns (uint256, OrderFromPaddingError) {\n        uint256 maxBranch = spec.child_order.length;\n        for (uint256 branch = 0; branch < maxBranch; branch++) {\n            (uint256 minp, uint256 maxp, uint256 suffix, GetPaddingError gCode) = getPadding(spec, branch);\n            if (gCode != GetPaddingError.None) return (0, OrderFromPaddingError.GetPadding);\n            if (hasPadding(op, minp, maxp, suffix) == true) return (branch, OrderFromPaddingError.None);\n        }\n        //revert(); // dev: Cannot find any valid spacing for this node\n        return (0, OrderFromPaddingError.NotFound);\n    }\n\n    enum GetPaddingError {\n        None,\n        GetPosition\n    }\n\n    function getPadding(\n        InnerSpec.Data memory spec,\n        uint256 branch\n    ) private pure returns (uint256 minPrefix, uint256 maxPrefix, uint256 suffix, GetPaddingError) {\n        uint256 uChildSize = SafeCast.toUint256(spec.child_size);\n        (uint256 idx, GetPositionError gCode) = getPosition(spec.child_order, branch);\n        if (gCode != GetPositionError.None) return (0, 0, 0, GetPaddingError.GetPosition);\n        uint256 prefix = idx * uChildSize;\n        minPrefix = prefix + SafeCast.toUint256(spec.min_prefix_length);\n        maxPrefix = prefix + SafeCast.toUint256(spec.max_prefix_length);\n        suffix = (spec.child_order.length - 1 - idx) * uChildSize;\n\n        return (minPrefix, maxPrefix, suffix, GetPaddingError.None);\n    }\n\n    enum GetPositionError {\n        None,\n        BranchLength,\n        NoFound\n    }\n\n    function getPosition(int32[] memory order, uint256 branch) private pure returns (uint256, GetPositionError) {\n        //require(branch < order.length); // dev: invalid branch\n        if (branch >= order.length) return (0, GetPositionError.BranchLength);\n        for (uint256 i = 0; i < order.length; i++) {\n            if (SafeCast.toUint256(order[i]) == branch) return (i, GetPositionError.None);\n        }\n        //revert(); // dev: branch not found in order\n        return (0, GetPositionError.NoFound);\n    }\n\n    function hasPadding(\n        InnerOp.Data memory op,\n        uint256 minPrefix,\n        uint256 maxPrefix,\n        uint256 suffix\n    ) private pure returns (bool) {\n        if (op.prefix.length < minPrefix) return false;\n        if (op.prefix.length > maxPrefix) return false;\n        return op.suffix.length == suffix;\n    }\n\n    function sliceInnerOps(\n        InnerOp.Data[] memory array,\n        uint256 start,\n        uint256 end\n    ) private pure returns (InnerOp.Data[] memory) {\n        InnerOp.Data[] memory slice = new InnerOp.Data[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            slice[i] = array[i];\n        }\n        return slice;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/Memory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nlibrary Memory {\n    // Size of a word, in bytes.\n    uint256 internal constant WORD_SIZE = 32;\n    // Size of the header of a 'bytes' array.\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\n    // Address of the free memory pointer.\n    uint256 internal constant FREE_MEM_PTR = 0x40;\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the 'len'\n    // bytes starting at 'addr2'.\n    // Returns 'true' if the bytes are the same, otherwise 'false'.\n    function equals(uint256 addr, uint256 addr2, uint256 len) internal pure returns (bool equal) {\n        assembly {\n            equal := eq(keccak256(addr, len), keccak256(addr2, len))\n        }\n    }\n\n    // Compares the 'len' bytes starting at address 'addr' in memory with the bytes stored in\n    // 'bts'. It is allowed to set 'len' to a lower value then 'bts.length', in which case only\n    // the first 'len' bytes will be compared.\n    // Requires that 'bts.length >= len'\n    function equals(uint256 addr, uint256 len, bytes memory bts) internal pure returns (bool equal) {\n        require(bts.length >= len);\n        uint256 addr2;\n        assembly {\n            addr2 := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        return equals(addr, addr2, len);\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n\n    // Copy 'len' bytes from memory address 'src', to address 'dest'.\n    // This function does not check the or destination, it only copies\n    // the bytes.\n    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_SIZE;\n            src += WORD_SIZE;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    // Returns a memory pointer to the provided bytes array.\n    function ptr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := bts\n        }\n    }\n\n    // Returns a memory pointer to the data portion of the provided bytes array.\n    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // This function does the same as 'dataPtr(bytes memory)', but will also return the\n    // length of the provided bytes array.\n    function fromBytes(bytes memory bts) internal pure returns (uint256 addr, uint256 len) {\n        len = bts.length;\n        assembly {\n            addr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n    }\n\n    // Creates a 'bytes memory' variable from the memory address 'addr', with the\n    // length 'len'. The function will allocate new memory for the bytes array, and\n    // the 'len bytes starting at 'addr' will be copied into that new memory.\n    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n        bts = new bytes(len);\n        uint256 btsptr;\n        assembly {\n            btsptr := add(\n                bts,\n                /*BYTES_HEADER_SIZE*/\n                32\n            )\n        }\n        copy(addr, btsptr, len);\n    }\n\n    // Get the word stored at memory address 'addr' as a 'uint'.\n    function toUint(uint256 addr) internal pure returns (uint256 n) {\n        assembly {\n            n := mload(addr)\n        }\n    }\n\n    // Get the word stored at memory address 'addr' as a 'bytes32'.\n    function toBytes32(uint256 addr) internal pure returns (bytes32 bts) {\n        assembly {\n            bts := mload(addr)\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/proto/Encoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary Encoder {\n    uint64 private constant _MAX_UINT64 = 0xFFFFFFFFFFFFFFFF;\n\n    function cdcEncode(string memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(bytes(item).length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (bytes(item).length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(bytes memory item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_lendelim(item.length);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item.length > 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    function cdcEncode(int64 item) internal pure returns (bytes memory) {\n        uint256 estimatedSize = 1 + ProtoBufRuntime._sz_int64(item);\n        bytes memory bs = new bytes(estimatedSize);\n\n        uint256 offset = 32;\n        uint256 pointer = 32;\n\n        if (item != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(item, pointer, bs);\n        }\n\n        uint256 sz = pointer - offset;\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // TODO: Can we make this cheaper?\n    // https://docs.soliditylang.org/en/v0.6.5/types.html#allocating-memory-arrays\n    function encodeDelim(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length < _MAX_UINT64, \"Encoder: out of bounds (uint64)\");\n\n        uint64 length = uint64(input.length);\n        uint256 additionalEstimated = ProtoBufRuntime._sz_uint64(length);\n\n        bytes memory delimitedPrefix = new bytes(additionalEstimated);\n        uint256 delimitedPrefixLen = ProtoBufRuntime._encode_uint64(length, 32, delimitedPrefix);\n\n        assembly {\n            mstore(delimitedPrefix, delimitedPrefixLen)\n        }\n\n        // concatenate buffers\n        return abi.encodePacked(delimitedPrefix, input);\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/proto/GoogleProtobufAny.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\n\nlibrary GoogleProtobufAny {\n    //struct definition\n    struct Data {\n        string type_url;\n        bytes value;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_type_url(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_type_url(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.type_url = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        //\n        // if `r` is NULL, then only counting the number of fields.\n        //\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_string(r.type_url, pointer, bs);\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.type_url).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        return e;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.type_url = input.type_url;\n        output.value = input.value;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n//library Any\n"
    },
    "contracts/bsc-tendermint/lib/proto/Proofs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\nimport \"./ProtoBufRuntime.sol\";\nimport \"./GoogleProtobufAny.sol\";\n\nlibrary ExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        bytes value;\n        LeafOp.Data leaf;\n        InnerOp.Data[] path;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.path = new InnerOp.Data[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.leaf = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_path(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerOp.Data memory x, uint256 sz) = _decode_InnerOp(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.path[r.path.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerOp(uint256 p, bytes memory bs) internal pure returns (InnerOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerOp.Data memory r, ) = InnerOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n        if (r.value.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf, pointer, bs);\n\n        if (r.path.length != 0) {\n            for (i = 0; i < r.path.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += InnerOp._encode_nested(r.path[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf));\n        for (i = 0; i < r.path.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(InnerOp._estimate(r.path[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        if (r.value.length != 0) {\n            return false;\n        }\n\n        if (r.path.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        output.value = input.value;\n        LeafOp.store(input.leaf, output.leaf);\n\n        for (uint256 i4 = 0; i4 < input.path.length; i4++) {\n            output.path.push(input.path[i4]);\n        }\n    }\n\n    //array helpers for Path\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addPath(Data memory self, InnerOp.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        InnerOp.Data[] memory tmp = new InnerOp.Data[](self.path.length + 1);\n        for (uint256 i = 0; i < self.path.length; i++) {\n            tmp[i] = self.path[i];\n        }\n        tmp[self.path.length] = value;\n        self.path = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ExistenceProof\n\nlibrary NonExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        ExistenceProof.Data left;\n        ExistenceProof.Data right;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_left(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_right(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_left(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.left = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_right(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.right = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.left, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.right, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.left));\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.right));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        ExistenceProof.store(input.left, output.left);\n        ExistenceProof.store(input.right, output.right);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library NonExistenceProof\n\nlibrary CommitmentProof {\n    //struct definition\n    struct Data {\n        ExistenceProof.Data exist;\n        NonExistenceProof.Data nonexist;\n        BatchProof.Data batch;\n        CompressedBatchProof.Data compressed;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_batch(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_compressed(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (NonExistenceProof.Data memory x, uint256 sz) = _decode_NonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_batch(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BatchProof.Data memory x, uint256 sz) = _decode_BatchProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.batch = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_compressed(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedBatchProof.Data memory x, uint256 sz) = _decode_CompressedBatchProof(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.compressed = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_NonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (NonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (NonExistenceProof.Data memory r, ) = NonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BatchProof(uint256 p, bytes memory bs) internal pure returns (BatchProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BatchProof.Data memory r, ) = BatchProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedBatchProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedBatchProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedBatchProof.Data memory r, ) = CompressedBatchProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += NonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BatchProof._encode_nested(r.batch, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedBatchProof._encode_nested(r.compressed, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(NonExistenceProof._estimate(r.nonexist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(BatchProof._estimate(r.batch));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedBatchProof._estimate(r.compressed));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        ExistenceProof.store(input.exist, output.exist);\n        NonExistenceProof.store(input.nonexist, output.nonexist);\n        BatchProof.store(input.batch, output.batch);\n        CompressedBatchProof.store(input.compressed, output.compressed);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CommitmentProof\n\nlibrary LeafOp {\n    //struct definition\n    struct Data {\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp prehash_key;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp prehash_value;\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp length;\n        bytes prefix;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[6] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_prehash_key(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_prehash_value(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_length(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_prefix(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prehash_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.prehash_key = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prehash_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.prehash_value = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.LengthOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_LengthOp(tmp);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.length = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prefix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[6] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.prefix = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        if (uint256(r.prehash_key) != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_prehash_key = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_key);\n            pointer += ProtoBufRuntime._encode_enum(_enum_prehash_key, pointer, bs);\n        }\n        if (uint256(r.prehash_value) != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_prehash_value = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_value);\n            pointer += ProtoBufRuntime._encode_enum(_enum_prehash_value, pointer, bs);\n        }\n        if (uint256(r.length) != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_length = PROOFS_PROTO_GLOBAL_ENUMS.encode_LengthOp(r.length);\n            pointer += ProtoBufRuntime._encode_enum(_enum_length, pointer, bs);\n        }\n        if (r.prefix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.prefix, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_key));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.prehash_value));\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_LengthOp(r.length));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.prefix.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        if (uint256(r.prehash_key) != 0) {\n            return false;\n        }\n\n        if (uint256(r.prehash_value) != 0) {\n            return false;\n        }\n\n        if (uint256(r.length) != 0) {\n            return false;\n        }\n\n        if (r.prefix.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        output.prehash_key = input.prehash_key;\n        output.prehash_value = input.prehash_value;\n        output.length = input.length;\n        output.prefix = input.prefix;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library LeafOp\n\nlibrary InnerOp {\n    //struct definition\n    struct Data {\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n        bytes prefix;\n        bytes suffix;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_prefix(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_suffix(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_prefix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.prefix = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_suffix(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.suffix = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        if (r.prefix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.prefix, pointer, bs);\n        }\n        if (r.suffix.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.suffix, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.prefix.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.suffix.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        if (r.prefix.length != 0) {\n            return false;\n        }\n\n        if (r.suffix.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        output.prefix = input.prefix;\n        output.suffix = input.suffix;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library InnerOp\n\nlibrary ProofSpec {\n    //struct definition\n    struct Data {\n        LeafOp.Data leaf_spec;\n        InnerSpec.Data inner_spec;\n        int32 max_depth;\n        int32 min_depth;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_leaf_spec(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_inner_spec(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_max_depth(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_min_depth(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf_spec(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.leaf_spec = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_inner_spec(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerSpec.Data memory x, uint256 sz) = _decode_InnerSpec(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.inner_spec = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_depth(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.max_depth = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_min_depth(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.min_depth = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerSpec(uint256 p, bytes memory bs) internal pure returns (InnerSpec.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerSpec.Data memory r, ) = InnerSpec._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf_spec, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += InnerSpec._encode_nested(r.inner_spec, pointer, bs);\n\n        if (r.max_depth != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.max_depth, pointer, bs);\n        }\n        if (r.min_depth != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.min_depth, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf_spec));\n        e += 1 + ProtoBufRuntime._sz_lendelim(InnerSpec._estimate(r.inner_spec));\n        e += 1 + ProtoBufRuntime._sz_int32(r.max_depth);\n        e += 1 + ProtoBufRuntime._sz_int32(r.min_depth);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.max_depth != 0) {\n            return false;\n        }\n\n        if (r.min_depth != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        LeafOp.store(input.leaf_spec, output.leaf_spec);\n        InnerSpec.store(input.inner_spec, output.inner_spec);\n        output.max_depth = input.max_depth;\n        output.min_depth = input.min_depth;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ProofSpec\n\nlibrary InnerSpec {\n    //struct definition\n    struct Data {\n        int32[] child_order;\n        int32 child_size;\n        int32 min_prefix_length;\n        int32 max_prefix_length;\n        bytes empty_child;\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[7] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_child_order(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_child_size(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_min_prefix_length(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_max_prefix_length(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_empty_child(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.child_order = new int32[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_child_order(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_child_size(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_min_prefix_length(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_max_prefix_length(pointer, bs, nil(), counters);\n            } else if (fieldId == 5) {\n                pointer += _read_empty_child(pointer, bs, nil(), counters);\n            } else if (fieldId == 6) {\n                pointer += _read_hash(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_child_order(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.child_order[r.child_order.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_child_size(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.child_size = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_min_prefix_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.min_prefix_length = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_prefix_length(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.max_prefix_length = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_empty_child(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.empty_child = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        PROOFS_PROTO_GLOBAL_ENUMS.HashOp x = PROOFS_PROTO_GLOBAL_ENUMS.decode_HashOp(tmp);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.hash = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.child_order.length != 0) {\n            for (i = 0; i < r.child_order.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n                pointer += ProtoBufRuntime._encode_int32(r.child_order[i], pointer, bs);\n            }\n        }\n        if (r.child_size != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.child_size, pointer, bs);\n        }\n        if (r.min_prefix_length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.min_prefix_length, pointer, bs);\n        }\n        if (r.max_prefix_length != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.max_prefix_length, pointer, bs);\n        }\n        if (r.empty_child.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.empty_child, pointer, bs);\n        }\n        if (uint256(r.hash) != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_hash = PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash);\n            pointer += ProtoBufRuntime._encode_enum(_enum_hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.child_order.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_int32(r.child_order[i]);\n        }\n        e += 1 + ProtoBufRuntime._sz_int32(r.child_size);\n        e += 1 + ProtoBufRuntime._sz_int32(r.min_prefix_length);\n        e += 1 + ProtoBufRuntime._sz_int32(r.max_prefix_length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.empty_child.length);\n        e += 1 + ProtoBufRuntime._sz_enum(PROOFS_PROTO_GLOBAL_ENUMS.encode_HashOp(r.hash));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.child_order.length != 0) {\n            return false;\n        }\n\n        if (r.child_size != 0) {\n            return false;\n        }\n\n        if (r.min_prefix_length != 0) {\n            return false;\n        }\n\n        if (r.max_prefix_length != 0) {\n            return false;\n        }\n\n        if (r.empty_child.length != 0) {\n            return false;\n        }\n\n        if (uint256(r.hash) != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.child_order = input.child_order;\n        output.child_size = input.child_size;\n        output.min_prefix_length = input.min_prefix_length;\n        output.max_prefix_length = input.max_prefix_length;\n        output.empty_child = input.empty_child;\n        output.hash = input.hash;\n    }\n\n    //array helpers for ChildOrder\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addChildOrder(Data memory self, int32 value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        int32[] memory tmp = new int32[](self.child_order.length + 1);\n        for (uint256 i = 0; i < self.child_order.length; i++) {\n            tmp[i] = self.child_order[i];\n        }\n        tmp[self.child_order.length] = value;\n        self.child_order = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library InnerSpec\n\nlibrary BatchProof {\n    //struct definition\n    struct Data {\n        BatchEntry.Data[] entries;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[2] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.entries = new BatchEntry.Data[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_entries(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[2] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BatchEntry.Data memory x, uint256 sz) = _decode_BatchEntry(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.entries[r.entries.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BatchEntry(uint256 p, bytes memory bs) internal pure returns (BatchEntry.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BatchEntry.Data memory r, ) = BatchEntry._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.entries.length != 0) {\n            for (i = 0; i < r.entries.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += BatchEntry._encode_nested(r.entries[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.entries.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(BatchEntry._estimate(r.entries[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.entries.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.entries.length; i1++) {\n            output.entries.push(input.entries[i1]);\n        }\n    }\n\n    //array helpers for Entries\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addEntries(Data memory self, BatchEntry.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        BatchEntry.Data[] memory tmp = new BatchEntry.Data[](self.entries.length + 1);\n        for (uint256 i = 0; i < self.entries.length; i++) {\n            tmp[i] = self.entries[i];\n        }\n        tmp[self.entries.length] = value;\n        self.entries = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BatchProof\n\nlibrary BatchEntry {\n    //struct definition\n    struct Data {\n        ExistenceProof.Data exist;\n        NonExistenceProof.Data nonexist;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ExistenceProof.Data memory x, uint256 sz) = _decode_ExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (NonExistenceProof.Data memory x, uint256 sz) = _decode_NonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ExistenceProof.Data memory r, ) = ExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_NonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (NonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (NonExistenceProof.Data memory r, ) = NonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += NonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(ExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(NonExistenceProof._estimate(r.nonexist));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        ExistenceProof.store(input.exist, output.exist);\n        NonExistenceProof.store(input.nonexist, output.nonexist);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BatchEntry\n\nlibrary CompressedBatchProof {\n    //struct definition\n    struct Data {\n        CompressedBatchEntry.Data[] entries;\n        InnerOp.Data[] lookup_inners;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_lookup_inners(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.entries = new CompressedBatchEntry.Data[](counters[1]);\n        r.lookup_inners = new InnerOp.Data[](counters[2]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_entries(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_lookup_inners(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_entries(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedBatchEntry.Data memory x, uint256 sz) = _decode_CompressedBatchEntry(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.entries[r.entries.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_lookup_inners(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (InnerOp.Data memory x, uint256 sz) = _decode_InnerOp(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.lookup_inners[r.lookup_inners.length - counters[2]] = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedBatchEntry(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedBatchEntry.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedBatchEntry.Data memory r, ) = CompressedBatchEntry._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_InnerOp(uint256 p, bytes memory bs) internal pure returns (InnerOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (InnerOp.Data memory r, ) = InnerOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.entries.length != 0) {\n            for (i = 0; i < r.entries.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += CompressedBatchEntry._encode_nested(r.entries[i], pointer, bs);\n            }\n        }\n        if (r.lookup_inners.length != 0) {\n            for (i = 0; i < r.lookup_inners.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += InnerOp._encode_nested(r.lookup_inners[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.entries.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(CompressedBatchEntry._estimate(r.entries[i]));\n        }\n        for (i = 0; i < r.lookup_inners.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(InnerOp._estimate(r.lookup_inners[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.entries.length != 0) {\n            return false;\n        }\n\n        if (r.lookup_inners.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.entries.length; i1++) {\n            output.entries.push(input.entries[i1]);\n        }\n\n        for (uint256 i2 = 0; i2 < input.lookup_inners.length; i2++) {\n            output.lookup_inners.push(input.lookup_inners[i2]);\n        }\n    }\n\n    //array helpers for Entries\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addEntries(Data memory self, CompressedBatchEntry.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        CompressedBatchEntry.Data[] memory tmp = new CompressedBatchEntry.Data[](self.entries.length + 1);\n        for (uint256 i = 0; i < self.entries.length; i++) {\n            tmp[i] = self.entries[i];\n        }\n        tmp[self.entries.length] = value;\n        self.entries = tmp;\n    }\n\n    //array helpers for LookupInners\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addLookupInners(Data memory self, InnerOp.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        InnerOp.Data[] memory tmp = new InnerOp.Data[](self.lookup_inners.length + 1);\n        for (uint256 i = 0; i < self.lookup_inners.length; i++) {\n            tmp[i] = self.lookup_inners[i];\n        }\n        tmp[self.lookup_inners.length] = value;\n        self.lookup_inners = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedBatchProof\n\nlibrary CompressedBatchEntry {\n    //struct definition\n    struct Data {\n        CompressedExistenceProof.Data exist;\n        CompressedNonExistenceProof.Data nonexist;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_exist(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nonexist(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_exist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.exist = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nonexist(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedNonExistenceProof.Data memory x, uint256 sz) = _decode_CompressedNonExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nonexist = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedExistenceProof.Data memory r, ) = CompressedExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedNonExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedNonExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedNonExistenceProof.Data memory r, ) = CompressedNonExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.exist, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedNonExistenceProof._encode_nested(r.nonexist, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.exist));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedNonExistenceProof._estimate(r.nonexist));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        CompressedExistenceProof.store(input.exist, output.exist);\n        CompressedNonExistenceProof.store(input.nonexist, output.nonexist);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedBatchEntry\n\nlibrary CompressedExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        bytes value;\n        LeafOp.Data leaf;\n        int32[] path;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.path = new int32[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_value(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_leaf(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_path(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_value(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.value = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_leaf(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LeafOp.Data memory x, uint256 sz) = _decode_LeafOp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.leaf = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_path(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.path[r.path.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LeafOp(uint256 p, bytes memory bs) internal pure returns (LeafOp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LeafOp.Data memory r, ) = LeafOp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n        if (r.value.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.value, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LeafOp._encode_nested(r.leaf, pointer, bs);\n\n        if (r.path.length != 0) {\n            for (i = 0; i < r.path.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n                pointer += ProtoBufRuntime._encode_int32(r.path[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.value.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(LeafOp._estimate(r.leaf));\n        for (i = 0; i < r.path.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_int32(r.path[i]);\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        if (r.value.length != 0) {\n            return false;\n        }\n\n        if (r.path.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        output.value = input.value;\n        LeafOp.store(input.leaf, output.leaf);\n        output.path = input.path;\n    }\n\n    //array helpers for Path\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addPath(Data memory self, int32 value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        int32[] memory tmp = new int32[](self.path.length + 1);\n        for (uint256 i = 0; i < self.path.length; i++) {\n            tmp[i] = self.path[i];\n        }\n        tmp[self.path.length] = value;\n        self.path = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedExistenceProof\n\nlibrary CompressedNonExistenceProof {\n    //struct definition\n    struct Data {\n        bytes key;\n        CompressedExistenceProof.Data left;\n        CompressedExistenceProof.Data right;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_left(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_right(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_left(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.left = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_right(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CompressedExistenceProof.Data memory x, uint256 sz) = _decode_CompressedExistenceProof(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.right = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CompressedExistenceProof(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CompressedExistenceProof.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CompressedExistenceProof.Data memory r, ) = CompressedExistenceProof._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.key.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.key, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.left, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CompressedExistenceProof._encode_nested(r.right, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.key.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.left));\n        e += 1 + ProtoBufRuntime._sz_lendelim(CompressedExistenceProof._estimate(r.right));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.key.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.key = input.key;\n        CompressedExistenceProof.store(input.left, output.left);\n        CompressedExistenceProof.store(input.right, output.right);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CompressedNonExistenceProof\n\nlibrary PROOFS_PROTO_GLOBAL_ENUMS {\n    //enum definition\n    // Solidity enum definitions\n    enum HashOp {\n        NO_HASH,\n        SHA256,\n        SHA512,\n        KECCAK,\n        RIPEMD160,\n        BITCOIN,\n        SHA512_256\n    }\n\n    // Solidity enum encoder\n    function encode_HashOp(HashOp x) internal pure returns (int32) {\n        if (x == HashOp.NO_HASH) {\n            return 0;\n        }\n\n        if (x == HashOp.SHA256) {\n            return 1;\n        }\n\n        if (x == HashOp.SHA512) {\n            return 2;\n        }\n\n        if (x == HashOp.KECCAK) {\n            return 3;\n        }\n\n        if (x == HashOp.RIPEMD160) {\n            return 4;\n        }\n\n        if (x == HashOp.BITCOIN) {\n            return 5;\n        }\n\n        if (x == HashOp.SHA512_256) {\n            return 6;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_HashOp(int64 x) internal pure returns (HashOp) {\n        if (x == 0) {\n            return HashOp.NO_HASH;\n        }\n\n        if (x == 1) {\n            return HashOp.SHA256;\n        }\n\n        if (x == 2) {\n            return HashOp.SHA512;\n        }\n\n        if (x == 3) {\n            return HashOp.KECCAK;\n        }\n\n        if (x == 4) {\n            return HashOp.RIPEMD160;\n        }\n\n        if (x == 5) {\n            return HashOp.BITCOIN;\n        }\n\n        if (x == 6) {\n            return HashOp.SHA512_256;\n        }\n        revert();\n    }\n\n    // Solidity enum definitions\n    enum LengthOp {\n        NO_PREFIX,\n        VAR_PROTO,\n        VAR_RLP,\n        FIXED32_BIG,\n        FIXED32_LITTLE,\n        FIXED64_BIG,\n        FIXED64_LITTLE,\n        REQUIRE_32_BYTES,\n        REQUIRE_64_BYTES\n    }\n\n    // Solidity enum encoder\n    function encode_LengthOp(LengthOp x) internal pure returns (int32) {\n        if (x == LengthOp.NO_PREFIX) {\n            return 0;\n        }\n\n        if (x == LengthOp.VAR_PROTO) {\n            return 1;\n        }\n\n        if (x == LengthOp.VAR_RLP) {\n            return 2;\n        }\n\n        if (x == LengthOp.FIXED32_BIG) {\n            return 3;\n        }\n\n        if (x == LengthOp.FIXED32_LITTLE) {\n            return 4;\n        }\n\n        if (x == LengthOp.FIXED64_BIG) {\n            return 5;\n        }\n\n        if (x == LengthOp.FIXED64_LITTLE) {\n            return 6;\n        }\n\n        if (x == LengthOp.REQUIRE_32_BYTES) {\n            return 7;\n        }\n\n        if (x == LengthOp.REQUIRE_64_BYTES) {\n            return 8;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_LengthOp(int64 x) internal pure returns (LengthOp) {\n        if (x == 0) {\n            return LengthOp.NO_PREFIX;\n        }\n\n        if (x == 1) {\n            return LengthOp.VAR_PROTO;\n        }\n\n        if (x == 2) {\n            return LengthOp.VAR_RLP;\n        }\n\n        if (x == 3) {\n            return LengthOp.FIXED32_BIG;\n        }\n\n        if (x == 4) {\n            return LengthOp.FIXED32_LITTLE;\n        }\n\n        if (x == 5) {\n            return LengthOp.FIXED64_BIG;\n        }\n\n        if (x == 6) {\n            return LengthOp.FIXED64_LITTLE;\n        }\n\n        if (x == 7) {\n            return LengthOp.REQUIRE_32_BYTES;\n        }\n\n        if (x == 8) {\n            return LengthOp.REQUIRE_64_BYTES;\n        }\n        revert();\n    }\n}\n//library PROOFS_PROTO_GLOBAL_ENUMS\n"
    },
    "contracts/bsc-tendermint/lib/proto/ProtoBufRuntime.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.2;\n\n/**\n * @title Runtime library for ProtoBuf serialization and/or deserialization.\n * All ProtoBuf generated code will use this library.\n */\nlibrary ProtoBufRuntime {\n    // Types defined in ProtoBuf\n    enum WireType {\n        Varint,\n        Fixed64,\n        LengthDelim,\n        StartGroup,\n        EndGroup,\n        Fixed32\n    }\n    // Constants for bytes calculation\n    uint256 constant WORD_LENGTH = 32;\n    uint256 constant HEADER_SIZE_LENGTH_IN_BYTES = 4;\n    uint256 constant BYTE_SIZE = 8;\n    uint256 constant REMAINING_LENGTH = WORD_LENGTH - HEADER_SIZE_LENGTH_IN_BYTES;\n    string constant OVERFLOW_MESSAGE = \"length overflow\";\n\n    //Storages\n    /**\n     * @dev Encode to storage location using assembly to save storage space.\n     * @param location The location of storage\n     * @param encoded The encoded ProtoBuf bytes\n     */\n    function encodeStorage(bytes storage location, bytes memory encoded) internal {\n        //\n        // This code use the first four bytes as size,\n        // and then put the rest of `encoded` bytes.\n        //\n        uint256 length = encoded.length;\n        uint256 firstWord;\n        uint256 wordLength = WORD_LENGTH;\n        uint256 remainingLength = REMAINING_LENGTH;\n\n        assembly {\n            firstWord := mload(add(encoded, wordLength))\n        }\n        firstWord =\n            (firstWord >> (BYTE_SIZE * HEADER_SIZE_LENGTH_IN_BYTES)) |\n            (length << (BYTE_SIZE * REMAINING_LENGTH));\n\n        assembly {\n            sstore(location.slot, firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    sstore(add(location.slot, slotIndex), mload(add(add(encoded, wordLength), offset)))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Decode storage location using assembly using the format in `encodeStorage`.\n     * @param location The location of storage\n     * @return The encoded bytes\n     */\n    function decodeStorage(bytes storage location) internal view returns (bytes memory) {\n        //\n        // This code is to decode the first four bytes as size,\n        // and then decode the rest using the decoded size.\n        //\n        uint256 firstWord;\n        uint256 remainingLength = REMAINING_LENGTH;\n        uint256 wordLength = WORD_LENGTH;\n\n        assembly {\n            firstWord := sload(location.slot)\n        }\n\n        uint256 length = firstWord >> (BYTE_SIZE * REMAINING_LENGTH);\n        bytes memory encoded = new bytes(length);\n\n        assembly {\n            mstore(add(encoded, remainingLength), firstWord)\n        }\n\n        if (length > REMAINING_LENGTH) {\n            length -= REMAINING_LENGTH;\n            for (uint256 i = 0; i < ceil(length, WORD_LENGTH); i++) {\n                assembly {\n                    let offset := add(mul(i, wordLength), remainingLength)\n                    let slotIndex := add(i, 1)\n                    mstore(add(add(encoded, wordLength), offset), sload(add(location.slot, slotIndex)))\n                }\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Fast memory copy of bytes using assembly.\n     * @param src The source memory address\n     * @param dest The destination memory address\n     * @param len The length of bytes to copy\n     */\n    function copyBytes(uint256 src, uint256 dest, uint256 len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= WORD_LENGTH; len -= WORD_LENGTH) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += WORD_LENGTH;\n            src += WORD_LENGTH;\n        }\n\n        // Copy remaining bytes\n        // TODO: There are two changes in solidity 0.8.x\n        // 1. exponential literal handling\n        // 2. overflow/underflow check enabled by default\n        //\n        // https://docs.soliditylang.org/en/latest/080-breaking-changes.html#how-to-update-your-code\n        //\n        // Here we have underflow / overflow and I don't yet know why. I tested:\n        //    uint256 WORD_LENGTH = 32;\n        //    uint256 len = 20;\n        //    uint256 mask =  256**(WORD_LENGTH - len) - 1;\n        //    uint256 mask2 = (256**(5)) - 1;\n        //    uint256 mask3 = 256**((5) - 1);\n        //\n        // all of them seem to return the same value, so I believe this is the overflow issue.\n        //\n        // To mitigate the issue I wrapped this in unchecked { }\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (WORD_LENGTH - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Use assembly to get memory address.\n     * @param r The in-memory bytes array\n     * @return The memory address of `r`\n     */\n    function getMemoryAddress(bytes memory r) internal pure returns (uint256) {\n        uint256 addr;\n        assembly {\n            addr := r\n        }\n        return addr;\n    }\n\n    /**\n     * @dev Implement Math function of ceil\n     * @param a The denominator\n     * @param m The numerator\n     * @return r The result of ceil(a/m)\n     */\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256 r) {\n        return (a + m - 1) / m;\n    }\n\n    // Decoders\n    /**\n     * This section of code `_decode_(u)int(32|64)`, `_decode_enum` and `_decode_bool`\n     * is to decode ProtoBuf native integers,\n     * using the `varint` encoding.\n     */\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint32(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        return (uint64(varint), sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int32 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        int64 r;\n        assembly {\n            r := varint\n        }\n        return (r, sz);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded enum's integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_enum(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        return _decode_int64(p, bs);\n    }\n\n    /**\n     * @dev Decode enum\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded boolean\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 varint, uint256 sz) = _decode_varint(p, bs);\n        if (varint == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    /**\n     * This section of code `_decode_sint(32|64)`\n     * is to decode ProtoBuf native signed integers,\n     * using the `zig-zag` encoding.\n     */\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int32(varint), sz);\n    }\n\n    /**\n     * @dev Decode signed integers\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_sint64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 varint, uint256 sz) = _decode_varints(p, bs);\n        return (int64(varint), sz);\n    }\n\n    /**\n     * @dev Decode string\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded string\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_string(uint256 p, bytes memory bs) internal pure returns (string memory, uint256) {\n        (bytes memory x, uint256 sz) = _decode_lendelim(p, bs);\n        return (string(x), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_bytes(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        return _decode_lendelim(p, bs);\n    }\n\n    /**\n     * @dev Decode ProtoBuf key\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded field ID\n     * @return The decoded WireType specified in ProtoBuf\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_key(uint256 p, bytes memory bs) internal pure returns (uint256, WireType, uint256) {\n        (uint256 x, uint256 n) = _decode_varint(p, bs);\n        WireType typeId = WireType(x & 7);\n        uint256 fieldId = x / 8;\n        return (fieldId, typeId, n);\n    }\n\n    /**\n     * @dev Decode ProtoBuf varint\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        //\n        // Read a byte.\n        // Use the lower 7 bits and shift it to the left,\n        // until the most significant bit is 0.\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 sz = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assembly {\n            let b := 0x80\n            p := add(bs, p)\n            for {\n\n            } eq(0x80, and(b, 0x80)) {\n\n            } {\n                if eq(lt(sub(p, bs), length), 0) {\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                    mstore(4, 32)\n                    mstore(36, 15)\n                    mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                    revert(0, 83)\n                }\n                let tmp := mload(p)\n                let pos := 0\n                for {\n\n                } and(eq(0x80, and(b, 0x80)), lt(pos, 32)) {\n\n                } {\n                    if eq(lt(sub(p, bs), length), 0) {\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) //error function selector\n                        mstore(4, 32)\n                        mstore(36, 15)\n                        mstore(68, 0x6c656e677468206f766572666c6f770000000000000000000000000000000000) // length overflow in hex\n                        revert(0, 83)\n                    }\n                    b := byte(pos, tmp)\n                    x := or(x, shl(mul(7, sz), and(0x7f, b)))\n                    sz := add(sz, 1)\n                    pos := add(pos, 1)\n                    p := add(p, 0x01)\n                }\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf zig-zag encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded signed integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_varints(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        (uint256 u, uint256 sz) = _decode_varint(p, bs);\n        int256 s;\n        assembly {\n            s := xor(shr(1, u), add(not(and(u, 1)), 1))\n        }\n        return (s, sz);\n    }\n\n    /**\n     * @dev Decode ProtoBuf fixed-length encoding\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded unsigned integer\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_uintf(uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256, uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 x = 0;\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz <= length);\n        assembly {\n            let i := 0\n            p := add(bs, p)\n            let tmp := mload(p)\n            for {\n\n            } lt(i, sz) {\n\n            } {\n                x := or(x, shl(mul(8, i), byte(i, tmp)))\n                p := add(p, 0x01)\n                i := add(i, 1)\n            }\n        }\n        return (x, sz);\n    }\n\n    /**\n     * `_decode_(s)fixed(32|64)` is the concrete implementation of `_decode_uintf`\n     */\n    function _decode_fixed32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        return (uint32(x), sz);\n    }\n\n    function _decode_fixed64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        return (uint64(x), sz);\n    }\n\n    function _decode_sfixed32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 4);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int32(r), sz);\n    }\n\n    function _decode_sfixed64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (uint256 x, uint256 sz) = _decode_uintf(p, bs, 8);\n        int256 r;\n        assembly {\n            r := x\n        }\n        return (int64(r), sz);\n    }\n\n    /**\n     * @dev Decode bytes array\n     * @param p The memory offset of `bs`\n     * @param bs The bytes array to be decoded\n     * @return The decoded bytes array\n     * @return The length of `bs` used to get decoded\n     */\n    function _decode_lendelim(uint256 p, bytes memory bs) internal pure returns (bytes memory, uint256) {\n        //\n        // First read the size encoded in `varint`, then use the size to read bytes.\n        //\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        bytes memory b = new bytes(len);\n        uint256 length = bs.length + WORD_LENGTH;\n        assert(p + sz + len <= length);\n        uint256 sourcePtr;\n        uint256 destPtr;\n        assembly {\n            destPtr := add(b, 32)\n            sourcePtr := add(add(bs, p), sz)\n        }\n        copyBytes(sourcePtr, destPtr, len);\n        return (b, sz + len);\n    }\n\n    // Encoders\n    /**\n     * @dev Encode ProtoBuf key\n     * @param x The field ID\n     * @param wt The WireType specified in ProtoBuf\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_key(uint256 x, WireType wt, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 i;\n        assembly {\n            i := or(mul(x, 8), mod(wt, 8))\n        }\n        return _encode_varint(i, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf varint\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varint(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 sz = 0;\n        assembly {\n            let bsptr := add(bs, p)\n            let byt := and(x, 0x7f)\n            for {\n\n            } gt(shr(7, x), 0) {\n\n            } {\n                mstore8(bsptr, or(0x80, byt))\n                bsptr := add(bsptr, 1)\n                sz := add(sz, 1)\n                x := shr(7, x)\n                byt := and(x, 0x7f)\n            }\n            mstore8(bsptr, byt)\n            sz := add(sz, 1)\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag encoding\n     * @param x The signed integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_varints(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // Refer to https://developers.google.com/protocol-buffers/docs/encoding\n        //\n        uint256 encodedInt = _encode_zigzag(x);\n        return _encode_varint(encodedInt, p, bs);\n    }\n\n    /**\n     * @dev Encode ProtoBuf bytes\n     * @param xs The bytes array to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_bytes(bytes memory xs, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 xsLength = xs.length;\n        uint256 sz = _encode_varint(xsLength, p, bs);\n        uint256 count = 0;\n        assembly {\n            let bsptr := add(bs, add(p, sz))\n            let xsptr := add(xs, 32)\n            for {\n\n            } lt(count, xsLength) {\n\n            } {\n                mstore8(bsptr, byte(0, mload(xsptr)))\n                bsptr := add(bsptr, 1)\n                xsptr := add(xsptr, 1)\n                count := add(count, 1)\n            }\n        }\n        return sz + count;\n    }\n\n    /**\n     * @dev Encode ProtoBuf string\n     * @param xs The string to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_string(string memory xs, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_bytes(bytes(xs), p, bs);\n    }\n\n    //\n    // `_encode_(u)int(32|64)`, `_encode_enum` and `_encode_bool`\n    // are concrete implementation of `_encode_varint`\n    //\n    function _encode_uint32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_uint64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varint(x, p, bs);\n    }\n\n    function _encode_int32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_int64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_varint(twosComplement, p, bs);\n    }\n\n    function _encode_enum(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_int32(x, p, bs);\n    }\n\n    function _encode_bool(bool x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        if (x) {\n            return _encode_varint(1, p, bs);\n        } else return _encode_varint(0, p, bs);\n    }\n\n    //\n    // `_encode_sint(32|64)`, `_encode_enum` and `_encode_bool`\n    // are the concrete implementation of `_encode_varints`\n    //\n    function _encode_sint32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    function _encode_sint64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_varints(x, p, bs);\n    }\n\n    //\n    // `_encode_(s)fixed(32|64)` is the concrete implementation of `_encode_uintf`\n    //\n    function _encode_fixed32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 4);\n    }\n\n    function _encode_fixed64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_uintf(x, p, bs, 8);\n    }\n\n    function _encode_sfixed32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint32 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 4);\n    }\n\n    function _encode_sfixed64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint64 twosComplement;\n        assembly {\n            twosComplement := x\n        }\n        return _encode_uintf(twosComplement, p, bs, 8);\n    }\n\n    /**\n     * @dev Encode ProtoBuf fixed-length integer\n     * @param x The unsigned integer to be encoded\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The length of encoded bytes\n     */\n    function _encode_uintf(uint256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        assembly {\n            let bsptr := add(sz, add(bs, p))\n            let count := sz\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                bsptr := sub(bsptr, 1)\n                mstore8(bsptr, byte(sub(32, count), x))\n                count := sub(count, 1)\n            }\n        }\n        return sz;\n    }\n\n    /**\n     * @dev Encode ProtoBuf zig-zag signed integer\n     * @param i The unsigned integer to be encoded\n     * @return The encoded unsigned integer\n     */\n    function _encode_zigzag(int256 i) internal pure returns (uint256) {\n        if (i >= 0) {\n            return uint256(i) * 2;\n        } else return uint256(i * -2) - 1;\n    }\n\n    // Estimators\n    /**\n     * @dev Estimate the length of encoded LengthDelim\n     * @param i The length of LengthDelim\n     * @return The estimated encoded length\n     */\n    function _sz_lendelim(uint256 i) internal pure returns (uint256) {\n        return i + _sz_varint(i);\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf field ID\n     * @param i The field ID\n     * @return The estimated encoded length\n     */\n    function _sz_key(uint256 i) internal pure returns (uint256) {\n        if (i < 16) {\n            return 1;\n        } else if (i < 2048) {\n            return 2;\n        } else if (i < 262144) {\n            return 3;\n        } else {\n            revert(\"not supported\");\n        }\n    }\n\n    /**\n     * @dev Estimate the length of encoded ProtoBuf varint\n     * @param i The unsigned integer\n     * @return The estimated encoded length\n     */\n    function _sz_varint(uint256 i) internal pure returns (uint256) {\n        uint256 count = 1;\n        assembly {\n            i := shr(7, i)\n            for {\n\n            } gt(i, 0) {\n\n            } {\n                i := shr(7, i)\n                count := add(count, 1)\n            }\n        }\n        return count;\n    }\n\n    /**\n     * `_sz_(u)int(32|64)` and `_sz_enum` are the concrete implementation of `_sz_varint`\n     */\n    function _sz_uint32(uint32 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_uint64(uint64 i) internal pure returns (uint256) {\n        return _sz_varint(i);\n    }\n\n    function _sz_int32(int32 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint32(i));\n    }\n\n    function _sz_int64(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    function _sz_enum(int64 i) internal pure returns (uint256) {\n        if (i < 0) {\n            return 10;\n        } else return _sz_varint(uint64(i));\n    }\n\n    /**\n     * `_sz_sint(32|64)` and `_sz_enum` are the concrete implementation of zig-zag encoding\n     */\n    function _sz_sint32(int32 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    function _sz_sint64(int64 i) internal pure returns (uint256) {\n        return _sz_varint(_encode_zigzag(i));\n    }\n\n    // Soltype extensions\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from lowest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN_lower(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        uint256 r;\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            r := mload(add(p, bs))\n        }\n        for (uint256 i = len - 2; i < WORD_LENGTH; i++) {\n            r /= 256;\n        }\n        return (bytes32(r), len + sz);\n    }\n\n    /**\n     * @dev Decode Solidity integer and/or fixed-size bytes array, filling from highest bit.\n     * @param n The maximum number of bytes to read\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The bytes32 representation\n     * @return The number of bytes used to decode\n     */\n    function _decode_sol_bytesN(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        (uint256 len, uint256 sz) = _decode_varint(p, bs);\n        uint256 wordLength = WORD_LENGTH;\n        uint256 byteSize = BYTE_SIZE;\n        if (len + sz > n + 3) {\n            revert(OVERFLOW_MESSAGE);\n        }\n        p += 3;\n        bytes32 acc;\n        assert(p < bs.length + WORD_LENGTH);\n        assembly {\n            acc := mload(add(p, bs))\n            let difference := sub(wordLength, sub(len, 2))\n            let bits := mul(byteSize, difference)\n            acc := shl(bits, shr(bits, acc))\n        }\n        return (acc, len + sz);\n    }\n\n    /*\n     * `_decode_sol*` are the concrete implementation of decoding Solidity types\n     */\n    function _decode_sol_address(uint256 p, bytes memory bs) internal pure returns (address, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytesN(20, p, bs);\n        return (address(bytes20(r)), sz);\n    }\n\n    function _decode_sol_bool(uint256 p, bytes memory bs) internal pure returns (bool, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        if (r == 0) {\n            return (false, sz);\n        }\n        return (true, sz);\n    }\n\n    function _decode_sol_uint(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        return _decode_sol_uint256(p, bs);\n    }\n\n    function _decode_sol_uintN(uint8 n, uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        uint256 r;\n        assembly {\n            r := u\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_uint8(uint256 p, bytes memory bs) internal pure returns (uint8, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(1, p, bs);\n        return (uint8(r), sz);\n    }\n\n    function _decode_sol_uint16(uint256 p, bytes memory bs) internal pure returns (uint16, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(2, p, bs);\n        return (uint16(r), sz);\n    }\n\n    function _decode_sol_uint24(uint256 p, bytes memory bs) internal pure returns (uint24, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(3, p, bs);\n        return (uint24(r), sz);\n    }\n\n    function _decode_sol_uint32(uint256 p, bytes memory bs) internal pure returns (uint32, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(4, p, bs);\n        return (uint32(r), sz);\n    }\n\n    function _decode_sol_uint40(uint256 p, bytes memory bs) internal pure returns (uint40, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(5, p, bs);\n        return (uint40(r), sz);\n    }\n\n    function _decode_sol_uint48(uint256 p, bytes memory bs) internal pure returns (uint48, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(6, p, bs);\n        return (uint48(r), sz);\n    }\n\n    function _decode_sol_uint56(uint256 p, bytes memory bs) internal pure returns (uint56, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(7, p, bs);\n        return (uint56(r), sz);\n    }\n\n    function _decode_sol_uint64(uint256 p, bytes memory bs) internal pure returns (uint64, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(8, p, bs);\n        return (uint64(r), sz);\n    }\n\n    function _decode_sol_uint72(uint256 p, bytes memory bs) internal pure returns (uint72, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(9, p, bs);\n        return (uint72(r), sz);\n    }\n\n    function _decode_sol_uint80(uint256 p, bytes memory bs) internal pure returns (uint80, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(10, p, bs);\n        return (uint80(r), sz);\n    }\n\n    function _decode_sol_uint88(uint256 p, bytes memory bs) internal pure returns (uint88, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(11, p, bs);\n        return (uint88(r), sz);\n    }\n\n    function _decode_sol_uint96(uint256 p, bytes memory bs) internal pure returns (uint96, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(12, p, bs);\n        return (uint96(r), sz);\n    }\n\n    function _decode_sol_uint104(uint256 p, bytes memory bs) internal pure returns (uint104, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(13, p, bs);\n        return (uint104(r), sz);\n    }\n\n    function _decode_sol_uint112(uint256 p, bytes memory bs) internal pure returns (uint112, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(14, p, bs);\n        return (uint112(r), sz);\n    }\n\n    function _decode_sol_uint120(uint256 p, bytes memory bs) internal pure returns (uint120, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(15, p, bs);\n        return (uint120(r), sz);\n    }\n\n    function _decode_sol_uint128(uint256 p, bytes memory bs) internal pure returns (uint128, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(16, p, bs);\n        return (uint128(r), sz);\n    }\n\n    function _decode_sol_uint136(uint256 p, bytes memory bs) internal pure returns (uint136, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(17, p, bs);\n        return (uint136(r), sz);\n    }\n\n    function _decode_sol_uint144(uint256 p, bytes memory bs) internal pure returns (uint144, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(18, p, bs);\n        return (uint144(r), sz);\n    }\n\n    function _decode_sol_uint152(uint256 p, bytes memory bs) internal pure returns (uint152, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(19, p, bs);\n        return (uint152(r), sz);\n    }\n\n    function _decode_sol_uint160(uint256 p, bytes memory bs) internal pure returns (uint160, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(20, p, bs);\n        return (uint160(r), sz);\n    }\n\n    function _decode_sol_uint168(uint256 p, bytes memory bs) internal pure returns (uint168, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(21, p, bs);\n        return (uint168(r), sz);\n    }\n\n    function _decode_sol_uint176(uint256 p, bytes memory bs) internal pure returns (uint176, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(22, p, bs);\n        return (uint176(r), sz);\n    }\n\n    function _decode_sol_uint184(uint256 p, bytes memory bs) internal pure returns (uint184, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(23, p, bs);\n        return (uint184(r), sz);\n    }\n\n    function _decode_sol_uint192(uint256 p, bytes memory bs) internal pure returns (uint192, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(24, p, bs);\n        return (uint192(r), sz);\n    }\n\n    function _decode_sol_uint200(uint256 p, bytes memory bs) internal pure returns (uint200, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(25, p, bs);\n        return (uint200(r), sz);\n    }\n\n    function _decode_sol_uint208(uint256 p, bytes memory bs) internal pure returns (uint208, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(26, p, bs);\n        return (uint208(r), sz);\n    }\n\n    function _decode_sol_uint216(uint256 p, bytes memory bs) internal pure returns (uint216, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(27, p, bs);\n        return (uint216(r), sz);\n    }\n\n    function _decode_sol_uint224(uint256 p, bytes memory bs) internal pure returns (uint224, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(28, p, bs);\n        return (uint224(r), sz);\n    }\n\n    function _decode_sol_uint232(uint256 p, bytes memory bs) internal pure returns (uint232, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(29, p, bs);\n        return (uint232(r), sz);\n    }\n\n    function _decode_sol_uint240(uint256 p, bytes memory bs) internal pure returns (uint240, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(30, p, bs);\n        return (uint240(r), sz);\n    }\n\n    function _decode_sol_uint248(uint256 p, bytes memory bs) internal pure returns (uint248, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(31, p, bs);\n        return (uint248(r), sz);\n    }\n\n    function _decode_sol_uint256(uint256 p, bytes memory bs) internal pure returns (uint256, uint256) {\n        (uint256 r, uint256 sz) = _decode_sol_uintN(32, p, bs);\n        return (uint256(r), sz);\n    }\n\n    function _decode_sol_int(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        return _decode_sol_int256(p, bs);\n    }\n\n    function _decode_sol_intN(uint8 n, uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN_lower(n, p, bs);\n        int256 r;\n        assembly {\n            r := u\n            r := signextend(sub(sz, 4), r)\n        }\n        return (r, sz);\n    }\n\n    function _decode_sol_bytes(uint8 n, uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        (bytes32 u, uint256 sz) = _decode_sol_bytesN(n, p, bs);\n        return (u, sz);\n    }\n\n    function _decode_sol_int8(uint256 p, bytes memory bs) internal pure returns (int8, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(1, p, bs);\n        return (int8(r), sz);\n    }\n\n    function _decode_sol_int16(uint256 p, bytes memory bs) internal pure returns (int16, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(2, p, bs);\n        return (int16(r), sz);\n    }\n\n    function _decode_sol_int24(uint256 p, bytes memory bs) internal pure returns (int24, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(3, p, bs);\n        return (int24(r), sz);\n    }\n\n    function _decode_sol_int32(uint256 p, bytes memory bs) internal pure returns (int32, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(4, p, bs);\n        return (int32(r), sz);\n    }\n\n    function _decode_sol_int40(uint256 p, bytes memory bs) internal pure returns (int40, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(5, p, bs);\n        return (int40(r), sz);\n    }\n\n    function _decode_sol_int48(uint256 p, bytes memory bs) internal pure returns (int48, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(6, p, bs);\n        return (int48(r), sz);\n    }\n\n    function _decode_sol_int56(uint256 p, bytes memory bs) internal pure returns (int56, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(7, p, bs);\n        return (int56(r), sz);\n    }\n\n    function _decode_sol_int64(uint256 p, bytes memory bs) internal pure returns (int64, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(8, p, bs);\n        return (int64(r), sz);\n    }\n\n    function _decode_sol_int72(uint256 p, bytes memory bs) internal pure returns (int72, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(9, p, bs);\n        return (int72(r), sz);\n    }\n\n    function _decode_sol_int80(uint256 p, bytes memory bs) internal pure returns (int80, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(10, p, bs);\n        return (int80(r), sz);\n    }\n\n    function _decode_sol_int88(uint256 p, bytes memory bs) internal pure returns (int88, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(11, p, bs);\n        return (int88(r), sz);\n    }\n\n    function _decode_sol_int96(uint256 p, bytes memory bs) internal pure returns (int96, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(12, p, bs);\n        return (int96(r), sz);\n    }\n\n    function _decode_sol_int104(uint256 p, bytes memory bs) internal pure returns (int104, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(13, p, bs);\n        return (int104(r), sz);\n    }\n\n    function _decode_sol_int112(uint256 p, bytes memory bs) internal pure returns (int112, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(14, p, bs);\n        return (int112(r), sz);\n    }\n\n    function _decode_sol_int120(uint256 p, bytes memory bs) internal pure returns (int120, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(15, p, bs);\n        return (int120(r), sz);\n    }\n\n    function _decode_sol_int128(uint256 p, bytes memory bs) internal pure returns (int128, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(16, p, bs);\n        return (int128(r), sz);\n    }\n\n    function _decode_sol_int136(uint256 p, bytes memory bs) internal pure returns (int136, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(17, p, bs);\n        return (int136(r), sz);\n    }\n\n    function _decode_sol_int144(uint256 p, bytes memory bs) internal pure returns (int144, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(18, p, bs);\n        return (int144(r), sz);\n    }\n\n    function _decode_sol_int152(uint256 p, bytes memory bs) internal pure returns (int152, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(19, p, bs);\n        return (int152(r), sz);\n    }\n\n    function _decode_sol_int160(uint256 p, bytes memory bs) internal pure returns (int160, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(20, p, bs);\n        return (int160(r), sz);\n    }\n\n    function _decode_sol_int168(uint256 p, bytes memory bs) internal pure returns (int168, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(21, p, bs);\n        return (int168(r), sz);\n    }\n\n    function _decode_sol_int176(uint256 p, bytes memory bs) internal pure returns (int176, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(22, p, bs);\n        return (int176(r), sz);\n    }\n\n    function _decode_sol_int184(uint256 p, bytes memory bs) internal pure returns (int184, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(23, p, bs);\n        return (int184(r), sz);\n    }\n\n    function _decode_sol_int192(uint256 p, bytes memory bs) internal pure returns (int192, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(24, p, bs);\n        return (int192(r), sz);\n    }\n\n    function _decode_sol_int200(uint256 p, bytes memory bs) internal pure returns (int200, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(25, p, bs);\n        return (int200(r), sz);\n    }\n\n    function _decode_sol_int208(uint256 p, bytes memory bs) internal pure returns (int208, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(26, p, bs);\n        return (int208(r), sz);\n    }\n\n    function _decode_sol_int216(uint256 p, bytes memory bs) internal pure returns (int216, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(27, p, bs);\n        return (int216(r), sz);\n    }\n\n    function _decode_sol_int224(uint256 p, bytes memory bs) internal pure returns (int224, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(28, p, bs);\n        return (int224(r), sz);\n    }\n\n    function _decode_sol_int232(uint256 p, bytes memory bs) internal pure returns (int232, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(29, p, bs);\n        return (int232(r), sz);\n    }\n\n    function _decode_sol_int240(uint256 p, bytes memory bs) internal pure returns (int240, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(30, p, bs);\n        return (int240(r), sz);\n    }\n\n    function _decode_sol_int248(uint256 p, bytes memory bs) internal pure returns (int248, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(31, p, bs);\n        return (int248(r), sz);\n    }\n\n    function _decode_sol_int256(uint256 p, bytes memory bs) internal pure returns (int256, uint256) {\n        (int256 r, uint256 sz) = _decode_sol_intN(32, p, bs);\n        return (int256(r), sz);\n    }\n\n    function _decode_sol_bytes1(uint256 p, bytes memory bs) internal pure returns (bytes1, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(1, p, bs);\n        return (bytes1(r), sz);\n    }\n\n    function _decode_sol_bytes2(uint256 p, bytes memory bs) internal pure returns (bytes2, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(2, p, bs);\n        return (bytes2(r), sz);\n    }\n\n    function _decode_sol_bytes3(uint256 p, bytes memory bs) internal pure returns (bytes3, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(3, p, bs);\n        return (bytes3(r), sz);\n    }\n\n    function _decode_sol_bytes4(uint256 p, bytes memory bs) internal pure returns (bytes4, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(4, p, bs);\n        return (bytes4(r), sz);\n    }\n\n    function _decode_sol_bytes5(uint256 p, bytes memory bs) internal pure returns (bytes5, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(5, p, bs);\n        return (bytes5(r), sz);\n    }\n\n    function _decode_sol_bytes6(uint256 p, bytes memory bs) internal pure returns (bytes6, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(6, p, bs);\n        return (bytes6(r), sz);\n    }\n\n    function _decode_sol_bytes7(uint256 p, bytes memory bs) internal pure returns (bytes7, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(7, p, bs);\n        return (bytes7(r), sz);\n    }\n\n    function _decode_sol_bytes8(uint256 p, bytes memory bs) internal pure returns (bytes8, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(8, p, bs);\n        return (bytes8(r), sz);\n    }\n\n    function _decode_sol_bytes9(uint256 p, bytes memory bs) internal pure returns (bytes9, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(9, p, bs);\n        return (bytes9(r), sz);\n    }\n\n    function _decode_sol_bytes10(uint256 p, bytes memory bs) internal pure returns (bytes10, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(10, p, bs);\n        return (bytes10(r), sz);\n    }\n\n    function _decode_sol_bytes11(uint256 p, bytes memory bs) internal pure returns (bytes11, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(11, p, bs);\n        return (bytes11(r), sz);\n    }\n\n    function _decode_sol_bytes12(uint256 p, bytes memory bs) internal pure returns (bytes12, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(12, p, bs);\n        return (bytes12(r), sz);\n    }\n\n    function _decode_sol_bytes13(uint256 p, bytes memory bs) internal pure returns (bytes13, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(13, p, bs);\n        return (bytes13(r), sz);\n    }\n\n    function _decode_sol_bytes14(uint256 p, bytes memory bs) internal pure returns (bytes14, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(14, p, bs);\n        return (bytes14(r), sz);\n    }\n\n    function _decode_sol_bytes15(uint256 p, bytes memory bs) internal pure returns (bytes15, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(15, p, bs);\n        return (bytes15(r), sz);\n    }\n\n    function _decode_sol_bytes16(uint256 p, bytes memory bs) internal pure returns (bytes16, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(16, p, bs);\n        return (bytes16(r), sz);\n    }\n\n    function _decode_sol_bytes17(uint256 p, bytes memory bs) internal pure returns (bytes17, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(17, p, bs);\n        return (bytes17(r), sz);\n    }\n\n    function _decode_sol_bytes18(uint256 p, bytes memory bs) internal pure returns (bytes18, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(18, p, bs);\n        return (bytes18(r), sz);\n    }\n\n    function _decode_sol_bytes19(uint256 p, bytes memory bs) internal pure returns (bytes19, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(19, p, bs);\n        return (bytes19(r), sz);\n    }\n\n    function _decode_sol_bytes20(uint256 p, bytes memory bs) internal pure returns (bytes20, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(20, p, bs);\n        return (bytes20(r), sz);\n    }\n\n    function _decode_sol_bytes21(uint256 p, bytes memory bs) internal pure returns (bytes21, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(21, p, bs);\n        return (bytes21(r), sz);\n    }\n\n    function _decode_sol_bytes22(uint256 p, bytes memory bs) internal pure returns (bytes22, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(22, p, bs);\n        return (bytes22(r), sz);\n    }\n\n    function _decode_sol_bytes23(uint256 p, bytes memory bs) internal pure returns (bytes23, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(23, p, bs);\n        return (bytes23(r), sz);\n    }\n\n    function _decode_sol_bytes24(uint256 p, bytes memory bs) internal pure returns (bytes24, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(24, p, bs);\n        return (bytes24(r), sz);\n    }\n\n    function _decode_sol_bytes25(uint256 p, bytes memory bs) internal pure returns (bytes25, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(25, p, bs);\n        return (bytes25(r), sz);\n    }\n\n    function _decode_sol_bytes26(uint256 p, bytes memory bs) internal pure returns (bytes26, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(26, p, bs);\n        return (bytes26(r), sz);\n    }\n\n    function _decode_sol_bytes27(uint256 p, bytes memory bs) internal pure returns (bytes27, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(27, p, bs);\n        return (bytes27(r), sz);\n    }\n\n    function _decode_sol_bytes28(uint256 p, bytes memory bs) internal pure returns (bytes28, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(28, p, bs);\n        return (bytes28(r), sz);\n    }\n\n    function _decode_sol_bytes29(uint256 p, bytes memory bs) internal pure returns (bytes29, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(29, p, bs);\n        return (bytes29(r), sz);\n    }\n\n    function _decode_sol_bytes30(uint256 p, bytes memory bs) internal pure returns (bytes30, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(30, p, bs);\n        return (bytes30(r), sz);\n    }\n\n    function _decode_sol_bytes31(uint256 p, bytes memory bs) internal pure returns (bytes31, uint256) {\n        (bytes32 r, uint256 sz) = _decode_sol_bytes(31, p, bs);\n        return (bytes31(r), sz);\n    }\n\n    function _decode_sol_bytes32(uint256 p, bytes memory bs) internal pure returns (bytes32, uint256) {\n        return _decode_sol_bytes(32, p, bs);\n    }\n\n    /*\n     * `_encode_sol*` are the concrete implementation of encoding Solidity types\n     */\n    function _encode_sol_address(address x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(uint160(x)), 20, p, bs);\n    }\n\n    function _encode_sol_uint(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_uint8(uint8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 1, p, bs);\n    }\n\n    function _encode_sol_uint16(uint16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 2, p, bs);\n    }\n\n    function _encode_sol_uint24(uint24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 3, p, bs);\n    }\n\n    function _encode_sol_uint32(uint32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 4, p, bs);\n    }\n\n    function _encode_sol_uint40(uint40 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 5, p, bs);\n    }\n\n    function _encode_sol_uint48(uint48 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 6, p, bs);\n    }\n\n    function _encode_sol_uint56(uint56 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 7, p, bs);\n    }\n\n    function _encode_sol_uint64(uint64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 8, p, bs);\n    }\n\n    function _encode_sol_uint72(uint72 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 9, p, bs);\n    }\n\n    function _encode_sol_uint80(uint80 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 10, p, bs);\n    }\n\n    function _encode_sol_uint88(uint88 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 11, p, bs);\n    }\n\n    function _encode_sol_uint96(uint96 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 12, p, bs);\n    }\n\n    function _encode_sol_uint104(uint104 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 13, p, bs);\n    }\n\n    function _encode_sol_uint112(uint112 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 14, p, bs);\n    }\n\n    function _encode_sol_uint120(uint120 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 15, p, bs);\n    }\n\n    function _encode_sol_uint128(uint128 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 16, p, bs);\n    }\n\n    function _encode_sol_uint136(uint136 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 17, p, bs);\n    }\n\n    function _encode_sol_uint144(uint144 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 18, p, bs);\n    }\n\n    function _encode_sol_uint152(uint152 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 19, p, bs);\n    }\n\n    function _encode_sol_uint160(uint160 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 20, p, bs);\n    }\n\n    function _encode_sol_uint168(uint168 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 21, p, bs);\n    }\n\n    function _encode_sol_uint176(uint176 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 22, p, bs);\n    }\n\n    function _encode_sol_uint184(uint184 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 23, p, bs);\n    }\n\n    function _encode_sol_uint192(uint192 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 24, p, bs);\n    }\n\n    function _encode_sol_uint200(uint200 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 25, p, bs);\n    }\n\n    function _encode_sol_uint208(uint208 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 26, p, bs);\n    }\n\n    function _encode_sol_uint216(uint216 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 27, p, bs);\n    }\n\n    function _encode_sol_uint224(uint224 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 28, p, bs);\n    }\n\n    function _encode_sol_uint232(uint232 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 29, p, bs);\n    }\n\n    function _encode_sol_uint240(uint240 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 30, p, bs);\n    }\n\n    function _encode_sol_uint248(uint248 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 31, p, bs);\n    }\n\n    function _encode_sol_uint256(uint256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(uint256(x), 32, p, bs);\n    }\n\n    function _encode_sol_int(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_int8(int8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 1, p, bs);\n    }\n\n    function _encode_sol_int16(int16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 2, p, bs);\n    }\n\n    function _encode_sol_int24(int24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 3, p, bs);\n    }\n\n    function _encode_sol_int32(int32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 4, p, bs);\n    }\n\n    function _encode_sol_int40(int40 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 5, p, bs);\n    }\n\n    function _encode_sol_int48(int48 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 6, p, bs);\n    }\n\n    function _encode_sol_int56(int56 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 7, p, bs);\n    }\n\n    function _encode_sol_int64(int64 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 8, p, bs);\n    }\n\n    function _encode_sol_int72(int72 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 9, p, bs);\n    }\n\n    function _encode_sol_int80(int80 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 10, p, bs);\n    }\n\n    function _encode_sol_int88(int88 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 11, p, bs);\n    }\n\n    function _encode_sol_int96(int96 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 12, p, bs);\n    }\n\n    function _encode_sol_int104(int104 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 13, p, bs);\n    }\n\n    function _encode_sol_int112(int112 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 14, p, bs);\n    }\n\n    function _encode_sol_int120(int120 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 15, p, bs);\n    }\n\n    function _encode_sol_int128(int128 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 16, p, bs);\n    }\n\n    function _encode_sol_int136(int136 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 17, p, bs);\n    }\n\n    function _encode_sol_int144(int144 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 18, p, bs);\n    }\n\n    function _encode_sol_int152(int152 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 19, p, bs);\n    }\n\n    function _encode_sol_int160(int160 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 20, p, bs);\n    }\n\n    function _encode_sol_int168(int168 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 21, p, bs);\n    }\n\n    function _encode_sol_int176(int176 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 22, p, bs);\n    }\n\n    function _encode_sol_int184(int184 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 23, p, bs);\n    }\n\n    function _encode_sol_int192(int192 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 24, p, bs);\n    }\n\n    function _encode_sol_int200(int200 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 25, p, bs);\n    }\n\n    function _encode_sol_int208(int208 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 26, p, bs);\n    }\n\n    function _encode_sol_int216(int216 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 27, p, bs);\n    }\n\n    function _encode_sol_int224(int224 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 28, p, bs);\n    }\n\n    function _encode_sol_int232(int232 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 29, p, bs);\n    }\n\n    function _encode_sol_int240(int240 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 30, p, bs);\n    }\n\n    function _encode_sol_int248(int248 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(int256(x), 31, p, bs);\n    }\n\n    function _encode_sol_int256(int256 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol(x, 32, p, bs);\n    }\n\n    function _encode_sol_bytes1(bytes1 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 1, p, bs);\n    }\n\n    function _encode_sol_bytes2(bytes2 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 2, p, bs);\n    }\n\n    function _encode_sol_bytes3(bytes3 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 3, p, bs);\n    }\n\n    function _encode_sol_bytes4(bytes4 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 4, p, bs);\n    }\n\n    function _encode_sol_bytes5(bytes5 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 5, p, bs);\n    }\n\n    function _encode_sol_bytes6(bytes6 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 6, p, bs);\n    }\n\n    function _encode_sol_bytes7(bytes7 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 7, p, bs);\n    }\n\n    function _encode_sol_bytes8(bytes8 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 8, p, bs);\n    }\n\n    function _encode_sol_bytes9(bytes9 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 9, p, bs);\n    }\n\n    function _encode_sol_bytes10(bytes10 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 10, p, bs);\n    }\n\n    function _encode_sol_bytes11(bytes11 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 11, p, bs);\n    }\n\n    function _encode_sol_bytes12(bytes12 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 12, p, bs);\n    }\n\n    function _encode_sol_bytes13(bytes13 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 13, p, bs);\n    }\n\n    function _encode_sol_bytes14(bytes14 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 14, p, bs);\n    }\n\n    function _encode_sol_bytes15(bytes15 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 15, p, bs);\n    }\n\n    function _encode_sol_bytes16(bytes16 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 16, p, bs);\n    }\n\n    function _encode_sol_bytes17(bytes17 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 17, p, bs);\n    }\n\n    function _encode_sol_bytes18(bytes18 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 18, p, bs);\n    }\n\n    function _encode_sol_bytes19(bytes19 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 19, p, bs);\n    }\n\n    function _encode_sol_bytes20(bytes20 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 20, p, bs);\n    }\n\n    function _encode_sol_bytes21(bytes21 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 21, p, bs);\n    }\n\n    function _encode_sol_bytes22(bytes22 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 22, p, bs);\n    }\n\n    function _encode_sol_bytes23(bytes23 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 23, p, bs);\n    }\n\n    function _encode_sol_bytes24(bytes24 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 24, p, bs);\n    }\n\n    function _encode_sol_bytes25(bytes25 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 25, p, bs);\n    }\n\n    function _encode_sol_bytes26(bytes26 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 26, p, bs);\n    }\n\n    function _encode_sol_bytes27(bytes27 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 27, p, bs);\n    }\n\n    function _encode_sol_bytes28(bytes28 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 28, p, bs);\n    }\n\n    function _encode_sol_bytes29(bytes29 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 29, p, bs);\n    }\n\n    function _encode_sol_bytes30(bytes30 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 30, p, bs);\n    }\n\n    function _encode_sol_bytes31(bytes31 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(bytes32(x), 31, p, bs);\n    }\n\n    function _encode_sol_bytes32(bytes32 x, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        return _encode_sol_bytes(x, 32, p, bs);\n    }\n\n    /**\n     * @dev Encode the key of Solidity integer and/or fixed-size bytes array.\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_header(uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        p += _encode_varint(sz + 2, p, bs);\n        p += _encode_key(1, WireType.LengthDelim, p, bs);\n        p += _encode_varint(sz, p, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The unsinged integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(uint256 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The signed integer to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol(int256 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_other(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Encode Solidity type\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes used to encode\n     */\n    function _encode_sol_bytes(bytes32 x, uint256 sz, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 size;\n        p += 3;\n        size = _encode_sol_raw_bytes_array(x, p, bs, sz);\n        p += size;\n        _encode_sol_header(size, offset, bs);\n        return p - offset;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(uint256 x, uint256 sz) internal pure returns (uint256) {\n        uint256 base = 0xff;\n        uint256 realSize = sz;\n        while (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == 0 && realSize > 0) {\n            realSize -= 1;\n        }\n        if (realSize == 0) {\n            realSize = 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Get the actual size needed to encoding an signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _get_real_size(int256 x, uint256 sz) internal pure returns (uint256) {\n        int256 base = 0xff;\n        if (x >= 0) {\n            uint256 tmp = _get_real_size(uint256(x), sz);\n            int256 remainder = (x & (base << (tmp * BYTE_SIZE - BYTE_SIZE))) >> (tmp * BYTE_SIZE - BYTE_SIZE);\n            if (remainder >= 128) {\n                tmp += 1;\n            }\n            return tmp;\n        }\n\n        uint256 realSize = sz;\n        while (\n            x & (base << (realSize * BYTE_SIZE - BYTE_SIZE)) == (base << (realSize * BYTE_SIZE - BYTE_SIZE)) &&\n            realSize > 0\n        ) {\n            realSize -= 1;\n        }\n        int256 remainder = (x & (base << (realSize * BYTE_SIZE - BYTE_SIZE))) >> (realSize * BYTE_SIZE - BYTE_SIZE);\n        if (remainder < 128) {\n            realSize += 1;\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the fixed-bytes array\n     * @param x The fixed-size byte array to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_bytes_array(\n        bytes32 x,\n        uint256 p,\n        bytes memory bs,\n        uint256 sz\n    ) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.\n        //\n        uint256 actualSize = sz;\n        for (uint256 i = 0; i < sz; i++) {\n            uint8 current = uint8(x[sz - 1 - i]);\n            if (current == 0 && actualSize > 1) {\n                actualSize--;\n            } else {\n                break;\n            }\n        }\n        assembly {\n            let bsptr := add(bs, p)\n            let count := actualSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(actualSize, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return actualSize;\n    }\n\n    /**\n     * @dev Encode the signed integer\n     * @param x The signed integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(int256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        //\n        // The idea is to not encode the leading bytes of zero.or one,\n        // depending on whether it is positive.\n        //\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n\n    /**\n     * @dev Encode the unsigned integer\n     * @param x The unsigned integer to be encoded\n     * @param sz The maximum number of bytes used to encode Solidity types\n     * @param p The offset of bytes array `bs`\n     * @param bs The bytes array to encode\n     * @return The number of bytes needed for encoding `x`\n     */\n    function _encode_sol_raw_other(uint256 x, uint256 p, bytes memory bs, uint256 sz) internal pure returns (uint256) {\n        uint256 realSize = _get_real_size(x, sz);\n        assembly {\n            let bsptr := add(bs, p)\n            let count := realSize\n            for {\n\n            } gt(count, 0) {\n\n            } {\n                mstore8(bsptr, byte(sub(32, count), x))\n                bsptr := add(bsptr, 1)\n                count := sub(count, 1)\n            }\n        }\n        return realSize;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/proto/TendermintHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, Validator, SimpleValidator, BlockID, Vote, CanonicalBlockID, CanonicalPartSetHeader, CanonicalVote, TmHeader, ConsensusState, MerkleRoot, Commit, CommitSig, SignedHeader, ValidatorSet, Duration, Timestamp, Consensus} from \"./TendermintLight.sol\";\nimport \"./Encoder.sol\";\nimport \"../crypto/MerkleTree.sol\";\n\nlibrary TendermintHelper {\n    function toSimpleValidator(Validator.Data memory val) internal pure returns (SimpleValidator.Data memory) {\n        return SimpleValidator.Data({pub_key: val.pub_key, voting_power: val.voting_power});\n    }\n\n    function toCanonicalBlockID(BlockID.Data memory blockID) internal pure returns (CanonicalBlockID.Data memory) {\n        return\n            CanonicalBlockID.Data({\n                hash: blockID.hash,\n                part_set_header: CanonicalPartSetHeader.Data({\n                    total: blockID.part_set_header.total,\n                    hash: blockID.part_set_header.hash\n                })\n            });\n    }\n\n    function toCanonicalVote(\n        Vote.Data memory vote,\n        string memory chainID\n    ) internal pure returns (CanonicalVote.Data memory) {\n        return\n            CanonicalVote.Data({\n                Type: vote.Type,\n                height: vote.height,\n                round: int64(vote.round),\n                block_id: toCanonicalBlockID(vote.block_id),\n                timestamp: vote.timestamp,\n                chain_id: chainID\n            });\n    }\n\n    function toConsensusState(TmHeader.Data memory tmHeader) internal pure returns (ConsensusState.Data memory) {\n        return\n            ConsensusState.Data({\n                timestamp: tmHeader.signed_header.header.time,\n                root: MerkleRoot.Data({hash: tmHeader.signed_header.header.app_hash}),\n                next_validators_hash: tmHeader.signed_header.header.next_validators_hash\n            });\n    }\n\n    function toVote(Commit.Data memory commit, uint256 valIdx) internal pure returns (Vote.Data memory) {\n        CommitSig.Data memory commitSig = commit.signatures[valIdx];\n\n        return\n            Vote.Data({\n                Type: TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT,\n                height: commit.height,\n                round: commit.round,\n                block_id: commit.block_id,\n                timestamp: commitSig.timestamp,\n                validator_address: commitSig.validator_address,\n                validator_index: SafeCast.toInt32(int256(valIdx)),\n                signature: commitSig.signature\n            });\n    }\n\n    function isEqual(BlockID.Data memory b1, BlockID.Data memory b2) internal pure returns (bool) {\n        if (keccak256(abi.encodePacked(b1.hash)) != keccak256(abi.encodePacked(b2.hash))) {\n            return false;\n        }\n\n        if (b1.part_set_header.total != b2.part_set_header.total) {\n            return false;\n        }\n\n        if (\n            keccak256(abi.encodePacked(b1.part_set_header.hash)) != keccak256(abi.encodePacked(b2.part_set_header.hash))\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function isEqual(ConsensusState.Data memory cs1, ConsensusState.Data memory cs2) internal pure returns (bool) {\n        return\n            keccak256(abi.encodePacked(ConsensusState.encode(cs1))) ==\n            keccak256(abi.encodePacked(ConsensusState.encode(cs2)));\n    }\n\n    function isExpired(\n        SignedHeader.Data memory header,\n        Duration.Data memory trustingPeriod,\n        Duration.Data memory currentTime\n    ) internal pure returns (bool) {\n        Timestamp.Data memory expirationTime = Timestamp.Data({\n            Seconds: header.header.time.Seconds + int64(trustingPeriod.Seconds),\n            nanos: header.header.time.nanos\n        });\n\n        return gt(Timestamp.Data({Seconds: int64(currentTime.Seconds), nanos: 0}), expirationTime);\n    }\n\n    function gt(Timestamp.Data memory t1, Timestamp.Data memory t2) internal pure returns (bool) {\n        if (t1.Seconds > t2.Seconds) {\n            return true;\n        }\n\n        if (t1.Seconds == t2.Seconds && t1.nanos > t2.nanos) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hash(SignedHeader.Data memory h) internal pure returns (bytes32) {\n        require(h.header.validators_hash.length > 0, \"Tendermint: hash can't be empty\");\n\n        bytes memory hbz = Consensus.encode(h.header.version);\n        bytes memory pbt = Timestamp.encode(h.header.time);\n        bytes memory bzbi = BlockID.encode(h.header.last_block_id);\n\n        bytes[14] memory all = [\n            hbz,\n            Encoder.cdcEncode(h.header.chain_id),\n            Encoder.cdcEncode(h.header.height),\n            pbt,\n            bzbi,\n            Encoder.cdcEncode(h.header.last_commit_hash),\n            Encoder.cdcEncode(h.header.data_hash),\n            Encoder.cdcEncode(h.header.validators_hash),\n            Encoder.cdcEncode(h.header.next_validators_hash),\n            Encoder.cdcEncode(h.header.consensus_hash),\n            Encoder.cdcEncode(h.header.app_hash),\n            Encoder.cdcEncode(h.header.last_results_hash),\n            Encoder.cdcEncode(h.header.evidence_hash),\n            Encoder.cdcEncode(h.header.proposer_address)\n        ];\n\n        return MerkleTree.merkleRootHash(all, 0, all.length);\n    }\n\n    function hash(ValidatorSet.Data memory vs) internal pure returns (bytes32) {\n        return MerkleTree.merkleRootHash(vs.validators, 0, vs.validators.length);\n    }\n\n    function getByAddress(\n        ValidatorSet.Data memory vals,\n        bytes memory addr\n    ) internal pure returns (uint256 index, bool found) {\n        bytes32 addrHash = keccak256(abi.encodePacked(addr));\n        for (uint256 idx; idx < vals.validators.length; idx++) {\n            if (keccak256(abi.encodePacked(vals.validators[idx].Address)) == addrHash) {\n                return (idx, true);\n            }\n        }\n\n        return (0, false);\n    }\n\n    function getTotalVotingPower(ValidatorSet.Data memory vals) internal pure returns (int64) {\n        if (vals.total_voting_power == 0) {\n            uint256 sum = 0;\n            uint256 maxInt64 = 1 << (63 - 1);\n            uint256 maxTotalVotingPower = maxInt64 / 8;\n\n            for (uint256 i = 0; i < vals.validators.length; i++) {\n                sum += (SafeCast.toUint256(int256(vals.validators[i].voting_power)));\n                require(sum <= maxTotalVotingPower, \"total voting power should be guarded to not exceed\");\n            }\n\n            vals.total_voting_power = SafeCast.toInt64(int256(sum));\n        }\n\n        return vals.total_voting_power;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/proto/TendermintLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\nimport \"./ProtoBufRuntime.sol\";\nimport \"./GoogleProtobufAny.sol\";\n\nlibrary Fraction {\n    //struct definition\n    struct Data {\n        uint64 numerator;\n        uint64 denominator;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_numerator(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_denominator(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_numerator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.numerator = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_denominator(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.denominator = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.numerator != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.numerator, pointer, bs);\n        }\n        if (r.denominator != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.denominator, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.numerator);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.denominator);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.numerator != 0) {\n            return false;\n        }\n\n        if (r.denominator != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.numerator = input.numerator;\n        output.denominator = input.denominator;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Fraction\n\nlibrary Duration {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Duration\n\nlibrary Consensus {\n    //struct definition\n    struct Data {\n        uint64 block;\n        uint64 app;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_app(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint64 x, uint256 sz) = ProtoBufRuntime._decode_uint64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.app = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.block != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.block, pointer, bs);\n        }\n        if (r.app != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint64(r.app, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint64(r.block);\n        e += 1 + ProtoBufRuntime._sz_uint64(r.app);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.block != 0) {\n            return false;\n        }\n\n        if (r.app != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block = input.block;\n        output.app = input.app;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Consensus\n\nlibrary ClientState {\n    //struct definition\n    struct Data {\n        string chain_id;\n        Fraction.Data trust_level;\n        Duration.Data trusting_period;\n        Duration.Data unbonding_period;\n        Duration.Data max_clock_drift;\n        int64 frozen_height;\n        int64 latest_height;\n        bool allow_update_after_expiry;\n        bool allow_update_after_misbehaviour;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[10] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_trust_level(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusting_period(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_unbonding_period(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_max_clock_drift(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_frozen_height(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_latest_height(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_allow_update_after_expiry(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_allow_update_after_misbehaviour(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trust_level(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Fraction.Data memory x, uint256 sz) = _decode_Fraction(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.trust_level = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusting_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusting_period = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_unbonding_period(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.unbonding_period = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_max_clock_drift(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Duration.Data memory x, uint256 sz) = _decode_Duration(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.max_clock_drift = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_frozen_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.frozen_height = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_latest_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.latest_height = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_expiry(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.allow_update_after_expiry = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_allow_update_after_misbehaviour(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[10] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bool x, uint256 sz) = ProtoBufRuntime._decode_bool(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.allow_update_after_misbehaviour = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Fraction(uint256 p, bytes memory bs) internal pure returns (Fraction.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Fraction.Data memory r, ) = Fraction._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Duration(uint256 p, bytes memory bs) internal pure returns (Duration.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Duration.Data memory r, ) = Duration._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Fraction._encode_nested(r.trust_level, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.trusting_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.unbonding_period, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Duration._encode_nested(r.max_clock_drift, pointer, bs);\n\n        if (r.frozen_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.frozen_height, pointer, bs);\n        }\n        if (r.latest_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.latest_height, pointer, bs);\n        }\n        if (r.allow_update_after_expiry != false) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_expiry, pointer, bs);\n        }\n        if (r.allow_update_after_misbehaviour != false) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bool(r.allow_update_after_misbehaviour, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Fraction._estimate(r.trust_level));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.trusting_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.unbonding_period));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Duration._estimate(r.max_clock_drift));\n        e += 1 + ProtoBufRuntime._sz_int64(r.frozen_height);\n        e += 1 + ProtoBufRuntime._sz_int64(r.latest_height);\n        e += 1 + 1;\n        e += 1 + 1;\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.frozen_height != 0) {\n            return false;\n        }\n\n        if (r.latest_height != 0) {\n            return false;\n        }\n\n        if (r.allow_update_after_expiry != false) {\n            return false;\n        }\n\n        if (r.allow_update_after_misbehaviour != false) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.chain_id = input.chain_id;\n        Fraction.store(input.trust_level, output.trust_level);\n        Duration.store(input.trusting_period, output.trusting_period);\n        Duration.store(input.unbonding_period, output.unbonding_period);\n        Duration.store(input.max_clock_drift, output.max_clock_drift);\n        output.frozen_height = input.frozen_height;\n        output.latest_height = input.latest_height;\n        output.allow_update_after_expiry = input.allow_update_after_expiry;\n        output.allow_update_after_misbehaviour = input.allow_update_after_misbehaviour;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ClientState\n\nlibrary ConsensusState {\n    //struct definition\n    struct Data {\n        Timestamp.Data timestamp;\n        MerkleRoot.Data root;\n        bytes next_validators_hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_root(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_root(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (MerkleRoot.Data memory x, uint256 sz) = _decode_MerkleRoot(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.root = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_MerkleRoot(uint256 p, bytes memory bs) internal pure returns (MerkleRoot.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (MerkleRoot.Data memory r, ) = MerkleRoot._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += MerkleRoot._encode_nested(r.root, pointer, bs);\n\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(MerkleRoot._estimate(r.root));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Timestamp.store(input.timestamp, output.timestamp);\n        MerkleRoot.store(input.root, output.root);\n        output.next_validators_hash = input.next_validators_hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ConsensusState\n\nlibrary MerkleRoot {\n    //struct definition\n    struct Data {\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[2] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[2] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library MerkleRoot\n\n// TODO: Fix field order after potential BSC upgrade\nlibrary CanonicalPartSetHeader {\n    //struct definition\n    struct Data {\n        bytes hash;\n        uint32 total;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalPartSetHeader\n\nlibrary CanonicalBlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        CanonicalPartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalPartSetHeader.Data memory x, uint256 sz) = _decode_CanonicalPartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalPartSetHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CanonicalPartSetHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalPartSetHeader.Data memory r, ) = CanonicalPartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalPartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalPartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        CanonicalPartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalBlockID\n\nlibrary CanonicalVote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int64 round;\n        CanonicalBlockID.Data block_id;\n        Timestamp.Data timestamp;\n        string chain_id;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[7] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_sfixed64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CanonicalBlockID.Data memory x, uint256 sz) = _decode_CanonicalBlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[7] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CanonicalBlockID(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (CanonicalBlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CanonicalBlockID.Data memory r, ) = CanonicalBlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Fixed64, pointer, bs);\n            pointer += ProtoBufRuntime._encode_sfixed64(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += CanonicalBlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + 8;\n        e += 1 + 8;\n        e += 1 + ProtoBufRuntime._sz_lendelim(CanonicalBlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        CanonicalBlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.chain_id = input.chain_id;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CanonicalVote\n\nlibrary Vote {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType Type;\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        Timestamp.Data timestamp;\n        bytes validator_address;\n        int32 validator_index;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[9] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Type(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_validator_index(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Type(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.SignedMsgType x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_SignedMsgType(\n            tmp\n        );\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Type = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.height = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.round = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_index(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.validator_index = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[9] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.signature = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.Type) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_Type = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type);\n            pointer += ProtoBufRuntime._encode_enum(_enum_Type, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n        if (r.validator_index != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.validator_index, pointer, bs);\n        }\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_SignedMsgType(r.Type));\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_int32(r.validator_index);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.Type) != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.validator_index != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Type = input.Type;\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.validator_address = input.validator_address;\n        output.validator_index = input.validator_index;\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Vote\n\nlibrary ValidatorSet {\n    //struct definition\n    struct Data {\n        Validator.Data[] validators;\n        Validator.Data proposer;\n        int64 total_voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.validators = new Validator.Data[](counters[1]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_validators(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_proposer(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_total_voting_power(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.validators[r.validators.length - counters[1]] = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Validator.Data memory x, uint256 sz) = _decode_Validator(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.proposer = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.total_voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Validator(uint256 p, bytes memory bs) internal pure returns (Validator.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Validator.Data memory r, ) = Validator._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.validators.length != 0) {\n            for (i = 0; i < r.validators.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += Validator._encode_nested(r.validators[i], pointer, bs);\n            }\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Validator._encode_nested(r.proposer, pointer, bs);\n\n        if (r.total_voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.total_voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        for (i = 0; i < r.validators.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.validators[i]));\n        }\n        e += 1 + ProtoBufRuntime._sz_lendelim(Validator._estimate(r.proposer));\n        e += 1 + ProtoBufRuntime._sz_int64(r.total_voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.validators.length != 0) {\n            return false;\n        }\n\n        if (r.total_voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        for (uint256 i1 = 0; i1 < input.validators.length; i1++) {\n            output.validators.push(input.validators[i1]);\n        }\n\n        Validator.store(input.proposer, output.proposer);\n        output.total_voting_power = input.total_voting_power;\n    }\n\n    //array helpers for Validators\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addValidators(Data memory self, Validator.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        Validator.Data[] memory tmp = new Validator.Data[](self.validators.length + 1);\n        for (uint256 i = 0; i < self.validators.length; i++) {\n            tmp[i] = self.validators[i];\n        }\n        tmp[self.validators.length] = value;\n        self.validators = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library ValidatorSet\n\nlibrary Validator {\n    //struct definition\n    struct Data {\n        bytes Address;\n        PublicKey.Data pub_key;\n        int64 voting_power;\n        int64 proposer_priority;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Address(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_proposer_priority(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Address = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_priority(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.proposer_priority = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.Address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        if (r.proposer_priority != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.proposer_priority, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.Address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        e += 1 + ProtoBufRuntime._sz_int64(r.proposer_priority);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Address.length != 0) {\n            return false;\n        }\n\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        if (r.proposer_priority != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Address = input.Address;\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n        output.proposer_priority = input.proposer_priority;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Validator\n\nlibrary SimpleValidator {\n    //struct definition\n    struct Data {\n        PublicKey.Data pub_key;\n        int64 voting_power;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_pub_key(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_voting_power(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_pub_key(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PublicKey.Data memory x, uint256 sz) = _decode_PublicKey(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.pub_key = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_voting_power(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.voting_power = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PublicKey(uint256 p, bytes memory bs) internal pure returns (PublicKey.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PublicKey.Data memory r, ) = PublicKey._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PublicKey._encode_nested(r.pub_key, pointer, bs);\n\n        if (r.voting_power != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.voting_power, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(PublicKey._estimate(r.pub_key));\n        e += 1 + ProtoBufRuntime._sz_int64(r.voting_power);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.voting_power != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        PublicKey.store(input.pub_key, output.pub_key);\n        output.voting_power = input.voting_power;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SimpleValidator\n\nlibrary PublicKey {\n    //struct definition\n    struct Data {\n        bytes ed25519;\n        bytes secp256k1;\n        bytes sr25519;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[4] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_ed25519(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_secp256k1(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_sr25519(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_ed25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.ed25519 = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_secp256k1(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.secp256k1 = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_sr25519(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[4] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.sr25519 = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.ed25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.ed25519, pointer, bs);\n        }\n        if (r.secp256k1.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.secp256k1, pointer, bs);\n        }\n        if (r.sr25519.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.sr25519, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.ed25519.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.secp256k1.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.sr25519.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.ed25519.length != 0) {\n            return false;\n        }\n\n        if (r.secp256k1.length != 0) {\n            return false;\n        }\n\n        if (r.sr25519.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.ed25519 = input.ed25519;\n        output.secp256k1 = input.secp256k1;\n        output.sr25519 = input.sr25519;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PublicKey\n\nlibrary PartSetHeader {\n    //struct definition\n    struct Data {\n        uint32 total;\n        bytes hash;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_total(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_total(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (uint32 x, uint256 sz) = ProtoBufRuntime._decode_uint32(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.total = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.hash = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.total != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_uint32(r.total, pointer, bs);\n        }\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_uint32(r.total);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.total != 0) {\n            return false;\n        }\n\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.total = input.total;\n        output.hash = input.hash;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library PartSetHeader\n\nlibrary BlockID {\n    //struct definition\n    struct Data {\n        bytes hash;\n        PartSetHeader.Data part_set_header;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_hash(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_part_set_header(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.hash = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_part_set_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (PartSetHeader.Data memory x, uint256 sz) = _decode_PartSetHeader(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.part_set_header = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_PartSetHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (PartSetHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (PartSetHeader.Data memory r, ) = PartSetHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.hash, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += PartSetHeader._encode_nested(r.part_set_header, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(PartSetHeader._estimate(r.part_set_header));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.hash.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.hash = input.hash;\n        PartSetHeader.store(input.part_set_header, output.part_set_header);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library BlockID\n\nlibrary Commit {\n    //struct definition\n    struct Data {\n        int64 height;\n        int32 round;\n        BlockID.Data block_id;\n        CommitSig.Data[] signatures;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, nil(), counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        pointer = offset;\n        r.signatures = new CommitSig.Data[](counters[4]);\n\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_height(pointer, bs, nil(), counters);\n            } else if (fieldId == 2) {\n                pointer += _read_round(pointer, bs, nil(), counters);\n            } else if (fieldId == 3) {\n                pointer += _read_block_id(pointer, bs, nil(), counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signatures(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.height = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_round(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.round = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.block_id = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signatures(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (CommitSig.Data memory x, uint256 sz) = _decode_CommitSig(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signatures[r.signatures.length - counters[4]] = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_CommitSig(uint256 p, bytes memory bs) internal pure returns (CommitSig.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (CommitSig.Data memory r, ) = CommitSig._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n        uint256 i;\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n        if (r.round != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.round, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.block_id, pointer, bs);\n\n        if (r.signatures.length != 0) {\n            for (i = 0; i < r.signatures.length; i++) {\n                pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n                pointer += CommitSig._encode_nested(r.signatures[i], pointer, bs);\n            }\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        uint256 i;\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_int32(r.round);\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.block_id));\n        for (i = 0; i < r.signatures.length; i++) {\n            e += 1 + ProtoBufRuntime._sz_lendelim(CommitSig._estimate(r.signatures[i]));\n        }\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.round != 0) {\n            return false;\n        }\n\n        if (r.signatures.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.height = input.height;\n        output.round = input.round;\n        BlockID.store(input.block_id, output.block_id);\n\n        for (uint256 i4 = 0; i4 < input.signatures.length; i4++) {\n            output.signatures.push(input.signatures[i4]);\n        }\n    }\n\n    //array helpers for Signatures\n    /**\n     * @dev Add value to an array\n     * @param self The in-memory struct\n     * @param value The value to add\n     */\n    function addSignatures(Data memory self, CommitSig.Data memory value) internal pure {\n        /**\n         * First resize the array. Then add the new element to the end.\n         */\n        CommitSig.Data[] memory tmp = new CommitSig.Data[](self.signatures.length + 1);\n        for (uint256 i = 0; i < self.signatures.length; i++) {\n            tmp[i] = self.signatures[i];\n        }\n        tmp[self.signatures.length] = value;\n        self.signatures = tmp;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Commit\n\nlibrary CommitSig {\n    //struct definition\n    struct Data {\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag block_id_flag;\n        bytes validator_address;\n        Timestamp.Data timestamp;\n        bytes signature;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_block_id_flag(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_address(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_timestamp(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_signature(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_block_id_flag(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 tmp, uint256 sz) = ProtoBufRuntime._decode_enum(p, bs);\n        TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag x = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.decode_BlockIDFlag(tmp);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.block_id_flag = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_address = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_timestamp(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.timestamp = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signature(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.signature = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (uint256(r.block_id_flag) != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            int32 _enum_block_id_flag = TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag);\n            pointer += ProtoBufRuntime._encode_enum(_enum_block_id_flag, pointer, bs);\n        }\n        if (r.validator_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validator_address, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.timestamp, pointer, bs);\n\n        if (r.signature.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.signature, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_enum(TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.encode_BlockIDFlag(r.block_id_flag));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validator_address.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.timestamp));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.signature.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (uint256(r.block_id_flag) != 0) {\n            return false;\n        }\n\n        if (r.validator_address.length != 0) {\n            return false;\n        }\n\n        if (r.signature.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.block_id_flag = input.block_id_flag;\n        output.validator_address = input.validator_address;\n        Timestamp.store(input.timestamp, output.timestamp);\n        output.signature = input.signature;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library CommitSig\n\nlibrary Timestamp {\n    //struct definition\n    struct Data {\n        int64 Seconds;\n        int32 nanos;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_Seconds(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_nanos(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_Seconds(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.Seconds = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_nanos(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int32 x, uint256 sz) = ProtoBufRuntime._decode_int32(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.nanos = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        if (r.Seconds != 0) {\n            pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.Seconds, pointer, bs);\n        }\n        if (r.nanos != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int32(r.nanos, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_int64(r.Seconds);\n        e += 1 + ProtoBufRuntime._sz_int32(r.nanos);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.Seconds != 0) {\n            return false;\n        }\n\n        if (r.nanos != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        output.Seconds = input.Seconds;\n        output.nanos = input.nanos;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library Timestamp\n\nlibrary LightHeader {\n    //struct definition\n    struct Data {\n        Consensus.Data version;\n        string chain_id;\n        int64 height;\n        Timestamp.Data time;\n        BlockID.Data last_block_id;\n        bytes last_commit_hash;\n        bytes data_hash;\n        bytes validators_hash;\n        bytes next_validators_hash;\n        bytes consensus_hash;\n        bytes app_hash;\n        bytes last_results_hash;\n        bytes evidence_hash;\n        bytes proposer_address;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[15] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_version(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_chain_id(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_time(pointer, bs, r, counters);\n            } else if (fieldId == 5) {\n                pointer += _read_last_block_id(pointer, bs, r, counters);\n            } else if (fieldId == 6) {\n                pointer += _read_last_commit_hash(pointer, bs, r, counters);\n            } else if (fieldId == 7) {\n                pointer += _read_data_hash(pointer, bs, r, counters);\n            } else if (fieldId == 8) {\n                pointer += _read_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 9) {\n                pointer += _read_next_validators_hash(pointer, bs, r, counters);\n            } else if (fieldId == 10) {\n                pointer += _read_consensus_hash(pointer, bs, r, counters);\n            } else if (fieldId == 11) {\n                pointer += _read_app_hash(pointer, bs, r, counters);\n            } else if (fieldId == 12) {\n                pointer += _read_last_results_hash(pointer, bs, r, counters);\n            } else if (fieldId == 13) {\n                pointer += _read_evidence_hash(pointer, bs, r, counters);\n            } else if (fieldId == 14) {\n                pointer += _read_proposer_address(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_version(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Consensus.Data memory x, uint256 sz) = _decode_Consensus(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.version = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_chain_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (string memory x, uint256 sz) = ProtoBufRuntime._decode_string(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.chain_id = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_time(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Timestamp.Data memory x, uint256 sz) = _decode_Timestamp(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.time = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_block_id(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (BlockID.Data memory x, uint256 sz) = _decode_BlockID(p, bs);\n        if (isNil(r)) {\n            counters[5] += 1;\n        } else {\n            r.last_block_id = x;\n            if (counters[5] > 0) counters[5] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_commit_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[6] += 1;\n        } else {\n            r.last_commit_hash = x;\n            if (counters[6] > 0) counters[6] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_data_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[7] += 1;\n        } else {\n            r.data_hash = x;\n            if (counters[7] > 0) counters[7] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[8] += 1;\n        } else {\n            r.validators_hash = x;\n            if (counters[8] > 0) counters[8] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_next_validators_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[9] += 1;\n        } else {\n            r.next_validators_hash = x;\n            if (counters[9] > 0) counters[9] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_consensus_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[10] += 1;\n        } else {\n            r.consensus_hash = x;\n            if (counters[10] > 0) counters[10] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_app_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[11] += 1;\n        } else {\n            r.app_hash = x;\n            if (counters[11] > 0) counters[11] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_last_results_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[12] += 1;\n        } else {\n            r.last_results_hash = x;\n            if (counters[12] > 0) counters[12] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_evidence_hash(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[13] += 1;\n        } else {\n            r.evidence_hash = x;\n            if (counters[13] > 0) counters[13] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_proposer_address(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[15] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (bytes memory x, uint256 sz) = ProtoBufRuntime._decode_bytes(p, bs);\n        if (isNil(r)) {\n            counters[14] += 1;\n        } else {\n            r.proposer_address = x;\n            if (counters[14] > 0) counters[14] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Consensus(uint256 p, bytes memory bs) internal pure returns (Consensus.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Consensus.Data memory r, ) = Consensus._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Timestamp(uint256 p, bytes memory bs) internal pure returns (Timestamp.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Timestamp.Data memory r, ) = Timestamp._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_BlockID(uint256 p, bytes memory bs) internal pure returns (BlockID.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (BlockID.Data memory r, ) = BlockID._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Consensus._encode_nested(r.version, pointer, bs);\n\n        if (bytes(r.chain_id).length != 0) {\n            pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_string(r.chain_id, pointer, bs);\n        }\n        if (r.height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Timestamp._encode_nested(r.time, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(5, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += BlockID._encode_nested(r.last_block_id, pointer, bs);\n\n        if (r.last_commit_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(6, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_commit_hash, pointer, bs);\n        }\n        if (r.data_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(7, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.data_hash, pointer, bs);\n        }\n        if (r.validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(8, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.validators_hash, pointer, bs);\n        }\n        if (r.next_validators_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(9, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.next_validators_hash, pointer, bs);\n        }\n        if (r.consensus_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(10, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.consensus_hash, pointer, bs);\n        }\n        if (r.app_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(11, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.app_hash, pointer, bs);\n        }\n        if (r.last_results_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(12, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.last_results_hash, pointer, bs);\n        }\n        if (r.evidence_hash.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(13, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.evidence_hash, pointer, bs);\n        }\n        if (r.proposer_address.length != 0) {\n            pointer += ProtoBufRuntime._encode_key(14, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n            pointer += ProtoBufRuntime._encode_bytes(r.proposer_address, pointer, bs);\n        }\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(Consensus._estimate(r.version));\n        e += 1 + ProtoBufRuntime._sz_lendelim(bytes(r.chain_id).length);\n        e += 1 + ProtoBufRuntime._sz_int64(r.height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(Timestamp._estimate(r.time));\n        e += 1 + ProtoBufRuntime._sz_lendelim(BlockID._estimate(r.last_block_id));\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_commit_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.data_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.next_validators_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.consensus_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.app_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.last_results_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.evidence_hash.length);\n        e += 1 + ProtoBufRuntime._sz_lendelim(r.proposer_address.length);\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (bytes(r.chain_id).length != 0) {\n            return false;\n        }\n\n        if (r.height != 0) {\n            return false;\n        }\n\n        if (r.last_commit_hash.length != 0) {\n            return false;\n        }\n\n        if (r.data_hash.length != 0) {\n            return false;\n        }\n\n        if (r.validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.next_validators_hash.length != 0) {\n            return false;\n        }\n\n        if (r.consensus_hash.length != 0) {\n            return false;\n        }\n\n        if (r.app_hash.length != 0) {\n            return false;\n        }\n\n        if (r.last_results_hash.length != 0) {\n            return false;\n        }\n\n        if (r.evidence_hash.length != 0) {\n            return false;\n        }\n\n        if (r.proposer_address.length != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        Consensus.store(input.version, output.version);\n        output.chain_id = input.chain_id;\n        output.height = input.height;\n        Timestamp.store(input.time, output.time);\n        BlockID.store(input.last_block_id, output.last_block_id);\n        output.last_commit_hash = input.last_commit_hash;\n        output.data_hash = input.data_hash;\n        output.validators_hash = input.validators_hash;\n        output.next_validators_hash = input.next_validators_hash;\n        output.consensus_hash = input.consensus_hash;\n        output.app_hash = input.app_hash;\n        output.last_results_hash = input.last_results_hash;\n        output.evidence_hash = input.evidence_hash;\n        output.proposer_address = input.proposer_address;\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library LightHeader\n\nlibrary SignedHeader {\n    //struct definition\n    struct Data {\n        LightHeader.Data header;\n        Commit.Data commit;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[3] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_commit(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (LightHeader.Data memory x, uint256 sz) = _decode_LightHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_commit(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[3] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (Commit.Data memory x, uint256 sz) = _decode_Commit(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.commit = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_LightHeader(uint256 p, bytes memory bs) internal pure returns (LightHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (LightHeader.Data memory r, ) = LightHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_Commit(uint256 p, bytes memory bs) internal pure returns (Commit.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (Commit.Data memory r, ) = Commit._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += LightHeader._encode_nested(r.header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += Commit._encode_nested(r.commit, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(LightHeader._estimate(r.header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(Commit._estimate(r.commit));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        LightHeader.store(input.header, output.header);\n        Commit.store(input.commit, output.commit);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library SignedHeader\n\nlibrary TmHeader {\n    //struct definition\n    struct Data {\n        SignedHeader.Data signed_header;\n        ValidatorSet.Data validator_set;\n        int64 trusted_height;\n        ValidatorSet.Data trusted_validators;\n    }\n\n    // Decoder section\n\n    /**\n     * @dev The main decoder for memory\n     * @param bs The bytes array to be decoded\n     * @return The decoded struct\n     */\n    function decode(bytes memory bs) internal pure returns (Data memory) {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        return x;\n    }\n\n    /**\n     * @dev The main decoder for storage\n     * @param self The in-storage struct\n     * @param bs The bytes array to be decoded\n     */\n    function decode(Data storage self, bytes memory bs) internal {\n        (Data memory x, ) = _decode(32, bs, bs.length);\n        store(x, self);\n    }\n\n    // inner decoder\n\n    /**\n     * @dev The decoder for internal usage\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param sz The number of bytes expected\n     * @return The decoded struct\n     * @return The number of bytes decoded\n     */\n    function _decode(uint256 p, bytes memory bs, uint256 sz) internal pure returns (Data memory, uint256) {\n        Data memory r;\n        uint256[5] memory counters;\n        uint256 fieldId;\n        ProtoBufRuntime.WireType wireType;\n        uint256 bytesRead;\n        uint256 offset = p;\n        uint256 pointer = p;\n        while (pointer < offset + sz) {\n            (fieldId, wireType, bytesRead) = ProtoBufRuntime._decode_key(pointer, bs);\n            pointer += bytesRead;\n            if (fieldId == 1) {\n                pointer += _read_signed_header(pointer, bs, r, counters);\n            } else if (fieldId == 2) {\n                pointer += _read_validator_set(pointer, bs, r, counters);\n            } else if (fieldId == 3) {\n                pointer += _read_trusted_height(pointer, bs, r, counters);\n            } else if (fieldId == 4) {\n                pointer += _read_trusted_validators(pointer, bs, r, counters);\n            } else {\n                if (wireType == ProtoBufRuntime.WireType.Fixed64) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed64(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Fixed32) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_fixed32(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.Varint) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_varint(pointer, bs);\n                    pointer += size;\n                }\n                if (wireType == ProtoBufRuntime.WireType.LengthDelim) {\n                    uint256 size;\n                    (, size) = ProtoBufRuntime._decode_lendelim(pointer, bs);\n                    pointer += size;\n                }\n            }\n        }\n        return (r, sz);\n    }\n\n    // field readers\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_signed_header(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (SignedHeader.Data memory x, uint256 sz) = _decode_SignedHeader(p, bs);\n        if (isNil(r)) {\n            counters[1] += 1;\n        } else {\n            r.signed_header = x;\n            if (counters[1] > 0) counters[1] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_validator_set(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[2] += 1;\n        } else {\n            r.validator_set = x;\n            if (counters[2] > 0) counters[2] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_height(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (int64 x, uint256 sz) = ProtoBufRuntime._decode_int64(p, bs);\n        if (isNil(r)) {\n            counters[3] += 1;\n        } else {\n            r.trusted_height = x;\n            if (counters[3] > 0) counters[3] -= 1;\n        }\n        return sz;\n    }\n\n    /**\n     * @dev The decoder for reading a field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @param r The in-memory struct\n     * @param counters The counters for repeated fields\n     * @return The number of bytes decoded\n     */\n    function _read_trusted_validators(\n        uint256 p,\n        bytes memory bs,\n        Data memory r,\n        uint256[5] memory counters\n    ) internal pure returns (uint256) {\n        /**\n         * if `r` is NULL, then only counting the number of fields.\n         */\n        (ValidatorSet.Data memory x, uint256 sz) = _decode_ValidatorSet(p, bs);\n        if (isNil(r)) {\n            counters[4] += 1;\n        } else {\n            r.trusted_validators = x;\n            if (counters[4] > 0) counters[4] -= 1;\n        }\n        return sz;\n    }\n\n    // struct decoder\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_SignedHeader(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (SignedHeader.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (SignedHeader.Data memory r, ) = SignedHeader._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    /**\n     * @dev The decoder for reading a inner struct field\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The decoded inner-struct\n     * @return The number of bytes used to decode\n     */\n    function _decode_ValidatorSet(\n        uint256 p,\n        bytes memory bs\n    ) internal pure returns (ValidatorSet.Data memory, uint256) {\n        uint256 pointer = p;\n        (uint256 sz, uint256 bytesRead) = ProtoBufRuntime._decode_varint(pointer, bs);\n        pointer += bytesRead;\n        (ValidatorSet.Data memory r, ) = ValidatorSet._decode(pointer, bs, sz);\n        return (r, sz + bytesRead);\n    }\n\n    // Encoder section\n\n    /**\n     * @dev The main encoder for memory\n     * @param r The struct to be encoded\n     * @return The encoded byte array\n     */\n    function encode(Data memory r) internal pure returns (bytes memory) {\n        bytes memory bs = new bytes(_estimate(r));\n        uint256 sz = _encode(r, 32, bs);\n        assembly {\n            mstore(bs, sz)\n        }\n        return bs;\n    }\n\n    // inner encoder\n\n    /**\n     * @dev The encoder for internal usage\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        uint256 offset = p;\n        uint256 pointer = p;\n\n        pointer += ProtoBufRuntime._encode_key(1, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += SignedHeader._encode_nested(r.signed_header, pointer, bs);\n\n        pointer += ProtoBufRuntime._encode_key(2, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.validator_set, pointer, bs);\n\n        if (r.trusted_height != 0) {\n            pointer += ProtoBufRuntime._encode_key(3, ProtoBufRuntime.WireType.Varint, pointer, bs);\n            pointer += ProtoBufRuntime._encode_int64(r.trusted_height, pointer, bs);\n        }\n\n        pointer += ProtoBufRuntime._encode_key(4, ProtoBufRuntime.WireType.LengthDelim, pointer, bs);\n        pointer += ValidatorSet._encode_nested(r.trusted_validators, pointer, bs);\n\n        return pointer - offset;\n    }\n\n    // nested encoder\n\n    /**\n     * @dev The encoder for inner struct\n     * @param r The struct to be encoded\n     * @param p The offset of bytes array to start decode\n     * @param bs The bytes array to be decoded\n     * @return The number of bytes encoded\n     */\n    function _encode_nested(Data memory r, uint256 p, bytes memory bs) internal pure returns (uint256) {\n        //\n        // First encoded `r` into a temporary array, and encode the actual size used.\n        // Then copy the temporary array into `bs`.\n        //\n        uint256 offset = p;\n        uint256 pointer = p;\n        bytes memory tmp = new bytes(_estimate(r));\n        uint256 tmpAddr = ProtoBufRuntime.getMemoryAddress(tmp);\n        uint256 bsAddr = ProtoBufRuntime.getMemoryAddress(bs);\n        uint256 size = _encode(r, 32, tmp);\n        pointer += ProtoBufRuntime._encode_varint(size, pointer, bs);\n        ProtoBufRuntime.copyBytes(tmpAddr + 32, bsAddr + pointer, size);\n        pointer += size;\n        delete tmp;\n        return pointer - offset;\n    }\n\n    // estimator\n\n    /**\n     * @dev The estimator for a struct\n     * @param r The struct to be encoded\n     * @return The number of bytes encoded in estimation\n     */\n    function _estimate(Data memory r) internal pure returns (uint256) {\n        uint256 e;\n        e += 1 + ProtoBufRuntime._sz_lendelim(SignedHeader._estimate(r.signed_header));\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.validator_set));\n        e += 1 + ProtoBufRuntime._sz_int64(r.trusted_height);\n        e += 1 + ProtoBufRuntime._sz_lendelim(ValidatorSet._estimate(r.trusted_validators));\n        return e;\n    }\n\n    // empty checker\n\n    function _empty(Data memory r) internal pure returns (bool) {\n        if (r.trusted_height != 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    //store function\n    /**\n     * @dev Store in-memory struct to storage\n     * @param input The in-memory struct\n     * @param output The in-storage struct\n     */\n    function store(Data memory input, Data storage output) internal {\n        SignedHeader.store(input.signed_header, output.signed_header);\n        ValidatorSet.store(input.validator_set, output.validator_set);\n        output.trusted_height = input.trusted_height;\n        ValidatorSet.store(input.trusted_validators, output.trusted_validators);\n    }\n\n    //utility functions\n    /**\n     * @dev Return an empty struct\n     * @return r The empty struct\n     */\n    function nil() internal pure returns (Data memory r) {\n        assembly {\n            r := 0\n        }\n    }\n\n    /**\n     * @dev Test whether a struct is empty\n     * @param x The struct to be tested\n     * @return r True if it is empty\n     */\n    function isNil(Data memory x) internal pure returns (bool r) {\n        assembly {\n            r := iszero(x)\n        }\n    }\n}\n\n//library TmHeader\n\nlibrary TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS {\n    //enum definition\n    // Solidity enum definitions\n    enum BlockIDFlag {\n        BLOCK_ID_FLAG_UNKNOWN,\n        BLOCK_ID_FLAG_ABSENT,\n        BLOCK_ID_FLAG_COMMIT,\n        BLOCK_ID_FLAG_NIL\n    }\n\n    // Solidity enum encoder\n    function encode_BlockIDFlag(BlockIDFlag x) internal pure returns (int32) {\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_ABSENT) {\n            return 1;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_COMMIT) {\n            return 2;\n        }\n\n        if (x == BlockIDFlag.BLOCK_ID_FLAG_NIL) {\n            return 3;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_BlockIDFlag(int64 x) internal pure returns (BlockIDFlag) {\n        if (x == 0) {\n            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n        }\n\n        if (x == 2) {\n            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n        }\n\n        if (x == 3) {\n            return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n        }\n        revert();\n    }\n\n    // Solidity enum definitions\n    enum SignedMsgType {\n        SIGNED_MSG_TYPE_UNKNOWN,\n        SIGNED_MSG_TYPE_PREVOTE,\n        SIGNED_MSG_TYPE_PRECOMMIT,\n        SIGNED_MSG_TYPE_PROPOSAL\n    }\n\n    // Solidity enum encoder\n    function encode_SignedMsgType(SignedMsgType x) internal pure returns (int32) {\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN) {\n            return 0;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PREVOTE) {\n            return 1;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT) {\n            return 2;\n        }\n\n        if (x == SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL) {\n            return 32;\n        }\n        revert();\n    }\n\n    // Solidity enum decoder\n    function decode_SignedMsgType(int64 x) internal pure returns (SignedMsgType) {\n        if (x == 0) {\n            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n        }\n\n        if (x == 1) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n        }\n\n        if (x == 2) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n        }\n\n        if (x == 32) {\n            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n        }\n        revert();\n    }\n}\n//library TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS\n"
    },
    "contracts/bsc-tendermint/lib/RLPDecode.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nlibrary RLPDecode {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(self, 0x20)\n        }\n\n        return RLPItem(self.length, memPtr);\n    }\n\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        require(item.len >= offset, \"length is less than offset\");\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            uint256 dataLen;\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n            require(itemLen >= dataLen, \"addition overflow\");\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/RLPEncode.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nlibrary RLPEncode {\n    uint8 constant STRING_OFFSET = 0x80;\n    uint8 constant LIST_OFFSET = 0xc0;\n\n    /**\n     * @notice Encode string item\n     * @param self The string (ie. byte array) item to encode\n     * @return The RLP encoded string in bytes\n     */\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\n        if (self.length == 1 && self[0] <= 0x7f) {\n            return self;\n        }\n        return mergeBytes(encodeLength(self.length, STRING_OFFSET), self);\n    }\n\n    /**\n     * @notice Encode address\n     * @param self The address to encode\n     * @return The RLP encoded address in bytes\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory b;\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, self))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n        return encodeBytes(b);\n    }\n\n    /**\n     * @notice Encode uint\n     * @param self The uint to encode\n     * @return The RLP encoded uint in bytes\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        return encodeBytes(toBinary(self));\n    }\n\n    /**\n     * @notice Encode int\n     * @param self The int to encode\n     * @return The RLP encoded int in bytes\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeUint(uint256(self));\n    }\n\n    /**\n     * @notice Encode bool\n     * @param self The bool to encode\n     * @return The RLP encoded bool in bytes\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory rs = new bytes(1);\n        if (self) {\n            rs[0] = bytes1(uint8(1));\n        }\n        return rs;\n    }\n\n    /**\n     * @notice Encode list of items\n     * @param self The list of items to encode, each item in list must be already encoded\n     * @return The RLP encoded list of items in bytes\n     */\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\n        if (self.length == 0) {\n            return new bytes(0);\n        }\n        bytes memory payload = self[0];\n        for (uint256 i = 1; i < self.length; i++) {\n            payload = mergeBytes(payload, self[i]);\n        }\n        return mergeBytes(encodeLength(payload.length, LIST_OFFSET), payload);\n    }\n\n    /**\n     * @notice Concat two bytes arrays\n     * @param _preBytes The first bytes array\n     * @param _postBytes The second bytes array\n     * @return The merged bytes array\n     */\n    function mergeBytes(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Encode the first byte, followed by the `length` in binary form if `length` is more than 55.\n     * @param length The length of the string or the payload\n     * @param offset `STRING_OFFSET` if item is string, `LIST_OFFSET` if item is list\n     * @return RLP encoded bytes\n     */\n    function encodeLength(uint256 length, uint256 offset) internal pure returns (bytes memory) {\n        require(length < 256 ** 8, \"input too long\");\n        bytes memory rs = new bytes(1);\n        if (length <= 55) {\n            rs[0] = bytes1(uint8(length + offset));\n            return rs;\n        }\n        bytes memory bl = toBinary(length);\n        rs[0] = bytes1(uint8(bl.length + offset + 55));\n        return mergeBytes(rs, bl);\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes\n     * @param x The integer to encode\n     * @return RLP encoded bytes\n     */\n    function toBinary(uint256 x) internal pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n        uint256 i;\n        if (x & 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000 == 0) {\n            i = 24;\n        } else if (x & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000 == 0) {\n            i = 16;\n        } else {\n            i = 0;\n        }\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n        uint256 length = 32 - i;\n        bytes memory rs = new bytes(length);\n        assembly {\n            mstore(add(rs, length), x)\n            mstore(rs, length)\n        }\n        return rs;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/lib/Tendermint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./Bytes.sol\";\nimport {TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS, SignedHeader, BlockID, Timestamp, ValidatorSet, Duration, Fraction, Commit, Validator, CommitSig, CanonicalVote, Vote} from \"./proto/TendermintLight.sol\";\nimport \"./proto/TendermintHelper.sol\";\nimport \"./proto/Encoder.sol\";\nimport \"../Ed25519Verifier.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nlibrary Tendermint {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for ValidatorSet.Data;\n    using TendermintHelper for SignedHeader.Data;\n    using TendermintHelper for Timestamp.Data;\n    using TendermintHelper for BlockID.Data;\n    using TendermintHelper for Commit.Data;\n    using TendermintHelper for Vote.Data;\n\n    // TODO: Change visibility to public for deployment. For some reason have to use internal for abigen.\n    function verify(\n        SignedHeader.Data memory trustedHeader,\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals,\n        address verifier,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) internal view returns (bool) {\n        verifyNewHeaderAndVals(untrustedHeader, untrustedVals, trustedHeader);\n\n        // Check the validator hashes are the same\n        require(\n            untrustedHeader.header.validators_hash.toBytes32() == trustedHeader.header.next_validators_hash.toBytes32(),\n            \"expected old header next validators to match those from new header\"\n        );\n\n        // Ensure that +2/3 of new validators signed correctly.\n        bool ok = verifyCommitLight(\n            untrustedVals,\n            trustedHeader.header.chain_id,\n            untrustedHeader.commit.block_id,\n            untrustedHeader.header.height,\n            untrustedHeader.commit,\n            verifier,\n            proofA,\n            proofB,\n            proofC,\n            proofCommit,\n            proofCommitPub\n        );\n\n        return ok;\n    }\n\n    function verifyNewHeaderAndVals(\n        SignedHeader.Data memory untrustedHeader,\n        ValidatorSet.Data memory untrustedVals,\n        SignedHeader.Data memory trustedHeader\n    ) internal pure {\n        // SignedHeader validate basic\n        require(\n            keccak256(abi.encodePacked(untrustedHeader.header.chain_id)) ==\n                keccak256(abi.encodePacked(trustedHeader.header.chain_id)),\n            \"header belongs to another chain\"\n        );\n        require(untrustedHeader.commit.height == untrustedHeader.header.height, \"header and commit height mismatch\");\n\n        bytes32 untrustedHeaderBlockHash = untrustedHeader.hash();\n        // TODO: Fix block hash\n        // require(\n        //     untrustedHeaderBlockHash == untrustedHeader.commit.block_id.hash.toBytes32(),\n        //     \"commit signs signs block failed\"\n        // );\n\n        require(\n            untrustedHeader.header.height > trustedHeader.header.height,\n            \"expected new header height to be greater than one of old header\"\n        );\n\n        // Skip time verification for now\n\n        bytes32 validatorsHash = untrustedVals.hash();\n        // TODO: Fix validators hash\n        // require(\n        //     untrustedHeader.header.validators_hash.toBytes32() == validatorsHash,\n        //     \"expected new header validators to match those that were supplied at height XX\"\n        // );\n    }\n\n    // VerifyCommitLight\n    // Proof of concept header verification with batch signature SNARK proof\n    function verifyCommitLight(\n        ValidatorSet.Data memory vals,\n        string memory chainID,\n        BlockID.Data memory blockID,\n        int64 height,\n        Commit.Data memory commit,\n        address verifier,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) internal view returns (bool) {\n        require(vals.validators.length == commit.signatures.length, \"invalid commit signatures\");\n        require(commit.signatures.length > 8, \"insufficient signatures\");\n\n        require(height == commit.height, \"invalid commit height\");\n\n        require(commit.block_id.isEqual(blockID), \"invalid commit -- wrong block ID\");\n\n        bytes[8] memory pubkeys;\n        bytes[8] memory messages;\n        uint256 sigCount;\n        for (uint256 i = 0; i < commit.signatures.length; i++) {\n            // no need to verify absent or nil votes.\n            if (\n                commit.signatures[i].block_id_flag !=\n                TENDERMINTLIGHT_PROTO_GLOBAL_ENUMS.BlockIDFlag.BLOCK_ID_FLAG_COMMIT\n            ) {\n                continue;\n            }\n\n            pubkeys[sigCount] = vals.validators[i].pub_key.ed25519;\n            messages[sigCount] = Encoder.encodeDelim(voteSignBytes(commit, chainID, i));\n\n            sigCount++;\n            if (sigCount == 8) {\n                break;\n            }\n        }\n\n        uint256[57] memory input = prepareInput(pubkeys, messages, proofCommitPub);\n        return Ed25519Verifier(verifier).verifyProof(proofA, proofB, proofC, proofCommit, input);\n    }\n\n    function prepareInput(\n        bytes[8] memory pubkeys,\n        bytes[8] memory messages,\n        uint256 proofCommitPub\n    ) private pure returns (uint256[57] memory input) {\n        for (uint256 i = 0; i < 8; i++) {\n            bytes memory messagePart0 = BytesLib.slice(messages[i], 0, 25);\n            bytes memory messagePart1 = BytesLib.slice(messages[i], 25, 25);\n            bytes memory messagePart2 = BytesLib.slice(messages[i], 50, 25);\n            bytes memory messagePart3 = BytesLib.slice(messages[i], 75, 25);\n            bytes memory messagePart4 = BytesLib.slice(messages[i], 100, 22);\n            input[5 * i] = uint256(uint200(bytes25(messagePart0)));\n            input[5 * i + 1] = uint256(uint200(bytes25(messagePart1)));\n            input[5 * i + 2] = uint256(uint200(bytes25(messagePart2)));\n            input[5 * i + 3] = uint256(uint200(bytes25(messagePart3)));\n            input[5 * i + 4] = uint256(uint176(bytes22(messagePart4)));\n            bytes memory pubkeyHigh = BytesLib.slice(pubkeys[i], 0, 16);\n            bytes memory pubkeyLow = BytesLib.slice(pubkeys[i], 16, 16);\n            input[2 * i + 40] = uint256(uint128(bytes16(pubkeyHigh)));\n            input[2 * i + 1 + 40] = uint256(uint128(bytes16(pubkeyLow)));\n        }\n        input[56] = proofCommitPub;\n        return input;\n    }\n\n    function voteSignBytes(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        Vote.Data memory vote;\n        vote = commit.toVote(idx);\n\n        return CanonicalVote.encode(vote.toCanonicalVote(chainID));\n    }\n\n    function voteSignBytesDelim(\n        Commit.Data memory commit,\n        string memory chainID,\n        uint256 idx\n    ) internal pure returns (bytes memory) {\n        return Encoder.encodeDelim(voteSignBytes(commit, chainID, idx));\n    }\n}\n"
    },
    "contracts/bsc-tendermint/System.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Initializable.sol\";\n\ncontract System is Ownable, Initializable {\n    uint32 public constant CODE_OK = 0;\n    uint32 public constant ERROR_FAIL_DECODE = 100;\n\n    uint8 public constant STAKING_CHANNEL_ID = 0x08;\n\n    address public bscValidatorSet;\n    address public tmLightClient;\n    address public crossChain;\n\n    uint16 public bscChainID;\n    address public relayer;\n\n    function init(\n        uint16 _bscChainID,\n        address _relayer,\n        address _bscValidatorSet,\n        address _tmLightClient,\n        address _crossChain\n    ) external onlyUninitialized onlyOwner {\n        bscChainID = _bscChainID;\n        relayer = _relayer;\n        bscValidatorSet = _bscValidatorSet;\n        tmLightClient = _tmLightClient;\n        crossChain = _crossChain;\n\n        _initialized = true;\n    }\n\n    function setRelayer(address _relayer) external onlyOwner {\n        relayer = _relayer;\n    }\n}\n"
    },
    "contracts/bsc-tendermint/TendermintLightClient.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./Initializable.sol\";\nimport \"./System.sol\";\nimport \"./lib/Tendermint.sol\";\nimport \"./interfaces/ITendermintLightClient.sol\";\nimport {GoogleProtobufAny as Any} from \"./lib/proto/GoogleProtobufAny.sol\";\nimport {LightHeader, ValidatorSet, ConsensusState, TmHeader} from \"./lib/proto/TendermintLight.sol\";\n\ncontract TendermintLightClient is Initializable, ITendermintLightClient {\n    using Bytes for bytes;\n    using Bytes for bytes32;\n    using TendermintHelper for TmHeader.Data;\n    using TendermintHelper for ConsensusState.Data;\n    using TendermintHelper for ValidatorSet.Data;\n\n    struct ProtoTypes {\n        bytes32 consensusState;\n        bytes32 tmHeader;\n    }\n\n    ProtoTypes private _pts;\n    mapping(uint64 => ConsensusState.Data) public consensusStates;\n    mapping(uint64 => bool) public synced;\n    uint64 public initialHeight;\n    uint64 public latestHeight;\n    System private system;\n    address ed25519Verifier;\n\n    event ConsensusStateInit(uint64 initialHeight, bytes32 appHash);\n    event ConsensusStateSynced(uint64 height, bytes32 appHash);\n\n    constructor(address _ed25519Verifier) {\n        ed25519Verifier = _ed25519Verifier;\n    }\n\n    function init(address _system, bytes memory _initHeader) external onlyUninitialized {\n        _pts = ProtoTypes({\n            consensusState: keccak256(abi.encodePacked(\"/tendermint.types.ConsensusState\")),\n            tmHeader: keccak256(abi.encodePacked(\"/tendermint.types.TmHeader\"))\n        });\n\n        system = System(_system);\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(_initHeader);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        initialHeight = height;\n        latestHeight = height;\n\n        emit ConsensusStateInit(initialHeight, bytes32(cs.root.hash));\n\n        _initialized = true;\n    }\n\n    function syncTendermintHeader(\n        bytes calldata header,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) external returns (bool) {\n        require(msg.sender == system.relayer(), \"not relayer\");\n\n        (TmHeader.Data memory tmHeader, bool ok) = unmarshalTmHeader(header);\n        require(ok, \"LC: light block is invalid\");\n\n        uint64 height = uint64(tmHeader.signed_header.header.height);\n        require(!synced[height], \"can't sync duplicated header\");\n        // assert header height is newer than consensus state\n        require(height > latestHeight, \"LC: header height not newer than consensus state height\");\n\n        checkValidity(consensusStates[latestHeight], tmHeader, proofA, proofB, proofC, proofCommit, proofCommitPub);\n\n        synced[height] = true;\n\n        // Store new cs\n        ConsensusState.Data memory cs = tmHeader.toConsensusState();\n        consensusStates[height] = cs;\n\n        emit ConsensusStateSynced(height, bytes32(cs.root.hash));\n\n        return true;\n    }\n\n    // checkValidity checks if the Tendermint header is valid.\n    function checkValidity(\n        ConsensusState.Data memory trustedConsensusState,\n        TmHeader.Data memory tmHeader,\n        uint256[2] memory proofA,\n        uint256[2][2] memory proofB,\n        uint256[2] memory proofC,\n        uint256[2] memory proofCommit,\n        uint256 proofCommitPub\n    ) private view {\n        LightHeader.Data memory lc;\n        lc.chain_id = tmHeader.signed_header.header.chain_id;\n        lc.height = int64(latestHeight);\n        lc.next_validators_hash = trustedConsensusState.next_validators_hash;\n\n        SignedHeader.Data memory trustedHeader;\n        trustedHeader.header = lc;\n\n        SignedHeader.Data memory untrustedHeader = tmHeader.signed_header;\n        ValidatorSet.Data memory untrustedVals = tmHeader.validator_set;\n\n        bool ok = Tendermint.verify(\n            trustedHeader,\n            untrustedHeader,\n            untrustedVals,\n            ed25519Verifier,\n            proofA,\n            proofB,\n            proofC,\n            proofCommit,\n            proofCommitPub\n        );\n\n        require(ok, \"LC: failed to verify header\");\n    }\n\n    function isHeaderSynced(uint64 height) external view override returns (bool) {\n        return synced[height] || height == initialHeight;\n    }\n\n    function getAppHash(uint64 height) external view override returns (bytes32) {\n        return bytes32(consensusStates[height].root.hash);\n    }\n\n    function unmarshalTmHeader(bytes memory bz) internal view returns (TmHeader.Data memory header, bool ok) {\n        Any.Data memory anyHeader = Any.decode(bz);\n        if (keccak256(abi.encodePacked(anyHeader.type_url)) != _pts.tmHeader) {\n            return (header, false);\n        }\n        return (TmHeader.decode(anyHeader.value), true);\n    }\n}\n"
    },
    "contracts/chunk-sync/BlockChunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IBlockChunks.sol\";\nimport \"../verifiers/interfaces/IZkpVerifier.sol\";\nimport \"../light-client/interfaces/IAnchorBlocks.sol\";\n\nuint8 constant TREE_DEPTH = 7;\nuint32 constant NUM_LEAVES = 2 ** 7;\n\n// array indices for reading from the ZKP calldata\nuint32 constant PUBLIC_BYTES_START_IDX = 10 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment)\n\ncontract BlockChunks is IBlockChunks, Ownable {\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n    mapping(uint64 => address) public anchorBlockProviders; // chainid => anchorBlockProvider\n\n    // historicalRoots[chainId][startBlockNumber] is 0 unless (startBlockNumber % NUM_LEAVES == 0)\n    // historicalRoots[chainId][startBlockNumber] holds the hash of\n    //   prevHash || root || numFinal\n    // where\n    // - prevHash is the parent hash of block startBlockNumber\n    // - root is the partial Merkle root of blockhashes of block numbers\n    //   [startBlockNumber, startBlockNumber + NUM_LEAVES)\n    //   where unconfirmed block hashes are 0's\n    // - numFinal is the number of confirmed consecutive roots in [startBlockNumber, startBlockNumber + NUM_LEAVES)\n    mapping(uint64 => mapping(uint32 => bytes32)) internal _historicalRoots; // chainid => (startBlockNumber => root)\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateAnchorBlockProvider(uint64 chainId, address newAddress);\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function updateAnchorBlockProvider(uint64 _chainId, address _provider) external onlyOwner {\n        anchorBlockProviders[_chainId] = _provider;\n        emit UpdateAnchorBlockProvider(_chainId, _provider);\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function historicalRoots(uint64 chainId, uint32 startBlockNumber) public view returns (bytes32) {\n        return _historicalRoots[chainId][startBlockNumber];\n    }\n\n    // after the groth16 proof are the public fields chunkRoot, prevHash, endHash (each in two uint128 represented in 256 bits), startBlockNum, endBlockNum\n    function getBoundaryBlockData(\n        bytes calldata proofData\n    )\n        internal\n        pure\n        returns (bytes32 chunkRoot, bytes32 prevHash, bytes32 endHash, uint32 startBlockNum, uint32 endBlockNum)\n    {\n        chunkRoot = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 32 + 16:PUBLIC_BYTES_START_IDX + 2 * 32]))\n        );\n        prevHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 3 * 32 + 16:PUBLIC_BYTES_START_IDX + 4 * 32]))\n        );\n        endHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 4 * 32:PUBLIC_BYTES_START_IDX + 5 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 5 * 32 + 16:PUBLIC_BYTES_START_IDX + 6 * 32]))\n        );\n        startBlockNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 7 * 32 - 4:PUBLIC_BYTES_START_IDX + 7 * 32]));\n        endBlockNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 8 * 32 - 4:PUBLIC_BYTES_START_IDX + 8 * 32]));\n    }\n\n    // update blocks in the \"backward\" direction, anchoring on a \"recent\" end blockhash from anchor contract\n    // * startBlockNumber must be a multiple of NUM_LEAVES\n    // * for now always endBlockNumber = startBlockNumber + NUM_LEAVES - 1 (full update on every NUM_LEAVES blocks chunk)\n    function updateRecent(uint64 chainId, bytes calldata proofData) external {\n        (\n            bytes32 chunkRoot,\n            bytes32 prevHash,\n            bytes32 endHash,\n            uint32 startBlockNum,\n            uint32 endBlockNum\n        ) = getBoundaryBlockData(proofData);\n\n        require(endBlockNum == startBlockNum + NUM_LEAVES - 1, \"need 128 blks\");\n        require(startBlockNum % NUM_LEAVES == 0, \"need start from 128x\");\n\n        require(anchorBlockProviders[chainId] != address(0), \"chain anchor provider not set\");\n        require(IAnchorBlocks(anchorBlockProviders[chainId]).blocks(endBlockNum) == endHash, \"endHash not correct\");\n\n        require(verifyRaw(chainId, proofData), \"proof not valid\");\n\n        _historicalRoots[chainId][startBlockNum] = keccak256(abi.encodePacked(prevHash, chunkRoot, NUM_LEAVES));\n        emit UpdateEvent(chainId, startBlockNum, prevHash, chunkRoot, NUM_LEAVES);\n    }\n\n    // update older blocks in \"backwards\" direction, anchoring on more recent trusted blockhash\n    // must be batch of NUM_LEAVES blocks\n    function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes calldata proofData) external {\n        (\n            bytes32 chunkRoot,\n            bytes32 prevHash,\n            bytes32 endHash,\n            uint32 startBlockNum,\n            uint32 endBlockNum\n        ) = getBoundaryBlockData(proofData);\n\n        require(startBlockNum % NUM_LEAVES == 0, \"need start from 128x\");\n        require(endBlockNum - startBlockNum == NUM_LEAVES - 1, \"need 128 blks\");\n\n        require(\n            historicalRoots(chainId, endBlockNum + 1) == keccak256(abi.encodePacked(endHash, nextRoot, nextNumFinal)),\n            \"endHash not correct\"\n        );\n        require(verifyRaw(chainId, proofData), \"proof not valid\");\n\n        _historicalRoots[chainId][startBlockNum] = keccak256(abi.encodePacked(prevHash, chunkRoot, NUM_LEAVES));\n        emit UpdateEvent(chainId, startBlockNum, prevHash, chunkRoot, NUM_LEAVES);\n    }\n\n    function isBlockHashValid(BlockHashWitness calldata witness) public view returns (bool) {\n        require(witness.claimedBlkHash != 0x0); // \"Claimed block hash cannot be 0\"\n        uint32 side = witness.blkNum % NUM_LEAVES;\n        uint32 startBlockNumber = witness.blkNum - side;\n        bytes32 merkleRoot = historicalRoots(witness.chainId, startBlockNumber);\n        require(merkleRoot != 0); // \"Merkle root must be stored already\"\n        // compute Merkle root of blockhash\n        bytes32 root = witness.claimedBlkHash;\n        for (uint8 depth = 0; depth < TREE_DEPTH; depth++) {\n            // 0 for left, 1 for right\n            if ((side >> depth) & 1 == 0) {\n                root = keccak256(abi.encodePacked(root, witness.merkleProof[depth]));\n            } else {\n                root = keccak256(abi.encodePacked(witness.merkleProof[depth], root));\n            }\n        }\n        return (merkleRoot == keccak256(abi.encodePacked(witness.prevHash, root, witness.numFinal)));\n    }\n}\n"
    },
    "contracts/chunk-sync/interfaces/IBlockChunks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface IBlockChunks {\n    // historicalRoots(chainId, startBlockNumber) is 0 unless (startBlockNumber % 128 == 0)\n    // historicalRoots(chainId, startBlockNumber) holds the hash of\n    //   prevHash || root || numFinal\n    // where\n    // - prevHash is the parent hash of block startBlockNumber\n    // - root is the partial Merkle root of blockhashes of block numbers\n    //   [startBlockNumber, startBlockNumber + 128)\n    //   where unconfirmed block hashes are 0's\n    // - numFinal is the number of confirmed consecutive roots in [startBlockNumber, startBlockNumber + 128)\n    function historicalRoots(uint64 chainId, uint32 startBlockNumber) external view returns (bytes32);\n\n    event UpdateEvent(uint64 chainId, uint32 startBlockNumber, bytes32 prevHash, bytes32 root, uint32 numFinal);\n\n    struct BlockHashWitness {\n        uint64 chainId;\n        uint32 blkNum;\n        bytes32 claimedBlkHash;\n        bytes32 prevHash;\n        uint32 numFinal;\n        bytes32[7] merkleProof;\n    }\n\n    // update blocks in the \"backward\" direction, anchoring on a \"recent\" end blockhash from anchor contract\n    // * startBlockNumber must be a multiple of 128\n    // * for now always endBlockNumber = startBlockNumber + 127 (full update on every 128 blocks chunk)\n    function updateRecent(uint64 chainId, bytes calldata proofData) external;\n\n    // update older blocks in \"backwards\" direction, anchoring on more recent trusted blockhash\n    // must be batch of 128 blocks\n    function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes calldata proofData) external;\n\n    function isBlockHashValid(BlockHashWitness calldata witness) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface IEthereumLightClient {\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/light-client/AnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/IEthereumLightClient.sol\";\nimport \"./interfaces/IAnchorBlocks.sol\";\n\nimport \"./common/Helpers.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Types.sol\";\n\nuint256 constant EXECUTION_BLOCK_LEFT_PREFIX_LEN = 4;\n\ncontract AnchorBlocks is IAnchorBlocks, Ownable {\n    // BlockHashWitness is the RLP code that witnesses the generation of block hash given the ParentHash field\n    struct BlockHashWitness {\n        bytes left;\n        bytes right;\n    }\n\n    event AnchorBlockUpdated(uint256 blockNum, bytes32 blockHash);\n\n    IEthereumLightClient public lightClient;\n    // execution block number => execution block hash\n    mapping(uint256 => bytes32) public blocks;\n    uint256 public latestBlockNum;\n\n    constructor(address _lightClient) {\n        lightClient = IEthereumLightClient(_lightClient);\n    }\n\n    /// @notice Updates an \"anchor block\" of a specific block number to the contract state\n    function processUpdate(LightClientOptimisticUpdate memory hb) external {\n        (uint256 blockNum, bytes32 blockHash) = verifyHeadBlock(hb);\n        require(blockHash != bytes32(0), \"empty blockHash\");\n        doUpdate(blockNum, blockHash);\n    }\n\n    /// @notice Updates an \"anchor block\" of a specific block number to the contract state\n    /// @dev It is possible that an attested block doesn't collect enough sync committee signatures in its corresponding\n    /// signature slot and thus cannot be used in an anchor update. In that case, the updater can pick a later block\n    /// that has enough sigs, and supply a chainProof to show that the block they want to sync can chain to the head block.\n    function processUpdateWithChainProof(\n        LightClientOptimisticUpdate memory hb,\n        bytes32 blockHash,\n        BlockHashWitness[] memory chainProof\n    ) external {\n        require(chainProof.length > 0, \"invalid proof length\");\n        (uint256 headBlockNum, bytes32 headBlockHash) = verifyHeadBlock(hb);\n        uint256 blockNum = headBlockNum - chainProof.length;\n        verifyChainProof(blockHash, chainProof, headBlockHash);\n        doUpdate(blockNum, blockHash);\n    }\n\n    function verifyHeadBlock(LightClientOptimisticUpdate memory hb) private view returns (uint256, bytes32) {\n        require(hasSupermajority(hb.syncAggregate.participation), \"quorum not reached\");\n        verifyExecutionPayload(hb.attestedHeader);\n        lightClient.verifyCommitteeSignature(hb.signatureSlot, hb.attestedHeader.beacon, hb.syncAggregate);\n        HeaderWithExecution memory h = hb.attestedHeader;\n        uint256 blockNum = Helpers.revertEndian(uint256(h.execution.blockNumber.leaf));\n        return (blockNum, h.execution.blockHash.leaf);\n    }\n\n    function verifyExecutionPayload(HeaderWithExecution memory h) private pure {\n        bool valid = Helpers.isValidMerkleBranch(h.executionRoot, EXECUTION_PAYLOAD_ROOT_INDEX, h.beacon.bodyRoot);\n        require(valid, \"bad exec root proof\");\n        verifyMerkleProof(h.execution.blockNumber, EXECUTION_BLOCK_NUMBER_LOCAL_INDEX, h.executionRoot.leaf);\n        verifyMerkleProof(h.execution.blockHash, EXECUTION_BLOCK_HASH_LOCAL_INDEX, h.executionRoot.leaf);\n    }\n\n    function doUpdate(uint256 blockNum, bytes32 blockHash) private {\n        require(blocks[blockNum] == bytes32(0), \"block hash already exists\");\n        blocks[blockNum] = blockHash;\n        if (blockNum > latestBlockNum) {\n            latestBlockNum = blockNum;\n        }\n        emit AnchorBlockUpdated(blockNum, blockHash);\n    }\n\n    function verifyChainProof(\n        bytes32 blockHash,\n        BlockHashWitness[] memory chainProof,\n        bytes32 headBlockHash\n    ) private pure {\n        bytes32 h = blockHash;\n        for (uint256 i = 0; i < chainProof.length; i++) {\n            // small hack to save some RLP encoding:\n            // We only care about whether the given blockHash can somehow combine with something to hash into headBlockHash.\n            // The RLP oding of a block always has 3 bytes for total length prefix and 1 byte (0xa0) for bytes32's length\n            // prefix; and the ParentHash field is always the first element. So there are always 8 bytes preceding ParentHash.\n            require(chainProof[i].left.length == EXECUTION_BLOCK_LEFT_PREFIX_LEN, \"invalid left len\");\n            h = keccak256(bytes.concat(chainProof[i].left, h, chainProof[i].right));\n        }\n        require(h == headBlockHash, \"invalid chainProof\");\n    }\n\n    function verifyMerkleProof(LeafWithBranch memory proof, uint256 index, bytes32 root) private pure {\n        require(Helpers.isValidMerkleBranch(proof, index, root), \"bad proof\");\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function setLightClient(address _lightClient) external onlyOwner {\n        lightClient = IEthereumLightClient(_lightClient);\n    }\n}\n"
    },
    "contracts/light-client/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\n// light client security params\nuint256 constant MIN_SYNC_COMMITTEE_PARTICIPANTS = 1;\nuint256 constant UPDATE_TIMEOUT = 86400;\n\n// beacon chain constants\nuint256 constant FINALIZED_ROOT_INDEX = 105;\nuint256 constant NEXT_SYNC_COMMITTEE_INDEX = 55;\nuint256 constant SYNC_COMMITTEE_SIZE = 512;\nuint64 constant SLOTS_PER_EPOCH = 32;\nuint64 constant EPOCHS_PER_SYNC_COMMITTEE_PERIOD = 256;\nbytes32 constant DOMAIN_SYNC_COMMITTEE = bytes32(uint256(0x07) << 248);\nuint256 constant SLOT_LENGTH_SECONDS = 12;\n\n// https://github.com/ethereum/consensus-specs/blob/dev/specs/capella/light-client/sync-protocol.md\n// beaconBodyRoot -> stateRoot gindex: 2 << 7 | 9 * 2 << 3 | 2\nuint256 constant EXECUTION_STATE_ROOT_INDEX = 402;\n// beaconBodyRoot -> blockHash gindex: 2 << 7 | 9 * 2 << 3 | 12\nuint256 constant EXECUTION_BLOCK_HASH_INDEX = 412;\n\n// the following indices are gindices counting from the executionPayloadRoot\n// beaconBodyRoot -> executionPayloadRoot gindex: 2 << 4 | 9\nuint256 constant EXECUTION_PAYLOAD_ROOT_INDEX = 25;\n// executionPayloadRoot -> stateRoot gindex: 2 << 4 | 2\nuint256 constant EXECUTION_STATE_ROOT_LOCAL_INDEX = 18;\n// executionPayloadRoot -> blockNumber gindex: 2 << 4 | 6\nuint256 constant EXECUTION_BLOCK_NUMBER_LOCAL_INDEX = 22;\n// executionPayloadRoot -> blockHash gindex: 2 << 4 | 12\nuint256 constant EXECUTION_BLOCK_HASH_LOCAL_INDEX = 28;\n"
    },
    "contracts/light-client/common/Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"./Types.sol\";\n\nlibrary Helpers {\n    function isValidMerkleBranch(LeafWithBranch memory lwb, uint256 index, bytes32 root) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(lwb.leaf, lwb.branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function isValidMerkleBranch(\n        bytes32 leaf,\n        bytes32[] memory branch,\n        uint256 index,\n        bytes32 root\n    ) internal pure returns (bool) {\n        bytes32 restoredMerkleRoot = restoreMerkleRoot(leaf, branch, index);\n        return root == restoredMerkleRoot;\n    }\n\n    function concatMerkleBranches(bytes32[] memory a, bytes32[] memory b) internal pure returns (bytes32[] memory) {\n        bytes32[] memory c = new bytes32[](a.length + b.length);\n        for (uint256 i = 0; i < a.length + b.length; i++) {\n            if (i < a.length) {\n                c[i] = a[i];\n            } else {\n                c[i] = b[i - a.length];\n            }\n        }\n        return c;\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, bytes32[] memory branch, uint256 index) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < branch.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(branch[i], value));\n            } else {\n                value = sha256(bytes.concat(value, branch[i]));\n            }\n        }\n        return value;\n    }\n\n    function hashTreeRoot(BeaconBlockHeader memory header) internal pure returns (bytes32) {\n        bytes32 left = sha256(\n            bytes.concat(\n                sha256(bytes.concat(bytes32(revertEndian(header.slot)), bytes32(revertEndian(header.proposerIndex)))),\n                sha256(bytes.concat(header.parentRoot, header.stateRoot))\n            )\n        );\n        bytes32 right = sha256(\n            bytes.concat(\n                sha256(bytes.concat(header.bodyRoot, bytes32(0))),\n                sha256(bytes.concat(bytes32(0), bytes32(0)))\n            )\n        );\n        return sha256(bytes.concat(left, right));\n    }\n\n    function revertEndian(uint256 x) internal pure returns (uint256) {\n        uint256 res;\n        for (uint256 i = 0; i < 32; i++) {\n            res = (res << 8) | (x & 0xff);\n            x >>= 8;\n        }\n        return res;\n    }\n}\n"
    },
    "contracts/light-client/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../../verifiers/interfaces/IBeaconVerifier.sol\";\n\nstruct LightClientOptimisticUpdate {\n    // Header attested to by the sync committee\n    HeaderWithExecution attestedHeader;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct LightClientUpdate {\n    // Header attested to by the sync committee\n    HeaderWithExecution attestedHeader;\n    HeaderWithExecution finalizedHeader;\n    // merkle branch from finalized beacon header root to attestedHeader.stateRoot\n    bytes32[] finalityBranch;\n    bytes32 nextSyncCommitteeRoot;\n    bytes32[] nextSyncCommitteeBranch;\n    bytes32 nextSyncCommitteePoseidonRoot;\n    IBeaconVerifier.Proof nextSyncCommitteeRootMappingProof;\n    // Sync committee aggregate signature participation & zk proof\n    SyncAggregate syncAggregate;\n    // Slot at which the aggregate signature was created (untrusted)\n    uint64 signatureSlot;\n}\n\nstruct HeaderWithExecution {\n    BeaconBlockHeader beacon;\n    ExecutionPayload execution;\n    // merkle branch from execution payload root to beacon block root\n    LeafWithBranch executionRoot;\n}\n\nfunction isEmpty(HeaderWithExecution memory header) pure returns (bool) {\n    return header.beacon.stateRoot == bytes32(0);\n}\n\n// only contains the fields we care about in execution payload\nstruct ExecutionPayload {\n    // merkle branch from execution state root to execution payload root\n    LeafWithBranch stateRoot;\n    // merkle branch from execution block hash to execution payload root\n    LeafWithBranch blockHash;\n    // merkle branch from execution block number to execution payload root\n    LeafWithBranch blockNumber;\n}\n\nfunction isEmpty(ExecutionPayload memory payload) pure returns (bool) {\n    return\n        payload.stateRoot.leaf == bytes32(0) &&\n        payload.blockHash.leaf == bytes32(0) &&\n        payload.blockNumber.leaf == bytes32(0);\n}\n\nstruct LeafWithBranch {\n    bytes32 leaf;\n    bytes32[] branch;\n}\n\nstruct BeaconBlockHeader {\n    uint64 slot;\n    uint64 proposerIndex;\n    bytes32 parentRoot;\n    bytes32 stateRoot;\n    bytes32 bodyRoot;\n}\n\nstruct SyncAggregate {\n    uint64 participation;\n    bytes32 poseidonRoot;\n    uint256 commitment;\n    IBeaconVerifier.Proof proof;\n}\n"
    },
    "contracts/light-client/EthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/IEthereumLightClient.sol\";\nimport \"./LightClientStore.sol\";\nimport \"./common/Helpers.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Types.sol\";\n\ncontract EthereumLightClient is IEthereumLightClient, LightClientStore, Ownable {\n    event OptimisticUpdate(uint256 slot, bytes32 executionStateRoot);\n    event FinalityUpdate(uint256 slot, bytes32 executionStateRoot);\n    event SyncCommitteeUpdated(uint256 period, bytes32 sszRoot, bytes32 poseidonRoot);\n    event ForkVersionUpdated(uint64 epoch, bytes4 forkVersion);\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        uint64 _finalizedSlot,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    )\n        LightClientStore(\n            genesisTime,\n            genesisValidatorsRoot,\n            _forkEpochs,\n            _forkVersions,\n            _finalizedSlot,\n            syncCommitteeRoot,\n            syncCommitteePoseidonRoot,\n            _zkVerifier\n        )\n    {}\n\n    function latestFinalizedSlotAndCommitteeRoots()\n        external\n        view\n        returns (uint64 slot, bytes32 currentRoot, bytes32 nextRoot)\n    {\n        return (finalizedSlot, currentSyncCommitteeRoot, nextSyncCommitteeRoot);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (optimisticExecutionStateRoot, optimisticSlot);\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (finalizedExecutionStateRoot, finalizedSlot);\n    }\n\n    function updateForkVersion(uint64 epoch, bytes4 forkVersion) external onlyOwner {\n        require(forkVersion != bytes4(0), \"bad fork version\");\n        forkEpochs.push(epoch);\n        forkVersions.push(forkVersion);\n        emit ForkVersionUpdated(epoch, forkVersion);\n    }\n\n    function processLightClientForceUpdate() external onlyOwner {\n        require(currentSlot() > finalizedSlot + UPDATE_TIMEOUT, \"timeout not passed\");\n        require(bestValidUpdate.attestedHeader.beacon.slot > 0, \"no best valid update\");\n\n        // Forced best update when the update timeout has elapsed.\n        // Because the apply logic waits for finalizedHeader.beacon.slot to indicate sync committee fin,\n        // the attestedHeader may be treated as finalizedHeader in extended periods of non-fin\n        // to guarantee progression into later sync committee periods according to isBetterUpdate().\n        if (bestValidUpdate.finalizedHeader.beacon.slot <= finalizedSlot) {\n            bestValidUpdate.finalizedHeader = bestValidUpdate.attestedHeader;\n        }\n        applyFinalityUpdate(bestValidUpdate);\n        delete bestValidUpdate;\n    }\n\n    function processLightClientUpdate(LightClientUpdate memory update) public {\n        bool quorumReached = hasSupermajority(update.syncAggregate.participation);\n        bool betterUpdate = isBetterUpdate(update, bestValidUpdate);\n        require(betterUpdate || quorumReached, \"quorum not reached\");\n        validateLightClientUpdate(update);\n\n        // Update the best update in case we have to force-update to it if the timeout elapses\n        if (betterUpdate) {\n            bestValidUpdate = update;\n        }\n        // Apply optimistic update\n        if (quorumReached && update.attestedHeader.beacon.slot > optimisticSlot) {\n            applyOptimisticUpdate(update);\n        }\n        // Apply finality update\n        if (\n            quorumReached &&\n            (update.finalizedHeader.beacon.slot > finalizedSlot ||\n                (hasNextSyncCommittee(update) && nextSyncCommitteeRoot == bytes32(0)))\n        ) {\n            applyFinalityUpdate(update);\n            delete bestValidUpdate;\n        }\n    }\n\n    function validateLightClientUpdate(LightClientUpdate memory update) private view {\n        // Verify sync committee has sufficient participants\n        require(update.syncAggregate.participation > MIN_SYNC_COMMITTEE_PARTICIPANTS, \"not enough participation\");\n        // Verify update does not skip a sync committee period\n        require(\n            currentSlot() > update.attestedHeader.beacon.slot &&\n                update.attestedHeader.beacon.slot > update.finalizedHeader.beacon.slot,\n            \"bad slot\"\n        );\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n\n        // Verify update is relavant\n        uint64 updateAttestedPeriod = computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot);\n        bool updateHasNextSyncCommittee = nextSyncCommitteeRoot == bytes32(0) &&\n            hasNextSyncCommitteeProof(update) &&\n            updateAttestedPeriod == storePeriod;\n        // Since sync committee update prefers older header (see isBetterUpdate), an update either\n        // needs to have a newer header or it should have sync committee update.\n        require(\n            update.attestedHeader.beacon.slot > finalizedSlot || updateHasNextSyncCommittee,\n            \"bad att slot or committee\"\n        );\n\n        // Verify that the finalityBranch, if present, confirms finalizedHeader\n        // to match the finalized checkpoint root saved in the state of attestedHeader.\n        // Note that the genesis finalized checkpoint root is represented as a zero hash.\n        if (!hasFinalityProof(update)) {\n            require(isEmpty(update.finalizedHeader), \"no fin proof\");\n        } else {\n            // genesis block header\n            if (update.finalizedHeader.beacon.slot == 0) {\n                require(isEmpty(update.finalizedHeader), \"genesis header should be empty\");\n            } else {\n                bool isValidFinalityProof = Helpers.isValidMerkleBranch(\n                    Helpers.hashTreeRoot(update.finalizedHeader.beacon),\n                    update.finalityBranch,\n                    FINALIZED_ROOT_INDEX,\n                    update.attestedHeader.beacon.stateRoot\n                );\n                require(isValidFinalityProof, \"bad fin proof\");\n                verifyExecutionPayload(update.finalizedHeader, \"finalized\");\n            }\n        }\n\n        // Verify that the update's nextSyncCommittee, if present, actually is the next sync committee\n        // saved in the state of the update's attested header\n        if (!hasNextSyncCommitteeProof(update)) {\n            require(\n                update.nextSyncCommitteeRoot == bytes32(0) && update.nextSyncCommitteePoseidonRoot == bytes32(0),\n                \"no next sync committee proof\"\n            );\n        } else {\n            if (updateAttestedPeriod == storePeriod && nextSyncCommitteeRoot != bytes32(0)) {\n                require(update.nextSyncCommitteeRoot == nextSyncCommitteeRoot, \"bad next sync committee\");\n            }\n            bool validSyncCommitteeProof = Helpers.isValidMerkleBranch(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteeBranch,\n                NEXT_SYNC_COMMITTEE_INDEX,\n                update.attestedHeader.beacon.stateRoot\n            );\n            require(validSyncCommitteeProof, \"bad next sync committee proof\");\n            bool validCommitteeRootMappingProof = zkVerifier.verifySyncCommitteeRootMappingProof(\n                update.nextSyncCommitteeRoot,\n                update.nextSyncCommitteePoseidonRoot,\n                update.nextSyncCommitteeRootMappingProof\n            );\n            require(validCommitteeRootMappingProof, \"bad next sync committee root mapping proof\");\n        }\n\n        // Verify optimistic execution payload\n        verifyExecutionPayload(update.attestedHeader, \"optimistic\");\n\n        // Verify sync committee signature ZK proof\n        verifyCommitteeSignature(update.signatureSlot, update.attestedHeader.beacon, update.syncAggregate);\n    }\n\n    function verifyCommitteeSignature(\n        uint64 signatureSlot,\n        BeaconBlockHeader memory header,\n        SyncAggregate memory syncAggregate\n    ) public view {\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n        uint64 updateSigPeriod = computeSyncCommitteePeriodAtSlot(signatureSlot);\n        if (nextSyncCommitteeRoot != bytes32(0)) {\n            require(updateSigPeriod == storePeriod || updateSigPeriod == storePeriod + 1, \"bad sig period 2\");\n        } else {\n            require(updateSigPeriod == storePeriod, \"bad sig period 1\");\n        }\n\n        bytes4 forkVersion = computeForkVersion(computeEpochAtSlot(signatureSlot));\n        bytes32 domain = computeDomain(forkVersion);\n        bytes32 signingRoot = computeSigningRoot(header, domain);\n        bytes32 activeSyncCommitteePoseidonRoot;\n        if (updateSigPeriod == storePeriod) {\n            require(currentSyncCommitteePoseidonRoot == syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = currentSyncCommitteePoseidonRoot;\n        } else {\n            require(nextSyncCommitteePoseidonRoot == syncAggregate.poseidonRoot, \"bad poseidon root\");\n            activeSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n        }\n        require(\n            zkVerifier.verifySignatureProof(\n                signingRoot,\n                activeSyncCommitteePoseidonRoot,\n                syncAggregate.participation,\n                syncAggregate.commitment,\n                syncAggregate.proof\n            ),\n            \"bad bls sig proof\"\n        );\n    }\n\n    function verifyExecutionPayload(HeaderWithExecution memory h, string memory name) private pure {\n        ExecutionPayload memory exec = h.execution;\n        bool valid = Helpers.isValidMerkleBranch(h.executionRoot, EXECUTION_PAYLOAD_ROOT_INDEX, h.beacon.bodyRoot);\n        require(valid, string.concat(\"bad exec root proof \", name));\n        valid = Helpers.isValidMerkleBranch(exec.stateRoot, EXECUTION_STATE_ROOT_LOCAL_INDEX, h.executionRoot.leaf);\n        require(valid, string.concat(\"bad exec state root proof \", name));\n    }\n\n    function applyOptimisticUpdate(LightClientUpdate memory update) private {\n        HeaderWithExecution memory h = update.attestedHeader;\n        bytes32 stateRoot = h.execution.stateRoot.leaf;\n        optimisticExecutionStateRoot = stateRoot;\n        optimisticSlot = h.beacon.slot;\n        emit OptimisticUpdate(h.beacon.slot, stateRoot);\n    }\n\n    function applyFinalityUpdate(LightClientUpdate memory update) private {\n        uint64 updateSlot = update.finalizedHeader.beacon.slot;\n        uint64 storePeriod = computeSyncCommitteePeriodAtSlot(finalizedSlot);\n        uint64 updateFinalizedPeriod = computeSyncCommitteePeriodAtSlot(updateSlot);\n        if (nextSyncCommitteeRoot == bytes32(0)) {\n            require(updateFinalizedPeriod == storePeriod, \"mismatch period\");\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        } else if (updateFinalizedPeriod == storePeriod + 1) {\n            currentSyncCommitteeRoot = nextSyncCommitteeRoot;\n            currentSyncCommitteePoseidonRoot = nextSyncCommitteePoseidonRoot;\n            nextSyncCommitteeRoot = update.nextSyncCommitteeRoot;\n            nextSyncCommitteePoseidonRoot = update.nextSyncCommitteePoseidonRoot;\n            emit SyncCommitteeUpdated(updateFinalizedPeriod + 1, nextSyncCommitteeRoot, nextSyncCommitteePoseidonRoot);\n        }\n        bytes32 updateExecStateRoot = update.finalizedHeader.execution.stateRoot.leaf;\n        if (updateSlot > finalizedSlot) {\n            finalizedExecutionStateRoot = updateExecStateRoot;\n            finalizedSlot = updateSlot;\n            emit FinalityUpdate(updateSlot, updateExecStateRoot);\n            return;\n        }\n    }\n\n    /*\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_better_update\n     */\n    function isBetterUpdate(\n        LightClientUpdate memory newUpdate,\n        LightClientUpdate memory oldUpdate\n    ) private pure returns (bool) {\n        // Old update doesn't exist\n        if (oldUpdate.syncAggregate.participation == 0) {\n            return newUpdate.syncAggregate.participation > 0;\n        }\n\n        // Compare supermajority (> 2/3) sync committee participation\n        bool newHasSupermajority = hasSupermajority(newUpdate.syncAggregate.participation);\n        bool oldHasSupermajority = hasSupermajority(oldUpdate.syncAggregate.participation);\n        if (newHasSupermajority != oldHasSupermajority) {\n            // the new update is a better one if new has supermajority but old doesn't\n            return newHasSupermajority && !oldHasSupermajority;\n        }\n        if (!newHasSupermajority && newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            // a better update is the one with higher participation when both new and old doesn't have supermajority\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Compare presence of relevant sync committee\n        bool newHasSyncCommittee = hasRelavantSyncCommittee(newUpdate);\n        bool oldHasSyncCommittee = hasRelavantSyncCommittee(oldUpdate);\n        if (newHasSyncCommittee != oldHasSyncCommittee) {\n            return newHasSyncCommittee;\n        }\n\n        // Compare indication of any fin\n        bool newHasFinality = hasFinalityProof(newUpdate);\n        bool oldHasFinality = hasFinalityProof(oldUpdate);\n        if (newHasFinality != oldHasFinality) {\n            return newHasFinality;\n        }\n\n        // Compare sync committee fin\n        if (newHasFinality) {\n            bool newHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(newUpdate.finalizedHeader.beacon.slot) ==\n                computeSyncCommitteePeriodAtSlot(newUpdate.attestedHeader.beacon.slot);\n            bool oldHasCommitteeFinality = computeSyncCommitteePeriodAtSlot(oldUpdate.finalizedHeader.beacon.slot) ==\n                computeSyncCommitteePeriodAtSlot(oldUpdate.attestedHeader.beacon.slot);\n            if (newHasCommitteeFinality != oldHasCommitteeFinality) {\n                return newHasCommitteeFinality;\n            }\n        }\n\n        // Tiebreaker 1: Sync committee participation beyond supermajority\n        if (newUpdate.syncAggregate.participation != oldUpdate.syncAggregate.participation) {\n            return newUpdate.syncAggregate.participation > oldUpdate.syncAggregate.participation;\n        }\n\n        // Tiebreaker 2: Prefer older data (fewer changes to best)\n        if (newUpdate.attestedHeader.beacon.slot != oldUpdate.attestedHeader.beacon.slot) {\n            return newUpdate.attestedHeader.beacon.slot < oldUpdate.attestedHeader.beacon.slot;\n        }\n\n        return newUpdate.signatureSlot < oldUpdate.signatureSlot;\n    }\n\n    function hasRelavantSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.signatureSlot);\n    }\n\n    function hasNextSyncCommitteeProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.nextSyncCommitteeBranch.length > 0;\n    }\n\n    function hasNextSyncCommittee(LightClientUpdate memory update) private pure returns (bool) {\n        return\n            hasNextSyncCommitteeProof(update) &&\n            hasFinalityProof(update) &&\n            computeSyncCommitteePeriodAtSlot(update.finalizedHeader.beacon.slot) ==\n            computeSyncCommitteePeriodAtSlot(update.attestedHeader.beacon.slot);\n    }\n\n    function hasFinalityProof(LightClientUpdate memory update) private pure returns (bool) {\n        return update.finalityBranch.length > 0;\n    }\n\n    function hasSupermajority(uint64 participation) private pure returns (bool) {\n        return participation * 3 >= SYNC_COMMITTEE_SIZE * 2;\n    }\n\n    function currentSlot() private view returns (uint64) {\n        return uint64((block.timestamp - GENESIS_TIME) / SLOT_LENGTH_SECONDS);\n    }\n\n    function computeForkVersion(uint64 epoch) private view returns (bytes4) {\n        for (uint256 i = forkVersions.length - 1; i >= 0; i--) {\n            if (epoch >= forkEpochs[i]) {\n                return forkVersions[i];\n            }\n        }\n        revert(\"fork versions not set\");\n    }\n\n    function computeSyncCommitteePeriodAtSlot(uint64 slot) private pure returns (uint64) {\n        return computeSyncCommitteePeriod(computeEpochAtSlot(slot));\n    }\n\n    function computeEpochAtSlot(uint64 slot) private pure returns (uint64) {\n        return slot / SLOTS_PER_EPOCH;\n    }\n\n    function computeSyncCommitteePeriod(uint64 epoch) private pure returns (uint64) {\n        return epoch / EPOCHS_PER_SYNC_COMMITTEE_PERIOD;\n    }\n\n    /**\n     * https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_domain\n     */\n    function computeDomain(bytes4 forkVersion) public view returns (bytes32) {\n        return DOMAIN_SYNC_COMMITTEE | (sha256(abi.encode(forkVersion, GENESIS_VALIDATOR_ROOT)) >> 32);\n    }\n\n    // computeDomain(forkVersion, genesisValidatorsRoot)\n    function computeSigningRoot(BeaconBlockHeader memory header, bytes32 domain) public pure returns (bytes32) {\n        return sha256(bytes.concat(Helpers.hashTreeRoot(header), domain));\n    }\n}\n"
    },
    "contracts/light-client/interfaces/IAnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface IAnchorBlocks {\n    function blocks(uint256 blockNum) external view returns (bytes32);\n}\n"
    },
    "contracts/light-client/interfaces/IEthereumLightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../common/Types.sol\";\n\ninterface IEthereumLightClient {\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot);\n\n    // reverts if check fails\n    function verifyCommitteeSignature(\n        uint64 signatureSlot,\n        BeaconBlockHeader memory header,\n        SyncAggregate memory syncAggregate\n    ) external view;\n}\n"
    },
    "contracts/light-client/LightClientStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"./common/Types.sol\";\nimport \"../verifiers/interfaces/IBeaconVerifier.sol\";\n\nabstract contract LightClientStore {\n    // beacon chain genesis information\n    uint256 immutable GENESIS_TIME;\n    bytes32 immutable GENESIS_VALIDATOR_ROOT;\n\n    uint64 public finalizedSlot;\n    bytes32 public finalizedExecutionStateRoot;\n\n    uint64 public optimisticSlot;\n    bytes32 public optimisticExecutionStateRoot;\n\n    bytes32 public currentSyncCommitteeRoot;\n    bytes32 public currentSyncCommitteePoseidonRoot;\n    bytes32 public nextSyncCommitteeRoot;\n    bytes32 public nextSyncCommitteePoseidonRoot;\n\n    LightClientUpdate public bestValidUpdate;\n\n    // fork versions\n    uint64[] public forkEpochs;\n    bytes4[] public forkVersions;\n\n    // zk verifier\n    IBeaconVerifier public zkVerifier; // contract too big. need to move this one out\n\n    constructor(\n        uint256 genesisTime,\n        bytes32 genesisValidatorsRoot,\n        uint64[] memory _forkEpochs,\n        bytes4[] memory _forkVersions,\n        uint64 _finalizedSlot,\n        bytes32 syncCommitteeRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        address _zkVerifier\n    ) {\n        GENESIS_TIME = genesisTime;\n        GENESIS_VALIDATOR_ROOT = genesisValidatorsRoot;\n        forkEpochs = _forkEpochs;\n        forkVersions = _forkVersions;\n        finalizedSlot = _finalizedSlot;\n        currentSyncCommitteeRoot = syncCommitteeRoot;\n        currentSyncCommitteePoseidonRoot = syncCommitteePoseidonRoot;\n        zkVerifier = IBeaconVerifier(_zkVerifier);\n    }\n}\n"
    },
    "contracts/message-bridge/apps/examples/MsgInOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\n\nimport \"../../framework/MessageApp.sol\";\n\n// a simple example to enforce in-order message delivery\ncontract MsgInOrder is MessageApp {\n    event MessageReceived(uint64 srcChainId, address srcContract, address sender, uint64 seq, bytes message);\n\n    // map at source chain. (dstChainId, dstContract) -> seq\n    mapping(uint64 => mapping(address => uint64)) public sendSeq;\n\n    // map at destination chain (srcChainId, srcContract) -> seq\n    mapping(uint64 => mapping(address => uint64)) public recvSeq;\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    // called by user on source chain to send cross-chain message\n    function sendMessage(uint64 _dstChainId, address _dstContract, bytes calldata _message) external payable {\n        uint64 seq = sendSeq[_dstChainId][_dstContract];\n        bytes memory message = abi.encode(msg.sender, seq, _message);\n        _sendMessage(_dstChainId, _dstContract, message);\n        sendSeq[_dstChainId][_dstContract] += 1;\n    }\n\n    // called by MessageBridge on destination chain to receive message\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _srcContract,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        (address sender, uint64 seq, bytes memory message) = abi.decode((_message), (address, uint64, bytes));\n        uint64 expectedSeq = recvSeq[_srcChainId][_srcContract];\n        require(seq == expectedSeq, _abortReason(\"sequence number not expected\")); // let execution retry later.\n        emit MessageReceived(_srcChainId, _srcContract, sender, seq, message);\n        recvSeq[_srcChainId][_srcContract] += 1;\n    }\n}\n"
    },
    "contracts/message-bridge/apps/examples/MsgTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9;\n\nimport \"../../framework/MessageApp.sol\";\n\n// A HelloWorld test example for basic cross-chain message passing\ncontract MsgTest is MessageApp {\n    event MessageReceived(uint64 srcChainId, address srcContract, address sender, uint64 number);\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    // called by user on source chain to send cross-chain messages\n    function sendMessage(uint64 _dstChainId, address _dstContract, uint64 _number) external {\n        bytes memory message = abi.encode(msg.sender, _number);\n        _sendMessage(_dstChainId, _dstContract, message);\n    }\n\n    // called by MessageBridge on destination chain to receive cross-chain messages\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _srcContract,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        (address sender, uint64 number) = abi.decode((_message), (address, uint64));\n        require(number != 1000, _abortReason(\"test abort\"));\n        require(number != 1001, \"test revert\");\n        emit MessageReceived(_srcChainId, _srcContract, sender, number);\n    }\n}\n"
    },
    "contracts/message-bridge/apps/token-bridge/MintableERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/**\n * @title A mintable {ERC20} token.\n */\ncontract MintableERC20 is ERC20Burnable, Ownable {\n    uint8 private _decimals;\n    address private _minter;\n\n    /**\n     * @dev Constructor that gives msg.sender an initial supply of tokens.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 initialSupply_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n        _minter = msg.sender;\n        _mint(msg.sender, initialSupply_);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function minter() public view virtual returns (address) {\n        return _minter;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the minter.\n     */\n    modifier onlyMinter() {\n        require(minter() == msg.sender, \"Mintable: caller is not the minter\");\n        _;\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     */\n    function mint(address to, uint256 amount) public onlyMinter {\n        _mint(to, amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function setMinter(address minter_) external onlyOwner {\n        _minter = minter_;\n    }\n}\n"
    },
    "contracts/message-bridge/apps/token-bridge/PegBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../framework/MessageApp.sol\";\n\ninterface IPeggedToken {\n    function mint(address _to, uint256 _amount) external;\n\n    function burnFrom(address _from, uint256 _amount) external;\n}\n\ncontract PegBridge is MessageApp, Ownable {\n    using SafeERC20 for IERC20;\n\n    mapping(bytes32 => bool) public records;\n    mapping(address => uint256) public supplies;\n    mapping(address => address) public vaultToPegTokens; // vault -> peg\n    mapping(address => address) public pegToVaultTokens; // peg -> vault\n\n    mapping(address => uint256) public minBurn;\n\n    uint64 public vaultChain;\n    address public vaultAddress;\n\n    event Mint(bytes32 mintId, address account, address token, uint256 amount, bytes32 refId, address depositor);\n\n    event Burn(\n        bytes32 burnId,\n        address burnAccount,\n        address token,\n        uint256 amount,\n        address withdrawAccount,\n        uint64 nonce,\n        bytes32 messageId\n    );\n\n    event BridgeTokenAdded(address vaultToken, address pegToken);\n    event BridgeTokenDeleted(address vaultToken, address pegToken);\n    event MinBurnUpdated(address token, uint256 amount);\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _sender,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        require(_srcChainId == vaultChain, \"not from vault chain\");\n        require(_sender == vaultAddress, \"sender is not token vault\");\n        _mint(_message);\n    }\n\n    function _mint(bytes calldata _message) private {\n        (address vaultToken, uint256 amount, address mintAccount, address depositor, bytes32 depositId) = abi.decode(\n            (_message),\n            (address, uint256, address, address, bytes32)\n        );\n        address pegToken = vaultToPegTokens[vaultToken];\n        require(pegToken != address(0), \"no peg token\");\n        bytes32 mintId = keccak256(\n            abi.encodePacked(pegToken, amount, mintAccount, depositor, depositId, address(this))\n        );\n        require(records[mintId] == false, \"record exists\");\n        records[mintId] = true;\n        IPeggedToken(pegToken).mint(mintAccount, amount);\n        supplies[pegToken] += amount;\n        emit Mint(mintId, mintAccount, pegToken, amount, depositId, depositor);\n    }\n\n    function burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) external returns (bytes32) {\n        bytes32 burnId = _burn(_token, _amount, _toChainId, _withdrawAccount, _nonce);\n        IPeggedToken(_token).burnFrom(msg.sender, _amount);\n        return burnId;\n    }\n\n    function _burn(\n        address _token,\n        uint256 _amount,\n        uint64 _toChainId,\n        address _withdrawAccount,\n        uint64 _nonce\n    ) private returns (bytes32) {\n        require(_amount > minBurn[_token], \"amount too small\");\n        address vaultToken = pegToVaultTokens[_token];\n        require(vaultToken != address(0), \"no vault token\");\n        supplies[_token] -= _amount;\n        bytes32 burnId = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                _token,\n                _amount,\n                _toChainId,\n                _withdrawAccount,\n                _nonce,\n                uint64(block.chainid),\n                address(this)\n            )\n        );\n        require(records[burnId] == false, \"record exists\");\n        records[burnId] = true;\n        bytes memory message = abi.encode(vaultToken, _amount, _withdrawAccount, msg.sender, burnId);\n        bytes32 messageId = _sendMessage(_toChainId, vaultAddress, message);\n        emit Burn(burnId, msg.sender, _token, _amount, _withdrawAccount, _nonce, messageId);\n        return burnId;\n    }\n\n    function setBridgeTokens(address[] calldata _vaultTokens, address[] calldata _pegTokens) external onlyOwner {\n        require(_vaultTokens.length == _pegTokens.length, \"length mismatch\");\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            vaultToPegTokens[_vaultTokens[i]] = _pegTokens[i];\n            pegToVaultTokens[_pegTokens[i]] = _vaultTokens[i];\n            emit BridgeTokenAdded(_vaultTokens[i], _pegTokens[i]);\n        }\n    }\n\n    function deletePegTokens(address[] calldata _pegTokens) external onlyOwner {\n        for (uint256 i = 0; i < _pegTokens.length; i++) {\n            address pegToken = _pegTokens[i];\n            address vaultToken = pegToVaultTokens[pegToken];\n            delete vaultToPegTokens[vaultToken];\n            delete pegToVaultTokens[pegToken];\n            emit BridgeTokenDeleted(vaultToken, pegToken);\n        }\n    }\n\n    function deleteVaultTokens(address[] calldata _vaultTokens) external onlyOwner {\n        for (uint256 i = 0; i < _vaultTokens.length; i++) {\n            address vaultToken = _vaultTokens[i];\n            address pegToken = vaultToPegTokens[vaultToken];\n            delete vaultToPegTokens[vaultToken];\n            delete pegToVaultTokens[pegToken];\n            emit BridgeTokenDeleted(vaultToken, pegToken);\n        }\n    }\n\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\n        require(_tokens.length == _amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            minBurn[_tokens[i]] = _amounts[i];\n            emit MinBurnUpdated(_tokens[i], _amounts[i]);\n        }\n    }\n\n    function setTokenVault(uint64 _vaultChain, address _vaultAddress) external onlyOwner {\n        vaultChain = _vaultChain;\n        vaultAddress = _vaultAddress;\n    }\n}\n"
    },
    "contracts/message-bridge/apps/token-bridge/TokenVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../framework/MessageApp.sol\";\n\ncontract TokenVault is MessageApp, Ownable {\n    using SafeERC20 for IERC20;\n\n    mapping(bytes32 => bool) public records;\n\n    mapping(uint64 => address) public remotePegBridges;\n\n    mapping(address => uint256) public minDeposit;\n\n    event Deposited(\n        bytes32 depositId,\n        address depositor,\n        address token,\n        uint256 amount,\n        address mintAccount,\n        uint64 nonce,\n        bytes32 messageId\n    );\n\n    event Withdrawn(\n        bytes32 withdrawId,\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes32 refId,\n        address burnAccount\n    );\n\n    event MinDepositUpdated(address token, uint256 amount);\n\n    constructor(IMessageBridge _messageBridge) MessageApp(_messageBridge) {}\n\n    function deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) external returns (bytes32) {\n        (bytes32 depositId, bytes32 messageId) = _deposit(_token, _amount, _mintChainId, _mintAccount, _nonce);\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        emit Deposited(depositId, msg.sender, _token, _amount, _mintAccount, _nonce, messageId);\n        return depositId;\n    }\n\n    function _deposit(\n        address _token,\n        uint256 _amount,\n        uint64 _mintChainId,\n        address _mintAccount,\n        uint64 _nonce\n    ) private returns (bytes32, bytes32) {\n        require(_amount > minDeposit[_token], \"amount too small\");\n        require(remotePegBridges[_mintChainId] != address(0), \"invalid mint chain\");\n        bytes32 depositId = keccak256(\n            abi.encodePacked(msg.sender, _token, _amount, _mintAccount, _nonce, uint64(block.chainid), address(this))\n        );\n        require(records[depositId] == false, \"record exists\");\n        bytes memory message = abi.encode(_token, _amount, _mintAccount, msg.sender, depositId);\n        bytes32 messageId = _sendMessage(_mintChainId, remotePegBridges[_mintChainId], message);\n        records[depositId] = true;\n        return (depositId, messageId);\n    }\n\n    function _handleMessage(\n        uint64 _srcChainId,\n        address _sender,\n        bytes calldata _message,\n        address // execution\n    ) internal override {\n        require(_sender == remotePegBridges[_srcChainId], \"sender is not remote peg bridge\");\n        _withdraw(_message);\n    }\n\n    function _withdraw(bytes calldata _message) private {\n        (address token, uint256 amount, address receiver, address burnAccount, bytes32 burnId) = abi.decode(\n            (_message),\n            (address, uint256, address, address, bytes32)\n        );\n        bytes32 withdrawId = keccak256(abi.encodePacked(receiver, token, amount, burnAccount, burnId, address(this)));\n        require(records[withdrawId] == false, \"record exists\");\n        records[withdrawId] = true;\n        IERC20(token).safeTransfer(receiver, amount);\n        emit Withdrawn(withdrawId, receiver, token, amount, burnId, burnAccount);\n    }\n\n    function setMinDeposit(address[] calldata _tokens, uint256[] calldata _amounts) external onlyOwner {\n        require(_tokens.length == _amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            minDeposit[_tokens[i]] = _amounts[i];\n            emit MinDepositUpdated(_tokens[i], _amounts[i]);\n        }\n    }\n\n    function setRemotePegBridge(uint64 _remoteChainId, address _remotePegBridge) external onlyOwner {\n        remotePegBridges[_remoteChainId] = _remotePegBridge;\n    }\n}\n"
    },
    "contracts/message-bridge/framework/MessageApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./MessageSenderApp.sol\";\nimport \"./MessageReceiverApp.sol\";\n\nabstract contract MessageApp is MessageSenderApp, MessageReceiverApp {\n    constructor(IMessageBridge _messageBridge) {\n        messageBridge = _messageBridge;\n    }\n}\n"
    },
    "contracts/message-bridge/framework/MessageBridgeAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../interfaces/IMessageBridge.sol\";\n\nabstract contract MessageBridgeAddress {\n    IMessageBridge public messageBridge;\n}\n"
    },
    "contracts/message-bridge/framework/MessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../interfaces/IMessageReceiverApp.sol\";\nimport \"../libraries/MsgLib.sol\";\nimport \"./MessageBridgeAddress.sol\";\n\nabstract contract MessageReceiverApp is IMessageReceiverApp, MessageBridgeAddress {\n    modifier onlyMessageBridge() {\n        require(msg.sender == address(messageBridge), \"caller is not message bridge\");\n        _;\n    }\n\n    /**\n     * @notice Called by MessageBridge to execute a message\n     * @param srcChainId The source chain ID where the message is originated from\n     * @param sender The address of the source app contract\n     * @param message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param executor Address who called the MessageBridge execution function\n     * @return true Always return true if _handleMessage is not reverted\n     */\n    function executeMessage(\n        uint64 srcChainId,\n        address sender,\n        bytes calldata message,\n        address executor\n    ) external onlyMessageBridge returns (bool) {\n        _handleMessage(srcChainId, sender, message, executor);\n        return true;\n    }\n\n    /**\n     * @notice Internally called by executeMessage function to execute a message\n     * @param srcChainId The source chain ID where the message is originated from\n     * @param sender The address of the source app contract\n     * @param message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param executor Address who called the MessageBridge execution function\n     */\n    function _handleMessage(\n        uint64 srcChainId,\n        address sender,\n        bytes calldata message,\n        address executor\n    ) internal virtual;\n\n    // Add abort prefix in the reason string for require or revert.\n    // This will abort (revert) the message execution without markig it as failed state,\n    // making it possible to retry later.\n    function _abortReason(string memory reason) internal pure returns (string memory) {\n        return string.concat(MsgLib.ABORT_PREFIX, reason);\n    }\n}\n"
    },
    "contracts/message-bridge/framework/MessageSenderApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../interfaces/IMessageBridge.sol\";\nimport \"./MessageBridgeAddress.sol\";\n\nabstract contract MessageSenderApp is MessageBridgeAddress {\n    /**\n     * @notice Send a message to a contract on another chain.\n     * @param dstChainId The destination chain ID.\n     * @param receiver The address of the destination app contract.\n     * @param message Arbitrary message bytes to be decoded by the destination app contract.\n     * @return messageId Message Id computed by MessageBridge\n     */\n    function _sendMessage(\n        uint64 dstChainId,\n        address receiver,\n        bytes memory message\n    ) internal returns (bytes32 messageId) {\n        return messageBridge.sendMessage(dstChainId, receiver, message);\n    }\n}\n"
    },
    "contracts/message-bridge/interfaces/IMessageBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport \"../../interfaces/IEthereumLightClient.sol\";\n\ninterface IMessageBridge {\n    enum MessageStatus {\n        Null,\n        Success,\n        Fail\n    }\n\n    event MessageSent(\n        bytes32 indexed messageId,\n        uint256 indexed nonce,\n        uint64 dstChainId,\n        address sender,\n        address receiver,\n        bytes message\n    );\n    event MessageExecuted(\n        bytes32 indexed messageId,\n        uint256 indexed nonce,\n        uint64 srcChainId,\n        address sender,\n        address receiver,\n        bytes message,\n        bool success\n    );\n    event MessageCallReverted(bytes32 messageId, string reason); // help debug\n\n    function lightClients(uint256 chainId) external view returns (IEthereumLightClient);\n\n    function sendMessage(uint64 dstChainId, address receiver, bytes calldata message) external returns (bytes32);\n\n    function executeMessage(\n        uint64 srcChainId,\n        uint64 nonce,\n        address sender,\n        address receiver,\n        bytes calldata message,\n        bytes[] calldata accountProof,\n        bytes[] calldata storageProof\n    ) external returns (bool);\n\n    function finalizedExecutionStateRootAndSlot(uint64 chainId) external view returns (bytes32 root, uint64 slot);\n}\n"
    },
    "contracts/message-bridge/interfaces/IMessageReceiverApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IMessageReceiverApp {\n    /**\n     * @notice Called by MessageBridge to execute a message\n     * @param _srcChainId The source chain ID where the message is originated from\n     * @param _sender The address of the source app contract\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBridge execution function\n     */\n    function executeMessage(\n        uint64 _srcChainId,\n        address _sender,\n        bytes calldata _message,\n        address _executor\n    ) external returns (bool);\n}\n"
    },
    "contracts/message-bridge/libraries/MerkleProofTree.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.18;\n\nimport \"./RLPReader.sol\";\n\nlibrary MerkleProofTree {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    function _gnaw(uint256 index, bytes32 key) private pure returns (uint256 gnaw) {\n        assembly {\n            gnaw := shr(mul(sub(63, index), 4), key)\n        }\n        return gnaw % 16;\n    }\n\n    function _pathLength(bytes memory path) private pure returns (uint256, bool) {\n        uint256 gnaw = uint256(uint8(path[0])) / 16;\n        return ((path.length - 1) * 2 + (gnaw % 2), gnaw > 1);\n    }\n\n    function read(bytes32 key, bytes[] memory proof) internal pure returns (bytes memory result) {\n        bytes32 root;\n        bytes memory node = proof[0];\n\n        uint256 index = 0;\n        uint256 pathLength = 0;\n\n        while (true) {\n            RLPReader.RLPItem[] memory items = node.toRlpItem().toList();\n            if (items.length == 17) {\n                uint256 gnaw = _gnaw(pathLength++, key);\n                root = bytes32(items[gnaw].toUint());\n            } else {\n                require(items.length == 2, \"MessageBridge: Iinvalid RLP list length\");\n                (uint256 nodePathLength, bool isLeaf) = _pathLength(items[0].toBytes());\n                pathLength += nodePathLength;\n                if (isLeaf) {\n                    return items[1].toBytes();\n                } else {\n                    root = bytes32(items[1].toUint());\n                }\n            }\n\n            node = proof[++index];\n            require(root == keccak256(node), \"MessageBridge: node hash mismatched\");\n        }\n    }\n\n    function restoreMerkleRoot(bytes32 leaf, uint256 index, bytes32[] memory proof) internal pure returns (bytes32) {\n        bytes32 value = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            if ((index / (2 ** i)) % 2 == 1) {\n                value = sha256(bytes.concat(proof[i], value));\n            } else {\n                value = sha256(bytes.concat(value, proof[i]));\n            }\n        }\n        return value;\n    }\n}\n"
    },
    "contracts/message-bridge/libraries/MsgLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity >=0.8.0;\n\nlibrary MsgLib {\n    string constant ABORT_PREFIX = \"MSG::ABORT:\";\n\n    function computeMessageId(\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        uint64 _srcChainId,\n        uint64 _dstChainId,\n        bytes calldata _message\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, _sender, _receiver, _srcChainId, _dstChainId, _message));\n    }\n\n    // https://ethereum.stackexchange.com/a/83577\n    // https://github.com/Uniswap/v3-periphery/blob/v1.0.0/contracts/base/Multicall.sol\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    function checkRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        string memory revertMsg = MsgLib.getRevertMsg(_returnData);\n        checkAbortPrefix(revertMsg);\n        return revertMsg;\n    }\n\n    function checkAbortPrefix(string memory _revertMsg) private pure {\n        bytes memory prefixBytes = bytes(ABORT_PREFIX);\n        bytes memory msgBytes = bytes(_revertMsg);\n        if (msgBytes.length >= prefixBytes.length) {\n            for (uint256 i = 0; i < prefixBytes.length; i++) {\n                if (msgBytes[i] != prefixBytes[i]) {\n                    return; // prefix not match, return\n                }\n            }\n            revert(_revertMsg); // prefix match, revert\n        }\n    }\n}\n"
    },
    "contracts/message-bridge/libraries/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <0.9.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    },
    "contracts/message-bridge/MessageBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IMessageBridge.sol\";\nimport \"./interfaces/IMessageReceiverApp.sol\";\nimport \"./libraries/RLPReader.sol\";\nimport \"./libraries/MerkleProofTree.sol\";\nimport \"./libraries/MsgLib.sol\";\nimport \"../interfaces/IEthereumLightClient.sol\";\n\ncontract MessageBridge is IMessageBridge, ReentrancyGuard, Ownable {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n\n    /* Sender side (source chain) storage */\n    mapping(uint64 => bytes32) public sentMessages; // nonce -> messageId\n    uint256 constant SENT_MESSAGES_STORAGE_SLOT = 2;\n    uint64 public nonce;\n\n    /* Receiver side (dest chain) storage */\n    mapping(bytes32 => MessageStatus) public receivedMessages; // messageId -> status\n    mapping(uint256 => IEthereumLightClient) public lightClients; // chainId -> light client\n    mapping(uint256 => address) public remoteMessageBridges; // chainId -> source chain bridge\n    mapping(uint256 => bytes32) public remoteMessageBridgeHashes;\n    // minimum amount of gas needed by this contract before it tries to deliver a message to the target.\n    uint256 public preExecuteMessageGasUsage;\n\n    /****************************************\n     * Sender side (source chain) functions *\n     ****************************************/\n\n    function sendMessage(uint64 _dstChainId, address _receiver, bytes calldata _message) external returns (bytes32) {\n        bytes32 messageId = MsgLib.computeMessageId(\n            nonce,\n            msg.sender,\n            _receiver,\n            uint64(block.chainid),\n            _dstChainId,\n            _message\n        );\n        sentMessages[nonce] = messageId;\n        emit MessageSent(messageId, nonce++, _dstChainId, msg.sender, _receiver, _message);\n        return messageId;\n    }\n\n    /****************************************\n     * Receiver side (dest chain) functions *\n     ****************************************/\n\n    function executeMessage(\n        uint64 _srcChainId,\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        bytes calldata _message,\n        bytes[] calldata _accountProof,\n        bytes[] calldata _storageProof\n    ) external nonReentrant returns (bool success) {\n        bytes32 messageId = MsgLib.computeMessageId(\n            _nonce,\n            _sender,\n            _receiver,\n            _srcChainId,\n            uint64(block.chainid),\n            _message\n        );\n        require(receivedMessages[messageId] == MessageStatus.Null, \"MessageBridge: message already executed\");\n\n        // verify the storageProof and message\n        require(\n            _retrieveStorageRoot(_srcChainId, _accountProof) == keccak256(_storageProof[0]),\n            \"MessageBridge: invalid storage root\"\n        );\n        bytes32 key = keccak256(abi.encode(keccak256(abi.encode(_nonce, SENT_MESSAGES_STORAGE_SLOT))));\n        bytes memory proof = MerkleProofTree.read(key, _storageProof);\n        require(bytes32(proof.toRlpItem().toUint()) == messageId, \"MessageBridge: invalid message hash\");\n\n        // execute message\n        bytes memory recieveCall = abi.encodeWithSelector(\n            IMessageReceiverApp.executeMessage.selector,\n            _srcChainId,\n            _sender,\n            _message,\n            msg.sender\n        );\n        uint256 gasLeftBeforeExecution = gasleft();\n        (bool ok, bytes memory res) = _receiver.call(recieveCall);\n        if (ok) {\n            success = abi.decode((res), (bool));\n        } else {\n            _handleExecutionRevert(messageId, gasLeftBeforeExecution, res);\n        }\n        receivedMessages[messageId] = success ? MessageStatus.Success : MessageStatus.Fail;\n        emit MessageExecuted(messageId, _nonce, _srcChainId, _sender, _receiver, _message, success);\n        return success;\n    }\n\n    function setLightClient(uint64 _chainId, address _lightClient) external onlyOwner {\n        lightClients[_chainId] = IEthereumLightClient(_lightClient);\n    }\n\n    function setRemoteMessageBridge(uint64 _chainId, address _remoteMessageBridge) external onlyOwner {\n        remoteMessageBridges[_chainId] = _remoteMessageBridge;\n        remoteMessageBridgeHashes[_chainId] = keccak256(abi.encodePacked(_remoteMessageBridge));\n    }\n\n    function setPreExecuteMessageGasUsage(uint256 _usage) public onlyOwner {\n        preExecuteMessageGasUsage = _usage;\n    }\n\n    function finalizedExecutionStateRootAndSlot(uint64 _chainId) public view returns (bytes32 root, uint64 slot) {\n        return lightClients[_chainId].finalizedExecutionStateRootAndSlot();\n    }\n\n    function _retrieveStorageRoot(uint64 _srcChainId, bytes[] calldata _accountProof) private view returns (bytes32) {\n        // verify accountProof and get storageRoot\n        (bytes32 executionStateRoot, ) = finalizedExecutionStateRootAndSlot(_srcChainId);\n        require(executionStateRoot != bytes32(0), \"MessageBridge: execution state root not found\");\n        require(executionStateRoot == keccak256(_accountProof[0]), \"MessageBridge: invalid account proof root\");\n\n        // get storageRoot\n        bytes memory accountInfo = MerkleProofTree.read(remoteMessageBridgeHashes[_srcChainId], _accountProof);\n        RLPReader.RLPItem[] memory items = accountInfo.toRlpItem().toList();\n        require(items.length == 4, \"MessageBridge: invalid account decoded from RLP\");\n        return bytes32(items[2].toUint());\n    }\n\n    function _handleExecutionRevert(\n        bytes32 messageId,\n        uint256 _gasLeftBeforeExecution,\n        bytes memory _returnData\n    ) private {\n        uint256 gasLeftAfterExecution = gasleft();\n        uint256 maxTargetGasLimit = block.gaslimit - preExecuteMessageGasUsage;\n        if (_gasLeftBeforeExecution < maxTargetGasLimit && gasLeftAfterExecution <= _gasLeftBeforeExecution / 64) {\n            // if this happens, the execution must have not provided sufficient gas limit,\n            // then the tx should revert instead of recording a non-retryable failure status\n            // https://github.com/wolflo/evm-opcodes/blob/main/gas.md#aa-f-gas-to-send-with-call-operations\n            assembly {\n                invalid()\n            }\n        }\n        string memory revertMsg = MsgLib.checkRevertMsg(_returnData);\n        // otherwiase, emit revert message, return and mark the execution as failed (non-retryable)\n        emit MessageCallReverted(messageId, revertMsg);\n    }\n}\n"
    },
    "contracts/message-bridge/mock/MockMerkleProofTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../libraries/MerkleProofTree.sol\";\n\ncontract MockMerkleProofTree {\n    function mockRead(bytes32 key, bytes[] memory proof) external pure returns (bytes memory result) {\n        return MerkleProofTree.read(key, proof);\n    }\n}\n"
    },
    "contracts/message-bridge/mock/MockMessageBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../MessageBridge.sol\";\nimport \"../../interfaces/IEthereumLightClient.sol\";\n\ncontract MockLightClient is IEthereumLightClient {\n    uint64 public latestSlot; // slot of latest known block\n    bytes32 public stateRoot; // slot => header\n\n    function submitHeader(uint64 slot, bytes32 _stateRoot) external {\n        latestSlot = slot;\n        stateRoot = _stateRoot;\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, latestSlot);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, latestSlot);\n    }\n}\n\ncontract MockMessageBridge {\n    MessageBridge public messageBridge;\n    MockLightClient public lightClient;\n\n    function initialize(\n        uint64 slot,\n        address _messageBridgeAddress,\n        address _mockLightClient,\n        bytes32 _mockStateRoot\n    ) public {\n        messageBridge = MessageBridge(_messageBridgeAddress);\n        lightClient = MockLightClient(_mockLightClient);\n        lightClient.submitHeader(slot, _mockStateRoot);\n    }\n\n    function testExecutedMessage(\n        uint64 _srcChainId,\n        uint64 _nonce,\n        address _sender,\n        address _receiver,\n        bytes calldata _message,\n        bytes[] calldata accountProof,\n        bytes[] calldata storageProof\n    ) external returns (bool success) {\n        return\n            messageBridge.executeMessage(_srcChainId, _nonce, _sender, _receiver, _message, accountProof, storageProof);\n    }\n}\n"
    },
    "contracts/poa/libraries/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// OpenZeppelin Contracts (v3.4.2-solc-0.7) (cryptography/ECDSA.sol)\n// Diff:\n// * Fixed: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\n// * Add `toTypedDataHash(bytes32, bytes32)` function\n\npragma solidity 0.8.18;\n\n/// @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n///\n/// These functions can be used to verify that a message was signed by the holder\n/// of the private keys of a given address.\nlibrary ECDSA {\n    /// @dev Returns the address that signed a hashed message (`hash`) with\n    /// `signature`. This address can then be used for verification purposes.\n    ///\n    /// The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n    /// this function rejects them by requiring the `s` value to be in the lower\n    /// half order, and the `v` value to be either 27 or 28.\n    ///\n    /// IMPORTANT: `hash` _must_ be the result of a hash operation for the\n    /// verification to be secure: it is possible to craft signatures that\n    /// recover to arbitrary addresses for non-hashed data. A safe way to ensure\n    /// this is by receiving a hash of the original message (which may otherwise\n    /// be too long), and then calling {toEthSignedMessageHash} on it.\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        return recover(hash, v, r, s);\n    }\n\n    /// @dev Returns the address that signed a hashed message (`hash`) with\n    /// `signature`. This address can then be used for verification purposes.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        // Check the signature length\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098)\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n\n        return recover(hash, v, r, s);\n    }\n\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ECDSA: invalid signature 's' value\"\n        );\n        if (v == 0 || v == 1) {\n            v += 27;\n        }\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`. This\n    /// replicates the behavior of the\n    /// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n    /// JSON-RPC method.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /// @dev Returns an Ethereum Signed Typed Data, created from a\n    /// `domainSeparator` and a `structHash`. This produces hash corresponding\n    /// to the one signed with the\n    /// https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n    /// JSON-RPC method as part of EIP-712.\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/poa/libraries/Memory.sol": {
      "content": "pragma solidity 0.8.18;\n\nlibrary Memory {\n    /**\n     * Copies a part of bytes.\n     * @param source original bytes\n     * @param from the first index to be copied, data included\n     * @param to the last index(to be copied) + 1, data excluded.\n     */\n    function range(bytes memory source, uint256 from, uint256 to) internal pure returns (bytes memory) {\n        if (from >= to) {\n            return \"\";\n        }\n\n        require(from < source.length && from >= 0, \"Memory: from out of bounds\");\n        require(to <= source.length && to >= 0, \"Memory: to out of bounds\");\n\n        bytes memory result = new bytes(to - from);\n\n        uint256 srcPtr;\n        assembly {\n            srcPtr := add(source, 0x20)\n        }\n\n        srcPtr += from;\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(result, 0x20)\n        }\n\n        copy(destPtr, srcPtr, to - from);\n\n        return result;\n    }\n\n    /**\n     * Copies a piece of memory to another location\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol\n     * @param _destPtr Destination location pointer\n     * @param _srcPtr Source location pointer\n     * @param _length Length of memory(in bytes) to be copied.\n     */\n    function copy(uint256 _destPtr, uint256 _srcPtr, uint256 _length) internal pure {\n        uint256 destPtr = _destPtr;\n        uint256 srcPtr = _srcPtr;\n        uint256 remainingLength = _length;\n\n        for (; remainingLength >= 32; remainingLength -= 32) {\n            assembly {\n                mstore(destPtr, mload(srcPtr))\n            }\n            destPtr += 32;\n            srcPtr += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256 ** (32 - remainingLength) - 1;\n        }\n\n        assembly {\n            let srcPart := and(mload(srcPtr), not(mask))\n            let destPart := and(mload(destPtr), mask)\n            mstore(destPtr, or(destPart, srcPart))\n        }\n    }\n}\n"
    },
    "contracts/poa/libraries/RLPWriter.sol": {
      "content": "// Inspired: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/rlp/Lib_RLPWriter.sol\n\npragma solidity 0.8.18;\n\nimport \"./Memory.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary RLPWriter {\n    /**\n     * RLP encodes bool\n     * @param _input The bool value to be encoded\n     * @return RLP encoded bool value in bytes\n     */\n    function writeBool(bool _input) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_input ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * RLP encodes bytes\n     * @param _input The byte string to be encoded\n     * @return RLP encoded string in bytes\n     */\n    function writeBytes(bytes memory _input) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        // input ∈ [0x00, 0x7f]\n        if (_input.length == 1 && uint8(_input[0]) < 128) {\n            encoded = _input;\n        } else {\n            // Offset 0x80\n            encoded = abi.encodePacked(_writeLength(_input.length, 128), _input);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded items\n     * @param _input The list of RLP encoded items\n     * @return RLP encoded list of items in bytes\n     */\n    function writeList(bytes[] memory _input) internal pure returns (bytes memory) {\n        bytes memory flatten = _flatten(_input);\n        // offset 0xc0\n        return abi.encodePacked(_writeLength(flatten.length, 192), flatten);\n    }\n\n    /**\n     * RLP encodes a string\n     * @param _input The string to be encoded\n     * @return RLP encoded string in bytes\n     */\n    function writeString(string memory _input) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_input));\n    }\n\n    /**\n     * RLP encodes an address\n     * @param _input The address to be encoded\n     * @return RLP encoded address in bytes\n     */\n    function writeAddress(address _input) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_input));\n    }\n\n    /**\n     * RLP encodes a uint256 value\n     * @param _input The uint256 to be encoded\n     * @return RLP encoded uint256 in bytes\n     */\n    function writeUint(uint256 _input) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_input));\n    }\n\n    /**\n     * Encode offset + length as first byte, followed by length in hex display if needed\n     * _offset: 0x80 for single item, 0xc0/192 for list\n     * If length is greater than 55, offset should add 55. 0xb7 for single item, 0xf7 for list\n     * @param _length The length of single item or list\n     * @param _offset Type indicator\n     * @return RLP encoded bytes\n     */\n    function _writeLength(uint256 _length, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_length < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_offset) + uint8(_length));\n        } else {\n            uint256 hexLengthForInputLength = 0;\n            uint256 index = 1;\n            while (_length / index != 0) {\n                index *= 256;\n                hexLengthForInputLength++;\n            }\n            encoded = new bytes(hexLengthForInputLength + 1);\n\n            // 0x80 + 55 = 0xb7\n            // 0xc0 + 55 = 0xf7\n            encoded[0] = bytes1(uint8(_offset) + 55 + uint8(hexLengthForInputLength));\n            for (index = 1; index <= hexLengthForInputLength; index++) {\n                encoded[index] = bytes1(uint8((_length / (256 ** (hexLengthForInputLength - index))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    function toBinary(uint256 _input) internal pure returns (bytes memory) {\n        return _toBinary(_input);\n    }\n\n    /**\n     * Encode integer into big endian without leading zeros\n     * @param _input The integer to be encoded\n     * @return RLP encoded bytes\n     */\n    function _toBinary(uint256 _input) private pure returns (bytes memory) {\n        // if input value is 0, return 0x00\n        if (_input == 0) {\n            bytes memory zeroResult = new bytes(1);\n            zeroResult[0] = 0;\n            return zeroResult;\n        }\n\n        bytes memory data = abi.encodePacked(_input);\n\n        uint8 index = 0;\n        for (; index < 32; ) {\n            if (data[index] != 0) {\n                break;\n            }\n\n            unchecked {\n                ++index;\n            }\n        }\n\n        bytes memory result = new bytes(32 - index);\n        uint256 resultPtr;\n        assembly {\n            resultPtr := add(result, 0x20)\n        }\n\n        uint256 dataPtr;\n        assembly {\n            dataPtr := add(data, 0x20)\n        }\n\n        Memory.copy(resultPtr, dataPtr + index, 32 - index);\n\n        return result;\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 length = 0;\n        uint256 index = 0;\n\n        for (; index < _list.length; ) {\n            length += _list[index].length;\n            unchecked {\n                ++index;\n            }\n        }\n\n        bytes memory flattened = new bytes(length);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (index = 0; index < _list.length; ) {\n            bytes memory item = _list[index];\n            uint256 itemPtr;\n            assembly {\n                itemPtr := add(item, 0x20)\n            }\n\n            Memory.copy(flattenedPtr, itemPtr, item.length);\n            flattenedPtr += _list[index].length;\n\n            unchecked {\n                ++index;\n            }\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/poa/PoALightClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../bsc-tendermint/interfaces/IBSCValidatorSet.sol\";\nimport \"../interfaces/IEthereumLightClient.sol\";\n\nimport \"./libraries/ECDSA.sol\";\nimport \"./libraries/Memory.sol\";\nimport \"./libraries/RLPWriter.sol\";\n\n// Sample header\n// curl --location --request POST 'https://bsc.getblock.io/API_KEY/testnet/'\n//  -H \"Content-Type: application/json\"\n//  --data-raw '{\"jsonrpc\": \"2.0\", \"method\": \"eth_getBlockByNumber\", \"params\": [\"0x68B3\", true], \"id\": \"getblock.io\"}'\n// {\n// \"difficulty\":\"0x2\",\n// \"extraData\":\"0xd983010000846765746889676f312e31322e3137856c696e7578000000000000c3daa60d95817e2789de3eafd44dc354fe804bf5f08059cde7c86bc1215941d022bf9609ca1dee2881baf2144aa93fc80082e6edd0b9f8eac16f327e7d59f16500\",\n// \"gasLimit\":\"0x1c9c380\",\n// \"gasUsed\":\"0x0\",\n// \"hash\":\"0xc3fa2927a8e5b7cfbd575188a30c34994d3356607deb4c10d7fefe0dd5cdcc83\",\n// \"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n// \"miner\":\"0x35552c16704d214347f29fa77f77da6d75d7c752\",\n// \"mixHash\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n// \"nonce\":\"0x0000000000000000\",\n// \"number\":\"0x68b3\",\n// \"parentHash\":\"0xbf4d16769b8fd946394957049eef29ed938da92454762fc6ac65e0364ea004c7\",\n// \"receiptsRoot\":\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\",\n// \"sha3Uncles\":\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\",\n// \"size\":\"0x261\",\n// \"stateRoot\":\"0x7b5a72075082c31ec909afe5c5df032b6e7f19c686a9a408a2cb6b75dec072a3\",\n// \"timestamp\":\"0x5f080818\",\n// \"totalDifficulty\":\"0xd167\",\n// \"transactions\":[],\n// \"transactionsRoot\":\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\",\n// \"uncles\":[]\n// }\n\ncontract PoALightClient is IEthereumLightClient {\n    using Memory for bytes;\n\n    struct BNBHeaderInfo {\n        bytes32 parentHash;\n        bytes32 sha3Uncles;\n        address miner;\n        bytes32 stateRoot;\n        bytes32 transactionsRoot;\n        bytes32 receiptsRoot;\n        bytes logsBloom;\n        uint256 difficulty;\n        uint256 number;\n        uint64 gasLimit;\n        uint64 gasUsed;\n        uint64 timestamp;\n        bytes extraData;\n        bytes32 mixHash;\n        bytes8 nonce;\n    }\n\n    IBSCValidatorSet public bscValidatorSet;\n\n    uint64 number;\n    bytes32 stateRoot;\n\n    constructor(address _bscValidatorSet) {\n        bscValidatorSet = IBSCValidatorSet(_bscValidatorSet);\n        number = 0;\n        stateRoot = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n    }\n\n    // Fixed number of extra-data prefix bytes reserved for signer vanity.\n    // https://eips.ethereum.org/EIPS/eip-225\n    uint256 private constant EXTRA_VANITY_LENGTH = 32;\n\n    // Length of signer's signature\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    uint64 private constant CHAIN_ID = 97;\n\n    function updateHeader(BNBHeaderInfo calldata header) external {\n        require(header.number > number, \"PoALightClient: invalid block number\");\n\n        address signer = _retrieveSignerInfo(header);\n        require(bscValidatorSet.isCurrentValidator(signer), \"PoALightClient: invalid signer address\");\n\n        number = uint64(header.number);\n        stateRoot = header.stateRoot;\n    }\n\n    function _retrieveSignerInfo(BNBHeaderInfo calldata header) internal pure returns (address signer) {\n        bytes memory extraData = header.extraData;\n\n        require(extraData.length > EXTRA_VANITY_LENGTH, \"PoALightClient: invalid extra data for vanity\");\n        require(\n            extraData.length >= EXTRA_VANITY_LENGTH + SIGNATURE_LENGTH,\n            \"PoALightClient: invalid extra data for signature\"\n        );\n\n        // data: [0, extraData.length - SIGNATURE_LENGTH)\n        // signature: [extraData.length - SIGNATURE_LENGTH, extraData.length)\n        bytes memory extraDataWithoutSignature = Memory.range(extraData, 0, extraData.length - SIGNATURE_LENGTH);\n        bytes memory signature = Memory.range(extraData, extraData.length - SIGNATURE_LENGTH, extraData.length);\n\n        require(signature.length == SIGNATURE_LENGTH, \"PoALightClient: signature retrieval failed\");\n        BNBHeaderInfo memory unsignedHeader = BNBHeaderInfo({\n            difficulty: header.difficulty,\n            extraData: extraDataWithoutSignature,\n            gasLimit: header.gasLimit,\n            gasUsed: header.gasUsed,\n            logsBloom: header.logsBloom,\n            miner: header.miner,\n            mixHash: header.mixHash,\n            nonce: header.nonce,\n            number: header.number,\n            parentHash: header.parentHash,\n            receiptsRoot: header.receiptsRoot,\n            sha3Uncles: header.sha3Uncles,\n            stateRoot: header.stateRoot,\n            timestamp: header.timestamp,\n            transactionsRoot: header.transactionsRoot\n        });\n\n        bytes32 message = _hashHeaderWithChainId(unsignedHeader, CHAIN_ID);\n\n        return ECDSA.recover(message, signature);\n    }\n\n    function _hashHeaderWithChainId(BNBHeaderInfo memory header, uint64 chainId) internal pure returns (bytes32) {\n        bytes[] memory list = new bytes[](16);\n\n        list[0] = RLPWriter.writeUint(chainId);\n        list[1] = RLPWriter.writeBytes(abi.encodePacked(header.parentHash));\n        list[2] = RLPWriter.writeBytes(abi.encodePacked(header.sha3Uncles));\n        list[3] = RLPWriter.writeAddress(header.miner);\n        list[4] = RLPWriter.writeBytes(abi.encodePacked(header.stateRoot));\n        list[5] = RLPWriter.writeBytes(abi.encodePacked(header.transactionsRoot));\n        list[6] = RLPWriter.writeBytes(abi.encodePacked(header.receiptsRoot));\n        list[7] = RLPWriter.writeBytes(header.logsBloom);\n        list[8] = RLPWriter.writeUint(header.difficulty);\n        list[9] = RLPWriter.writeUint(header.number);\n        list[10] = RLPWriter.writeUint(header.gasLimit);\n        list[11] = RLPWriter.writeUint(header.gasUsed);\n        list[12] = RLPWriter.writeUint(header.timestamp);\n        list[13] = RLPWriter.writeBytes(header.extraData);\n        list[14] = RLPWriter.writeBytes(abi.encodePacked(header.mixHash));\n        list[15] = RLPWriter.writeBytes(abi.encodePacked(header.nonce));\n\n        return keccak256(RLPWriter.writeList(list));\n    }\n\n    function finalizedExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, number);\n    }\n\n    function optimisticExecutionStateRootAndSlot() external view returns (bytes32 root, uint64 slot) {\n        return (stateRoot, number);\n    }\n}\n"
    },
    "contracts/poa/test/MockPOALightClient.sol": {
      "content": "pragma solidity 0.8.18;\n\nimport \"../../bsc-tendermint/interfaces/IBSCValidatorSet.sol\";\n\ncontract MockTendermintLightClient is IBSCValidatorSet {\n    address public signerAddress;\n\n    function updateSigner(address _newSigner) external {\n        signerAddress = _newSigner;\n    }\n\n    constructor(address _signer) {\n        signerAddress = _signer;\n    }\n\n    function isCurrentValidator(address _signer) external view returns (bool valid) {\n        return signerAddress == _signer;\n    }\n}\n"
    },
    "contracts/poa/test/PoALibTest.sol": {
      "content": "pragma solidity 0.8.18;\n\nimport \"../libraries/RLPWriter.sol\";\nimport \"../libraries/Memory.sol\";\nimport \"../libraries/ECDSA.sol\";\n\ncontract PoALibTest {\n    function mockRange(bytes memory source, uint256 from, uint256 to) public pure returns (bytes memory) {\n        return Memory.range(source, from, to);\n    }\n\n    function mockCopy(bytes memory _source, uint256 _length) public pure returns (bytes memory) {\n        bytes memory dest = new bytes(_length);\n        uint256 destPtr;\n        assembly {\n            destPtr := add(dest, 0x20)\n        }\n\n        uint256 srcPtr;\n        assembly {\n            srcPtr := add(_source, 0x20)\n        }\n\n        Memory.copy(destPtr, srcPtr, _length);\n        return dest;\n    }\n\n    function mockWriteUint(uint256 _input) public pure returns (bytes memory) {\n        return RLPWriter.writeUint(_input);\n    }\n\n    function mockWriteAddress(address _input) public pure returns (bytes memory) {\n        return RLPWriter.writeAddress(_input);\n    }\n\n    function mockWriteRLPList(bytes[] memory _input) public pure returns (bytes memory) {\n        return RLPWriter.writeList(_input);\n    }\n\n    function mockWriteBool(bool _input) public pure returns (bytes memory) {\n        return RLPWriter.writeBool(_input);\n    }\n\n    function mockWriteString(string calldata _input) public pure returns (bytes memory) {\n        return RLPWriter.writeString(_input);\n    }\n\n    function mockWriteBytes(bytes memory _input) public pure returns (bytes memory) {\n        return RLPWriter.writeBytes(_input);\n    }\n\n    function mockToBinary(uint256 _input) public pure returns (bytes memory) {\n        return RLPWriter.toBinary(_input);\n    }\n\n    function mockUint256MaxToBinary() public pure returns (bytes memory) {\n        return RLPWriter.toBinary(115792089237316195423570985008687907853269984665640564039457584007913129639935);\n    }\n\n    function mockRecoverAddress(bytes32 message, bytes memory signature) public pure returns (address) {\n        bytes32 h = ECDSA.toEthSignedMessageHash(message);\n        return ECDSA.recover(h, signature);\n    }\n}\n"
    },
    "contracts/test-helper/MockAnchorBlocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../light-client/interfaces/IAnchorBlocks.sol\";\n\ncontract MockAnchorBlocks is IAnchorBlocks {\n    mapping(uint256 => bytes32) public blocks;\n    function update(uint256 blockNum, bytes32 blockHash) external {\n        blocks[blockNum] = blockHash;\n    }\n}"
    },
    "contracts/test-helper/MockBlockSyncer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../chunk-sync/interfaces/IBlockChunks.sol\";\n\ncontract MockBlockChunks is IBlockChunks {\n    function isBlockHashValid(BlockHashWitness calldata) external pure returns (bool) {\n        return true;\n    }\n\n    function historicalRoots(uint64 chainId, uint32 startBlockNumber) external view returns (bytes32) {\n        // nothing to do\n    }\n\n    function updateRecent(uint64 chainId, bytes calldata proofData) external {\n        // nothing to do\n    }\n\n    function updateOld(uint64 chainId, bytes32 nextRoot, uint32 nextNumFinal, bytes calldata proofData) external {\n        // nothing to do\n    }\n}\n"
    },
    "contracts/test-helper/MockZkVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"../verifiers/interfaces/IZkpVerifier.sol\";\n\ncontract MockZkVerifier is IZkpVerifier {\n    function verifyRaw(bytes calldata) external pure returns (bool r) {\n        return true;\n    }\n}\n"
    },
    "contracts/verifiers/BeaconVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"./zk-verifiers/BlsSigVerifier.sol\";\nimport \"./zk-verifiers/CommitteeRootMappingVerifier.sol\";\nimport \"./interfaces/IBeaconVerifier.sol\";\n\ncontract BeaconVerifier is IBeaconVerifier, BlsSigVerifier, CommitteeRootMappingVerifier {\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        uint256 commitment,\n        Proof memory p\n    ) public view returns (bool) {\n        uint256[35] memory input;\n        uint256 root = uint256(signingRoot);\n        // slice the signing root into 32 individual bytes and assign them in order to the first 32 slots of input[]\n        for (uint256 i = 0; i < 32; i++) {\n            input[(32 - 1 - i)] = root % 256;\n            root = root / 256;\n        }\n        input[32] = participation;\n        input[33] = uint256(syncCommitteePoseidonRoot);\n        input[34] = commitment;\n        return verifyBlsSigProof(p.a, p.b, p.c, p.commitment, input);\n    }\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) public view returns (bool) {\n        uint256[33] memory input;\n        uint256 root = uint256(sszRoot);\n        for (uint256 i = 0; i < 32; i++) {\n            input[(32 - 1 - i)] = root % 256;\n            root = root / 256;\n        }\n        input[32] = uint256(poseidonRoot);\n        return verifyCommitteeRootMappingProof(p.a, p.b, p.c, input);\n    }\n}\n"
    },
    "contracts/verifiers/interfaces/IBeaconVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface IBeaconVerifier {\n    struct Proof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[2] commitment;\n    }\n\n    function verifySignatureProof(\n        bytes32 signingRoot,\n        bytes32 syncCommitteePoseidonRoot,\n        uint256 participation,\n        uint256 commitment,\n        Proof memory p\n    ) external view returns (bool);\n\n    function verifySyncCommitteeRootMappingProof(\n        bytes32 sszRoot,\n        bytes32 poseidonRoot,\n        Proof memory p\n    ) external view returns (bool);\n}\n"
    },
    "contracts/verifiers/interfaces/ITxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface ITxVerifier {\n    struct TxInfo {\n        uint64 chainId;\n        uint64 nonce;\n        uint256 gasTipCap;\n        uint256 gasFeeCap;\n        uint256 gas;\n        address to;\n        uint256 value;\n        bytes data;\n        address from; // calculate from V R S\n        uint32 blkNum;\n        bytes32 blkHash;\n        uint64 blkTime;\n    }\n\n    // reverts if not verified\n    // - txRaw: signed dynamic fee tx rlp encode data\n    // - proofData: tx proof data\n    // - auxiBlkVerifyInfo: auxiliary info for blk verify in chunk sync contract\n    function verifyTx(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external returns (TxInfo memory txInfo);\n}\n"
    },
    "contracts/verifiers/interfaces/IZkpVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\ninterface IZkpVerifier {\n    function verifyRaw(bytes calldata proofData) external view returns (bool r);\n}\n"
    },
    "contracts/verifiers/TxVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"solidity-rlp/contracts/RLPReader.sol\";\nimport \"./interfaces/ITxVerifier.sol\";\nimport \"./interfaces/IZkpVerifier.sol\";\nimport \"../chunk-sync/interfaces/IBlockChunks.sol\";\n\n// retrieved from proofData, to align the fields with circuit...\nstruct ProofData {\n    bytes32 txHash;\n    bytes32 blkHash;\n    uint32 blkNum;\n    uint64 blkTime;\n}\n\n// mapping(bytes32 => StoredProovedContent) public proofs; // txhash => StoredProovedContent\nstruct StoredProovedContent {\n    uint64 chainId;\n    bytes32 blkHash;\n    uint32 blkNum;\n    uint256 blkTime;\n}\n\nuint32 constant PUBLIC_BYTES_START_IDX = 10 * 32; // the first 10 32bytes are groth16 proof (A/B/C/Commitment)\n\ncontract TxVerifier is ITxVerifier, Ownable {\n    using RLPReader for bytes;\n    using RLPReader for uint;\n    using RLPReader for RLPReader.RLPItem;\n\n    mapping(uint64 => address) public verifierAddresses; // chainid => snark verifier contract address\n    address public BlockChunks;\n\n    constructor(address _BlockChunks) {\n        BlockChunks = _BlockChunks;\n    }\n\n    event UpdateVerifierAddress(uint64 chainId, address newAddress);\n    event UpdateBlockChunks(address newAddress);\n\n    function updateVerifierAddress(uint64 _chainId, address _verifierAddress) external onlyOwner {\n        verifierAddresses[_chainId] = _verifierAddress;\n        emit UpdateVerifierAddress(_chainId, _verifierAddress);\n    }\n\n    function updateBlockChunks(address _BlockChunks) external onlyOwner {\n        BlockChunks = _BlockChunks;\n        emit UpdateBlockChunks(_BlockChunks);\n    }\n\n    function verifyTx(\n        bytes calldata txRaw,\n        bytes calldata proofData,\n        bytes calldata auxiBlkVerifyInfo\n    ) external view returns (TxInfo memory info) {\n        info = decodeTx(txRaw);\n        require(verifyRaw(info.chainId, proofData), \"proof not valid\");\n        bytes32 txHash = keccak256(txRaw);\n        ProofData memory data = getProofData(proofData);\n        require(txHash == data.txHash, \"txHash not match\");\n\n        (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) = getFromAuxiBlkVerifyInfo(\n            auxiBlkVerifyInfo\n        );\n\n        IBlockChunks.BlockHashWitness memory witness = IBlockChunks.BlockHashWitness({\n            chainId: info.chainId,\n            blkNum: data.blkNum,\n            claimedBlkHash: data.blkHash,\n            prevHash: prevHash,\n            numFinal: numFinal,\n            merkleProof: merkleProof\n        });\n        require(IBlockChunks(BlockChunks).isBlockHashValid(witness), \"invalid blkHash\");\n\n        info.blkHash = data.blkHash;\n        info.blkTime = data.blkTime;\n        info.blkNum = data.blkNum;\n    }\n\n    function getFromAuxiBlkVerifyInfo(\n        bytes calldata auxiBlkVerifyInfo\n    ) internal pure returns (bytes32 prevHash, uint32 numFinal, bytes32[7] memory merkleProof) {\n        require(auxiBlkVerifyInfo.length == 8 * 32 + 4, \"incorrect auxiBlkVerifyInfo\");\n\n        prevHash = bytes32(auxiBlkVerifyInfo[:32]);\n        numFinal = uint32(bytes4(auxiBlkVerifyInfo[32:36]));\n        for (uint8 idx = 0; idx < 6; idx++) {\n            merkleProof[idx] = bytes32(auxiBlkVerifyInfo[36 + 32 * idx:36 + 32 * (idx + 1)]);\n        }\n        merkleProof[6] = bytes32(auxiBlkVerifyInfo[36 + 32 * 6:36 + 32 * (6 + 1)]);\n    }\n\n    // support DynamicFeeTxType for now\n    function decodeTx(bytes calldata txRaw) public pure returns (TxInfo memory info) {\n        uint8 txType = uint8(txRaw[0]);\n        require(txType == 2, \"not a DynamicFeeTxType\");\n\n        bytes memory rlpData = txRaw[1:];\n        RLPReader.RLPItem[] memory values = rlpData.toRlpItem().toList();\n        info.chainId = uint64(values[0].toUint());\n        info.nonce = uint64(values[1].toUint());\n        info.gasTipCap = values[2].toUint();\n        info.gasFeeCap = values[3].toUint();\n        info.gas = values[4].toUint();\n        info.to = values[5].toAddress();\n        info.value = values[6].toUint();\n        info.data = values[7].toBytes();\n\n        (uint8 v, bytes32 r, bytes32 s) = (\n            uint8(values[9].toUint()),\n            bytes32(values[10].toBytes()),\n            bytes32(values[11].toBytes())\n        );\n        // remove r,s,v and adjust length field\n        bytes memory unsignedTxRaw;\n        uint8 unsignedTxRawDataLength = uint8(txRaw[2]) - 67;\n        if (unsignedTxRawDataLength <= 55) {\n            unsignedTxRaw = abi.encodePacked(txRaw[:2], txRaw[3:txRaw.length - 67]);\n            unsignedTxRaw[1] = bytes1(192 + unsignedTxRawDataLength);\n        } else {\n            unsignedTxRaw = txRaw[:txRaw.length - 67];\n            unsignedTxRaw[2] = bytes1(unsignedTxRawDataLength);\n        }\n        info.from = recover(keccak256(unsignedTxRaw), r, s, v);\n    }\n\n    function recover(bytes32 message, bytes32 r, bytes32 s, uint8 v) internal pure returns (address) {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, message));\n        if (v < 27) {\n            v += 27;\n        }\n        return ecrecover(prefixedHash, v, r, s);\n    }\n\n    function verifyRaw(uint64 chainId, bytes calldata proofData) private view returns (bool) {\n        require(verifierAddresses[chainId] != address(0), \"chain verifier not set\");\n        return (IZkpVerifier)(verifierAddresses[chainId]).verifyRaw(proofData);\n    }\n\n    function getProofData(bytes calldata proofData) internal pure returns (ProofData memory data) {\n        data.txHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX:PUBLIC_BYTES_START_IDX + 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 32 + 16:PUBLIC_BYTES_START_IDX + 2 * 32]))\n        );\n        data.blkHash = bytes32(\n            (uint256(bytes32(proofData[PUBLIC_BYTES_START_IDX + 2 * 32:PUBLIC_BYTES_START_IDX + 3 * 32])) << 128) |\n                uint128(bytes16(proofData[PUBLIC_BYTES_START_IDX + 3 * 32 + 16:PUBLIC_BYTES_START_IDX + 4 * 32]))\n        );\n        data.blkNum = uint32(bytes4(proofData[PUBLIC_BYTES_START_IDX + 5 * 32 - 4:PUBLIC_BYTES_START_IDX + 5 * 32]));\n        data.blkTime = uint64(bytes8(proofData[PUBLIC_BYTES_START_IDX + 6 * 32 - 8:PUBLIC_BYTES_START_IDX + 6 * 32]));\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/BlsSigVerifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"./common/Pairing.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Common.sol\";\n\ncontract BlsSigVerifier {\n    using Pairing for *;\n\n    function verifyingKey() internal pure returns (Common.VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(21869404648590355938070204738007299921184879677994422527706836467860465229555),\n            uint256(13498271808119839955057715147407595718888788089303053071109523938531313129416)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(7054962807852101821777521907353900534536574912206623342548135225636684065633),\n                uint256(4719416372386397569789716378331929165562736304329438825528404248445356317544)\n            ],\n            [\n                uint256(13169505134780753056527210184700054053183554009975495323937739848223108944491),\n                uint256(13592098286878802627104334887812977484641971308142750321766707760557234071693)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(11095415866555931179835746321035950972580128700079993342944687987088771893970),\n                uint256(7608157602633458693059833022944239778069565713137388978977277542137468568611)\n            ],\n            [\n                uint256(7401180895810745229430756020474788835440387402515164454484661092797156083108),\n                uint256(5065358031358114712449190279086624673751222971320486961839316362446988673960)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(2222475616788908183739316851660307727267648260775064003405822118215303226516),\n                uint256(6757963293650080478631547193181808365039329301693745170213066300772412893432)\n            ],\n            [\n                uint256(16109832433313432721291101899523165130162303404627529133543410010343809968099),\n                uint256(10657128623625091271138067059727783952095522932162725865057316893805238179881)\n            ]\n        );\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyBlsSigProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[35] memory input\n    ) public view returns (bool r) {\n        Common.Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        Common.VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(6164202379403353093337803285728957014471789019875115975131401894724388184318); // vk.K[0].X\n        vk_x.Y = uint256(14653739865386807698202111307501669964169649892515646451656712652300441924746); // vk.K[0].Y\n        mul_input[0] = uint256(21624815114078889503955414395662096302081445496963466787344578976263660902728); // vk.K[1].X\n        mul_input[1] = uint256(11975795059976038387412140269866198306105499844184502711829412068023274602635); // vk.K[1].Y\n        mul_input[2] = input[0];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(9775291361201569299414467699407168277620212957980866255045879806029778744670); // vk.K[2].X\n        mul_input[1] = uint256(17233924503171010558175232794027883068335710383496735149565234989213088796768); // vk.K[2].Y\n        mul_input[2] = input[1];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(8261354145794168978236113350349424817333204461878829563010649753110739562635); // vk.K[3].X\n        mul_input[1] = uint256(228648003771409636961945287326030341918541270047335109757141629333782275554); // vk.K[3].Y\n        mul_input[2] = input[2];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(17152002075022784984752660010686481854578129701150390242442680875098241592838); // vk.K[4].X\n        mul_input[1] = uint256(11918344010421497075133630718996356084858247140809583870914170975825762239902); // vk.K[4].Y\n        mul_input[2] = input[3];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(6724640989773315527339379483030265695332390420189583344806142015699008773038); // vk.K[5].X\n        mul_input[1] = uint256(861669679975036023917296038423011939661116903611653803520085082890905199789); // vk.K[5].Y\n        mul_input[2] = input[4];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(14251387140848206404864695272174413529185588726241264808479413090259577951538); // vk.K[6].X\n        mul_input[1] = uint256(4877123074037160235642133175015361159040197060194606461929469075209090452909); // vk.K[6].Y\n        mul_input[2] = input[5];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(20478957346453652200579299273452777262775946284794283970558676720582194409443); // vk.K[7].X\n        mul_input[1] = uint256(13820772652701693231224118191632029591356297457861304887694791784009996804692); // vk.K[7].Y\n        mul_input[2] = input[6];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(9234465648938974703786224967061256507261169398685469391550057760202443899331); // vk.K[8].X\n        mul_input[1] = uint256(13214614408686260510380993851179383149022140264065385584700637692530775154803); // vk.K[8].Y\n        mul_input[2] = input[7];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(8322398570000964255587165898643030029017010777972305270331988207302834192671); // vk.K[9].X\n        mul_input[1] = uint256(2792163176420440857016104913456882943905817335378546111765666996712066935576); // vk.K[9].Y\n        mul_input[2] = input[8];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(15797084070376204854261757656819325712271250278301568410976291761898112633721); // vk.K[10].X\n        mul_input[1] = uint256(16921845299282876706614570130523339313885521170603933721890067977426560293948); // vk.K[10].Y\n        mul_input[2] = input[9];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(406216972217762516055114890594086577323982284148453070046117814489609787072); // vk.K[11].X\n        mul_input[1] = uint256(19680277307775257363705979553150354779381952871529724380294836363819544498123); // vk.K[11].Y\n        mul_input[2] = input[10];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(12525306314981123491352345009709438907206215415831226491632499998999204127459); // vk.K[12].X\n        mul_input[1] = uint256(1658709794415567495634480941878933577381576154054415708255836274811180964933); // vk.K[12].Y\n        mul_input[2] = input[11];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(243194178389731910341565843545971823670153019065524768068260919793967722188); // vk.K[13].X\n        mul_input[1] = uint256(1539016065323199244386584217201350236710807235938447628544504644138676080000); // vk.K[13].Y\n        mul_input[2] = input[12];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(9275972589095639516678595044389709393960973430061520882565539743422692685960); // vk.K[14].X\n        mul_input[1] = uint256(4472610206252234523359317365636135395350815197903460649733786399406367486575); // vk.K[14].Y\n        mul_input[2] = input[13];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(1604039017774374075569025682010500744317749653925017699242881946260024023542); // vk.K[15].X\n        mul_input[1] = uint256(9410905005395438689346852685696727671986553838639094357993770247718588779274); // vk.K[15].Y\n        mul_input[2] = input[14];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(5467079506302237253715880360217400787071012184171130827989740479628417662627); // vk.K[16].X\n        mul_input[1] = uint256(5224193576447153852009901997143890474156655585587640006673196987947931700778); // vk.K[16].Y\n        mul_input[2] = input[15];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(9387444906146485207075936664808214655500107570142417551032840004938425984101); // vk.K[17].X\n        mul_input[1] = uint256(590813342019945519768071606508477036322091281941727992935444194199808517685); // vk.K[17].Y\n        mul_input[2] = input[16];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(19041927819469860627785730717901058973852083133163312846046958804599105964228); // vk.K[18].X\n        mul_input[1] = uint256(8145703607669957376931460933689362105951308370224326599319773750727102492008); // vk.K[18].Y\n        mul_input[2] = input[17];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(14204777538249598371293791017226113964614885045747036692434310643177244084169); // vk.K[19].X\n        mul_input[1] = uint256(19991551163786857983848828955926174440512514907619539468704022616567132258153); // vk.K[19].Y\n        mul_input[2] = input[18];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(12417075001679265443105210537412885798344552810848770848740273623901433226365); // vk.K[20].X\n        mul_input[1] = uint256(15254102101044498161161923790765048216173887701468938517549705046497697348129); // vk.K[20].Y\n        mul_input[2] = input[19];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(10269550220001463320881104580554222531390353399943986353550597742767825203938); // vk.K[21].X\n        mul_input[1] = uint256(3029115017209685411907558073483483867359830128318261715424531870119465329684); // vk.K[21].Y\n        mul_input[2] = input[20];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(14428083165341078925702200873211485650187256256509974692495884984971265925464); // vk.K[22].X\n        mul_input[1] = uint256(15475503186436372842471391388091832734881597469954031845230603258731548786526); // vk.K[22].Y\n        mul_input[2] = input[21];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(21628050343072376849090277477176470142622908553816436115710816402067062636840); // vk.K[23].X\n        mul_input[1] = uint256(7029190031936503335713201259562887395453755842232447142827705567066954030015); // vk.K[23].Y\n        mul_input[2] = input[22];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(18110637118732954586253866494394595281955623057396063638731715904832753062595); // vk.K[24].X\n        mul_input[1] = uint256(10041565796468001571466611556015291077335046776933681659744217988421358102715); // vk.K[24].Y\n        mul_input[2] = input[23];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(4394594477670212487624118222291685582484342594449655582983945008137107825); // vk.K[25].X\n        mul_input[1] = uint256(12907667141942256119052629834176444916095324468551648766101314800519980891911); // vk.K[25].Y\n        mul_input[2] = input[24];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(12264813020217849970868777479799238229912660701320711442659475763187093184540); // vk.K[26].X\n        mul_input[1] = uint256(5418405552541349472839540236004659645077530645792067120765938377537697612686); // vk.K[26].Y\n        mul_input[2] = input[25];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(511205244113194326604079314682967281483973984567702129900795395158408587823); // vk.K[27].X\n        mul_input[1] = uint256(13182904816261728693468832675109011780365501025377828890958755203977021114190); // vk.K[27].Y\n        mul_input[2] = input[26];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(7745322370569289256054483431857334835907602968150216319025615839493340926445); // vk.K[28].X\n        mul_input[1] = uint256(802527185108559510753348953543835956246583756974633024055374364959752960622); // vk.K[28].Y\n        mul_input[2] = input[27];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(6443616155328954964370112634631799535966126116548305083954877582628003863726); // vk.K[29].X\n        mul_input[1] = uint256(6748022417080637760377192763249012207074862674787085243054196391894862853769); // vk.K[29].Y\n        mul_input[2] = input[28];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(4746053807226732815609107613694422909828283203346089197433464043542316944158); // vk.K[30].X\n        mul_input[1] = uint256(568459565911058268471985303141965010407745186442811181897604717750346101795); // vk.K[30].Y\n        mul_input[2] = input[29];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(6867388841298402377650181552003032287359815924707163591172560189355289362811); // vk.K[31].X\n        mul_input[1] = uint256(12681153196280456072370427543675941721359193477428355329469521843056250842522); // vk.K[31].Y\n        mul_input[2] = input[30];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(11834855045548628237299252472287217659541095251983817826749302275066363050032); // vk.K[32].X\n        mul_input[1] = uint256(10549551457031005862882545350575007326729695512101543170018470906439946899475); // vk.K[32].Y\n        mul_input[2] = input[31];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(21080571058062105169480371434944542317741872583578405624882037076932528614624); // vk.K[33].X\n        mul_input[1] = uint256(11386667982944779644843347272450639356560600194842785817671488724791644458315); // vk.K[33].Y\n        mul_input[2] = input[32];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n        mul_input[0] = uint256(8323118186735247530367920845955364944904052300793452286806441510422146880773); // vk.K[34].X\n        mul_input[1] = uint256(7046818066858629220640333055452104424201007141089175803564675939513429614352); // vk.K[34].Y\n        mul_input[2] = input[33];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[34] * input[33]\n        mul_input[0] = uint256(12620149755261046671755404694759801128385638190500539207079026239458336064522); // vk.K[35].X\n        mul_input[1] = uint256(10994846953135033560648325534438412658436366579529892185303274351838980685981); // vk.K[35].Y\n        mul_input[2] = input[34];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[35] * input[34]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/CommitteeRootMappingVerifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"./common/Pairing.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Common.sol\";\n\ncontract CommitteeRootMappingVerifier {\n    using Pairing for *;\n\n    function verifyingKey1() private pure returns (Common.VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(4625995678875839184227102343980957941553435037863367632170514069470978075482),\n            uint256(7745472346822620166365670179252096531675980956628675937691452644416704349631)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(16133906051290029359415836500687237322258320219528941728637152470582101797559),\n                uint256(9982592290591904397750372202184781412509742437847499064025507928193374812763)\n            ],\n            [\n                uint256(20447084996628162496147084243623314997274147610235538549283479856317752366847),\n                uint256(10652060452474388359080900509291122865897396777233890537481945528644944582649)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(14205774305928561884273671177098614973303096843515928049981466843882075090453),\n                uint256(6194647019556442694746623566240152360142526955447025858054760757353994166695)\n            ],\n            [\n                uint256(720177741655577944140882804072173464461234581005085937938128202222496044348),\n                uint256(15180859461535417805311870856102250988010112023636345871703449475067945282517)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(2075341858515413383107490988194322113274273165071779395977011288835607214232),\n                uint256(21779842329350845285414688998042134519611654255235365675696046856282966715158)\n            ],\n            [\n                uint256(4310903133868833376693610009744123646701594778591654462646551313203044329349),\n                uint256(8934039419334185533732134671857943150009456594043165319933471646801466475060)\n            ]\n        );\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyCommitteeRootMappingProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[33] memory input\n    ) public view returns (bool r) {\n        Common.Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        Common.VerifyingKey memory vk = verifyingKey1();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(20552480178503420105472757749758256930777503163697981232418248899738739436302); // vk.K[0].X\n        vk_x.Y = uint256(21874644052683447189335205444383300629386926406593895540736254865290692175330); // vk.K[0].Y\n        mul_input[0] = uint256(2419465434811246925970456918943785845329721675292263546063218305166868830301); // vk.K[1].X\n        mul_input[1] = uint256(224414837900933448241244127409926533084118787014653569685139207760162770563); // vk.K[1].Y\n        mul_input[2] = input[0];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(20237582094031100903111658800543003981446659818658320070287593450545147260932); // vk.K[2].X\n        mul_input[1] = uint256(9498936270692258262448475366106441134297508170417707117017418182506243810929); // vk.K[2].Y\n        mul_input[2] = input[1];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(21686431407509598771022896245105442713057757617842882639916055310118549735455); // vk.K[3].X\n        mul_input[1] = uint256(18587475580363988870337779644366478839186363821430368900189877147428300473925); // vk.K[3].Y\n        mul_input[2] = input[2];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(4190323520659374373641761976155873288531237902311450285189695279890286046705); // vk.K[4].X\n        mul_input[1] = uint256(8044837422277408304807431419004307582225876792722238390231063677200212676904); // vk.K[4].Y\n        mul_input[2] = input[3];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(2652622379392044318082038991710242104342228971779836360052332572087628421201); // vk.K[5].X\n        mul_input[1] = uint256(406860223885500452975843681654102213552218004006375181643914225581644355831); // vk.K[5].Y\n        mul_input[2] = input[4];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(6057918943482398019697118579402810827270820344972408585195554580949838772589); // vk.K[6].X\n        mul_input[1] = uint256(5060377211716517826689871487122513539243478809827924728351043431363438746264); // vk.K[6].Y\n        mul_input[2] = input[5];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(3687702938753468537462497928786246235243684882237823906440956320376037461563); // vk.K[7].X\n        mul_input[1] = uint256(1208686206265801496727901652555022795816232879429721718984614404615694111083); // vk.K[7].Y\n        mul_input[2] = input[6];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(11710614008104008246282861623202747769385618500144669344475214097509828684593); // vk.K[8].X\n        mul_input[1] = uint256(5065836875015911503963590142184023993405575153173968399414211124081308802733); // vk.K[8].Y\n        mul_input[2] = input[7];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(544404787870686540959136485911507545335221912755631162384362056307403363961); // vk.K[9].X\n        mul_input[1] = uint256(2345869893991024974950769006226913293849021455623995373213361343160988457751); // vk.K[9].Y\n        mul_input[2] = input[8];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        mul_input[0] = uint256(2209389364146280288951908471817129375141759543141552284740145921306411049406); // vk.K[10].X\n        mul_input[1] = uint256(9042259349973012497614444570261244747029883119587798835387806797437998198439); // vk.K[10].Y\n        mul_input[2] = input[9];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[10] * input[9]\n        mul_input[0] = uint256(5329749415213215279150815169017002879660981652478899879932293459107956198272); // vk.K[11].X\n        mul_input[1] = uint256(1269241490245981774317800992176787362067828005821041854984670483140659381972); // vk.K[11].Y\n        mul_input[2] = input[10];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[11] * input[10]\n        mul_input[0] = uint256(4943793813361186613838184379271444100858893499387902057809188182513783485846); // vk.K[12].X\n        mul_input[1] = uint256(9275690329715777324103642003412034648418070562981699307031172873365106078545); // vk.K[12].Y\n        mul_input[2] = input[11];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[12] * input[11]\n        mul_input[0] = uint256(12729498268013982038852548044563174517696421517428254680176367740849220266709); // vk.K[13].X\n        mul_input[1] = uint256(7546589572574852665535613703939452808321148398493753492131740521875420626909); // vk.K[13].Y\n        mul_input[2] = input[12];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[13] * input[12]\n        mul_input[0] = uint256(9333085734209829031122997463964247926338222396225058317742956090059153031592); // vk.K[14].X\n        mul_input[1] = uint256(4043123151744068929699760825751364162242644369436915556155534564396462636465); // vk.K[14].Y\n        mul_input[2] = input[13];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[14] * input[13]\n        mul_input[0] = uint256(3698686717106590496650986585007797659650605418055308742433506982460764492730); // vk.K[15].X\n        mul_input[1] = uint256(9179617523334761636265229485895993306228474412981061346064728177636515751968); // vk.K[15].Y\n        mul_input[2] = input[14];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[15] * input[14]\n        mul_input[0] = uint256(15521850592660810728436432508964964041834382081916421935161893482249902884387); // vk.K[16].X\n        mul_input[1] = uint256(5449901017503560405242500659614777785834634841695450826672263537767974100219); // vk.K[16].Y\n        mul_input[2] = input[15];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[16] * input[15]\n        mul_input[0] = uint256(20102906107256118088436001377164222872704427733042089123636772674622559816716); // vk.K[17].X\n        mul_input[1] = uint256(12498854682789208487185327670228889940757953195079617884138082484806034246784); // vk.K[17].Y\n        mul_input[2] = input[16];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[17] * input[16]\n        mul_input[0] = uint256(9455841695606475800176819517076441035373288808813491909032241063291148788930); // vk.K[18].X\n        mul_input[1] = uint256(5760837211388967374979882368837632355372021503182733102840122488409476353553); // vk.K[18].Y\n        mul_input[2] = input[17];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[18] * input[17]\n        mul_input[0] = uint256(1446991383552871512734012954692326283314249519870143612600792757960520781278); // vk.K[19].X\n        mul_input[1] = uint256(9834470268591454131741863361237282178002203711883219940241340793939995038767); // vk.K[19].Y\n        mul_input[2] = input[18];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[19] * input[18]\n        mul_input[0] = uint256(1059357485615144832413353841149751938707953460935522780194084907196702253731); // vk.K[20].X\n        mul_input[1] = uint256(10815569476482003993766770423385630209543201328293985898718647153832884016017); // vk.K[20].Y\n        mul_input[2] = input[19];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[20] * input[19]\n        mul_input[0] = uint256(7433245970798099608332042376067563625513377267096206052430761000239299269566); // vk.K[21].X\n        mul_input[1] = uint256(12741834193487831964894419250386047831198155854304448707022734193570700410821); // vk.K[21].Y\n        mul_input[2] = input[20];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[21] * input[20]\n        mul_input[0] = uint256(8648224634225961431530490440075030243542463588893169022877288417966438069777); // vk.K[22].X\n        mul_input[1] = uint256(16540610842070555034877322476339116325277917786072762919274678110762172365508); // vk.K[22].Y\n        mul_input[2] = input[21];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[22] * input[21]\n        mul_input[0] = uint256(16908648218709781420138074614673957046034248547088691701260866141074824824919); // vk.K[23].X\n        mul_input[1] = uint256(20980273428957053574278769661356962533672481733183512384951407225298181139010); // vk.K[23].Y\n        mul_input[2] = input[22];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[23] * input[22]\n        mul_input[0] = uint256(20934252423600973663175987808002009495824217352345209099319606411155218995932); // vk.K[24].X\n        mul_input[1] = uint256(9987927206019920292163635872827487165514620975045002130414615160938718715749); // vk.K[24].Y\n        mul_input[2] = input[23];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[24] * input[23]\n        mul_input[0] = uint256(9602737041922572073213386264444643405537681976425696147506639312256088109115); // vk.K[25].X\n        mul_input[1] = uint256(5030838233095700558123674330813925820525997306253984515590208165812087573689); // vk.K[25].Y\n        mul_input[2] = input[24];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[25] * input[24]\n        mul_input[0] = uint256(20088832978375886523413495106079569725269630343909328763686584839952109161933); // vk.K[26].X\n        mul_input[1] = uint256(8311397503596416021728705867174781915782892850820869993294450806608979293432); // vk.K[26].Y\n        mul_input[2] = input[25];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[26] * input[25]\n        mul_input[0] = uint256(15729968276421379987872047780863974781795109674620595131198333451598870913212); // vk.K[27].X\n        mul_input[1] = uint256(11755585053459843437112320638816029546922021127794137048950074210155862560131); // vk.K[27].Y\n        mul_input[2] = input[26];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[27] * input[26]\n        mul_input[0] = uint256(5783930197610380391486193680213891260111080319012345925622032738683845648623); // vk.K[28].X\n        mul_input[1] = uint256(15914052883335873414184612431500787588848752068877353731383121390711998005745); // vk.K[28].Y\n        mul_input[2] = input[27];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[28] * input[27]\n        mul_input[0] = uint256(13576027419855184371737615151659181815220661446877879847199764825219880625500); // vk.K[29].X\n        mul_input[1] = uint256(2191728030944522062213775267825510142676636904535936426097088151735038661017); // vk.K[29].Y\n        mul_input[2] = input[28];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[29] * input[28]\n        mul_input[0] = uint256(17443744306907421274656073114832682866914815795994710278637727590770342132904); // vk.K[30].X\n        mul_input[1] = uint256(6204265850197846880732314988280474321915051365218910504902500465319260176648); // vk.K[30].Y\n        mul_input[2] = input[29];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[30] * input[29]\n        mul_input[0] = uint256(7667236600173703281656707827902729453577123223272717952708859478183847798002); // vk.K[31].X\n        mul_input[1] = uint256(3073364345901477288521870238026227645583520851820532416933060479253244595356); // vk.K[31].Y\n        mul_input[2] = input[30];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[31] * input[30]\n        mul_input[0] = uint256(9980877541970177898146397507672456369445448128646497326829193893755401659297); // vk.K[32].X\n        mul_input[1] = uint256(11845859001496825643147981605740249183632753870257747701403057774143489519069); // vk.K[32].Y\n        mul_input[2] = input[31];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[32] * input[31]\n        mul_input[0] = uint256(12453897189547283279636360437482740153245209912090247350145743599538029507132); // vk.K[33].X\n        mul_input[1] = uint256(6469937287375115226432040539121250021511388797917475330256634615436829876816); // vk.K[33].Y\n        mul_input[2] = input[32];\n        Common.accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[33] * input[32]\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/common/Common.sol": {
      "content": "// SPDX-License-Identifier: AML\n\npragma solidity ^0.8.0;\n\nimport \"./Pairing.sol\";\n\nlibrary Common {\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: AML\n\npragma solidity ^0.8.0;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n"
    },
    "contracts/verifiers/zk-verifiers/common/Pairing.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/EthChunkOf128ProofVerifier.sol": {
      "content": "\n// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\nimport \"../interfaces/IZkpVerifier.sol\";\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(\n        G1Point memory p1,\n        G1Point memory p2\n    ) internal view returns (G1Point memory r) {\n\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-add-failed\");\n    }\n\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 {invalid()}\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n        require (success,\"pairing-mul-failed\");\n    }\n\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 {invalid()}\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n\ncontract EthChunkOf128Verifier is IZkpVerifier {\n\n    using Pairing for *;\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(uint256(3731296059100206882180451755503172983109296248442025944723039592906698751900), uint256(259282599373131156598819103264659325586675381205265829375869139666859279077));\n        vk.beta2 = Pairing.G2Point([uint256(1542547783169253521197735286554664372551314003473574629092788070944269927009), uint256(3442843350567772397992411822441194496033000804528083490373991767861898380921)], [uint256(548716800731408953921339589333269049204399133705913270541257072650667905637), uint256(19884421027672845815718445738066364430735990147602958067065404264457524686219)]);\n        vk.gamma2 = Pairing.G2Point([uint256(11891988479373600508373950254994848776611254114498681881881793265865565715386), uint256(19931296744367177659683198721889325174160042107805115279855692658605438538701)], [uint256(16677912734950263118736987260922842186425341971840174170121099525719169899146), uint256(7417603967557513391474517980599665601132457400115579956964885296221617800673)]);\n        vk.delta2 = Pairing.G2Point([uint256(16517284527623427684849545816824631314997223078114802689115370057079771769284), uint256(9556334973004218826551566300456739568039857994289235505930178517047984960309)], [uint256(11378844714980444222011796238800318515164232281952868936120207698945684705011), uint256(16717114042048232586709438632101306668327363244916399631576013967002311482733)]);\n    }\n\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[8] memory input\n    ) public view returns (bool r) {\n\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(20771483654708554343899445707962704346619674363636303975277986884195939178109); // vk.K[0].X\n        vk_x.Y = uint256(7136981524249642767758675836778771393360023884114860800337043409235713151709); // vk.K[0].Y\n        mul_input[0] = uint256(19233685918932192923050625893183018999852678211997471298974889334412747883339); // vk.K[1].X\n        mul_input[1] = uint256(10573418048246313728599286941747928760901755928929380194465994346023631757706); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(14573802110847817293393990384189386188819275610796892844002198465549922624165); // vk.K[2].X\n        mul_input[1] = uint256(6366177769334632983948241800448594297640371227299129420889272762628401203322); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(4423470128720469023828937120320047480914076991874402659152085174133214111513); // vk.K[3].X\n        mul_input[1] = uint256(16661537357790150960310016685835020561095798528309478888052879927100385369883); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(20954264198739863123465273905250064029734563486205900387553306667464142762653); // vk.K[4].X\n        mul_input[1] = uint256(15400479026677042446536213348710994852526762940505119021682575524837659837800); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(0); // vk.K[5].X\n        mul_input[1] = uint256(0); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(0); // vk.K[6].X\n        mul_input[1] = uint256(0); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(15581619746676589215919086055186955357437498065118852273796328444039455983836); // vk.K[7].X\n        mul_input[1] = uint256(2079225735174412294634686160304546497644529522569168218992038814057683036684); // vk.K[7].Y\n        mul_input[2] = input[6];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(5271944653916881751571075049622758937543583004433508630909066776841583056730); // vk.K[8].X\n        mul_input[1] = uint256(5018511801199739199792530205278441732520613352432208789698314328778478334533); // vk.K[8].Y\n        mul_input[2] = input[7];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return Pairing.pairing(\n            Pairing.negate(proof.A),\n            proof.B,\n            vk.alfa1,\n            vk.beta2,\n            vk_x,\n            vk.gamma2,\n            proof.C,\n            vk.delta2\n        );\n    }\n\n    function verifyRaw(bytes calldata proofData) external view returns (bool) {\n        uint256[2] memory a;\n        a[0] = uint256(bytes32(proofData[:32]));\n        a[1] = uint256(bytes32(proofData[32:64]));\n        uint256[2][2] memory b;\n        b[0][0] = uint256(bytes32(proofData[64:96]));\n        b[0][1] = uint256(bytes32(proofData[96:128]));\n        b[1][0] = uint256(bytes32(proofData[128:160]));\n        b[1][1] = uint256(bytes32(proofData[160:192]));\n        uint256[2] memory c;\n        c[0] = uint256(bytes32(proofData[192:224]));\n        c[1] = uint256(bytes32(proofData[224:256]));\n        uint256[2] memory commit;\n        commit[0] = uint256(bytes32(proofData[256:288]));\n        commit[1] = uint256(bytes32(proofData[288:320]));\n        uint256[8] memory input;\n        input[0] = uint256(bytes32(proofData[320:352]));\n        input[1] = uint256(bytes32(proofData[352:384]));\n        input[2] = uint256(bytes32(proofData[384:416]));\n        input[3] = uint256(bytes32(proofData[416:448]));\n        input[4] = uint256(bytes32(proofData[448:480]));\n        input[5] = uint256(bytes32(proofData[480:512]));\n        input[6] = uint256(bytes32(proofData[512:544]));\n        input[7] = uint256(bytes32(proofData[544:576]));\n\n        return verifyProof(a, b, c, commit, input);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/EthChunkOf4Verifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IZkpVerifier.sol\";\n\nlibrary Pairing {\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n\ncontract EthChunkOf4Verifier is IZkpVerifier {\n    using Pairing for *;\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(18817484117484069366757665183662813402495953473519259662283079002294548080691),\n            uint256(3707867045561993601731789112226505946031412633462297251830101019097999108551)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(14213976529208837719488764109084713770065992925229028604696041977506661049055),\n                uint256(21424749531634428021749427392088154088337263471292474469985930285441628539400)\n            ],\n            [\n                uint256(9947456217500232408381126874555624761869562282312931767209841535086538286105),\n                uint256(11093797387504627481297019303400776129939635051612302273918935672881734940150)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(25256757722808193402729875811627815184432273207181170376097646944363660428),\n                uint256(14448194432164744891650627119186885271368113477576102466482554138470620061715)\n            ],\n            [\n                uint256(18974800557241068460803322719309396040989098741381788513391228987758417368992),\n                uint256(18706248632581717947962797018673911201194428624389311999422128961719537501802)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(6292990886972116428963934290848620154597851746547245567837436369811884001883),\n                uint256(18505423028363144788114344002000719154538064035501300051042881963693413564189)\n            ],\n            [\n                uint256(17097858395416461294042716501974032630525650446206569046941246159931214861534),\n                uint256(577689152318570673179160528008804919184731144878495931581457695389740904030)\n            ]\n        );\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[8] memory input\n    ) public view returns (bool r) {\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(6166774643054930396128303512925021211088528559625868963141665622436507850338); // vk.K[0].X\n        vk_x.Y = uint256(1366802430701477708767297578799612519304923222530131915839730192852149168002); // vk.K[0].Y\n        mul_input[0] = uint256(7917416894269141091274540808489820310039933179816056718878189168376321863625); // vk.K[1].X\n        mul_input[1] = uint256(10259616060354789615287745330945951632310714601987727770205554466995895686225); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(16557245815426527630463258162311177691755699637719478034071580678973549612319); // vk.K[2].X\n        mul_input[1] = uint256(21353791902778596696078831702815880782394838855719487337551098082703593506228); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(12616991494489362613958763195408535348901069566643828794530918592786924327022); // vk.K[3].X\n        mul_input[1] = uint256(10542368460295172479933247337523378034571330389389219789303493052373293841289); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(14164258132313981124885987124242726038159149323978238174240882772136051462554); // vk.K[4].X\n        mul_input[1] = uint256(8935396269628365491313180965725057556862681395897683056104763947636950296424); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(0); // vk.K[5].X\n        mul_input[1] = uint256(0); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(0); // vk.K[6].X\n        mul_input[1] = uint256(0); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(15867107710883206908088091496160875273703227764658753912807070702627859344025); // vk.K[7].X\n        mul_input[1] = uint256(847071465173731572379633624707701472829592314474215928151150253445060723461); // vk.K[7].Y\n        mul_input[2] = input[6];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(8592719208147103101510656570267286762577713272560555317459865324802331096613); // vk.K[8].X\n        mul_input[1] = uint256(401319081538986855829995977875037301319874053933248403106184957380310545939); // vk.K[8].Y\n        mul_input[2] = input[7];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n\n    function verifyRaw(bytes calldata proofData) external view returns (bool) {\n        uint256[2] memory a;\n        a[0] = uint256(bytes32(proofData[:32]));\n        a[1] = uint256(bytes32(proofData[32:64]));\n        uint256[2][2] memory b;\n        b[0][0] = uint256(bytes32(proofData[64:96]));\n        b[0][1] = uint256(bytes32(proofData[96:128]));\n        b[1][0] = uint256(bytes32(proofData[128:160]));\n        b[1][1] = uint256(bytes32(proofData[160:192]));\n        uint256[2] memory c;\n        c[0] = uint256(bytes32(proofData[192:224]));\n        c[1] = uint256(bytes32(proofData[224:256]));\n        uint256[2] memory commit;\n        commit[0] = uint256(bytes32(proofData[256:288]));\n        commit[1] = uint256(bytes32(proofData[288:320]));\n        uint256[8] memory input;\n        input[0] = uint256(bytes32(proofData[320:352]));\n        input[1] = uint256(bytes32(proofData[352:384]));\n        input[2] = uint256(bytes32(proofData[384:416]));\n        input[3] = uint256(bytes32(proofData[416:448]));\n        input[4] = uint256(bytes32(proofData[448:480]));\n        input[5] = uint256(bytes32(proofData[480:512]));\n        input[6] = uint256(bytes32(proofData[512:544]));\n        input[7] = uint256(bytes32(proofData[544:576]));\n\n        return verifyProof(a, b, c, commit, input);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/EthStorageVerifier.sol": {
      "content": "// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nimport \"./common/Pairing.sol\";\nimport \"./common/Constants.sol\";\nimport \"./common/Common.sol\";\n\ncontract EthStorageVerifier {\n    using Pairing for *;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(\n            uint256(4101194415195068025423874713299757109624368409561482108170376832586679531405),\n            uint256(4258395440362667126312935482794695741222608482150653359018346434337602508946)\n        );\n        vk.beta2 = Pairing.G2Point(\n            [\n                uint256(16439514875033274687454048461377996745326195782655333965576073480836691883559),\n                uint256(19276203858306240750277475695807151297248730490961797886027456650995005321959)\n            ],\n            [\n                uint256(19060953054949632557505353041350268914431326836117845728665299546912330812818),\n                uint256(4698702276323878506769802352286111743331920171021274587560571984285702023928)\n            ]\n        );\n        vk.gamma2 = Pairing.G2Point(\n            [\n                uint256(12838461299153070211771740521976432485177653380836211615829770099493232139064),\n                uint256(21183238866260352420957994792199103433633945560940750430485497773712222687210)\n            ],\n            [\n                uint256(17833421956262291594989392582813776941326904872094028568146525236797053854992),\n                uint256(16870220658894912225499336011210296770804995380996232515561786091840591541590)\n            ]\n        );\n        vk.delta2 = Pairing.G2Point(\n            [\n                uint256(9656699309964346278718040058127642112594472223235587127181580233464527618277),\n                uint256(19823064266563161392144329690471889204117741805048436633177469904580008915304)\n            ],\n            [\n                uint256(1997570263637684074581409993197259576695125905630672663128757086882404277806),\n                uint256(21296156718838357686129692666693528046179496134366711708929536738920590035238)\n            ]\n        );\n    }\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[9] calldata input\n    ) public view returns (bool r) {\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD, \"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(11324798991801455719954252063583334670536437952341509943176836321388782785475); // vk.K[0].X\n        vk_x.Y = uint256(12326427617847987634187499233539079835136211843857405454969210436632570846644); // vk.K[0].Y\n        mul_input[0] = uint256(15855758052910946362564301207345214800941948855526929671171992550648923901194); // vk.K[1].X\n        mul_input[1] = uint256(8814837402073387239890142132996274060688382484773297478886074148806745320694); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(6522741885788032953156164277068652456095530543849390614185398653638226383320); // vk.K[2].X\n        mul_input[1] = uint256(21192739319070000135810363152030394321048757677557147623013216697480179276271); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(11958951098730554082216072825282969421721647367014815269992686619331778317908); // vk.K[3].X\n        mul_input[1] = uint256(10655457940451391962242848166798429511880151597239431088751286306299649577129); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(17186075274510691052239294402855156934324874491974465566959055818508971850332); // vk.K[4].X\n        mul_input[1] = uint256(19158069234039211539526983551792889121978716641772966009217546796359790957076); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(9714094901466418966170048415820685381424848766104412220565399689260664652072); // vk.K[5].X\n        mul_input[1] = uint256(2249856808164293755600652581653693354796803855461791739554458217477761697306); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(17224884247093246510191903557819707122090369916854086297176718409151948017398); // vk.K[6].X\n        mul_input[1] = uint256(528501653263386182780162102397973366413989345917948755563786102759128317402); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        mul_input[0] = uint256(361174086899201465184609656237690432862909345413059635441144532044010353899); // vk.K[7].X\n        mul_input[1] = uint256(13366727442090128273019302009232654673396906988981409672802134248099590073825); // vk.K[7].Y\n        mul_input[2] = input[6];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[7] * input[6]\n        mul_input[0] = uint256(18653179265997504904500924363864280893939557576747047870034827610218133388062); // vk.K[8].X\n        mul_input[1] = uint256(2414988480708584541105466146832501629915521197512569819894185302890984806761); // vk.K[8].Y\n        mul_input[2] = input[7];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[8] * input[7]\n        mul_input[0] = uint256(20817613062917486844360076494632614720655961007368164725678903685604190477822); // vk.K[9].X\n        mul_input[1] = uint256(4044560346597429541255539481561957938362798150817993714804018870646190181781); // vk.K[9].Y\n        mul_input[2] = input[8];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[9] * input[8]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return\n            Pairing.pairing(Pairing.negate(proof.A), proof.B, vk.alfa1, vk.beta2, vk_x, vk.gamma2, proof.C, vk.delta2);\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/TransactionProof13Verifier.sol": {
      "content": "\n// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(\n        G1Point memory p1,\n        G1Point memory p2\n    ) internal view returns (G1Point memory r) {\n\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-add-failed\");\n    }\n\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 {invalid()}\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n        require (success,\"pairing-mul-failed\");\n    }\n\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 {invalid()}\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n\ncontract TransactionProof13Verifier {\n\n    using Pairing for *;\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(uint256(20251458252014746786532581505656126475537984610140277051490708107166442895680), uint256(8585152856269905466194214634316639665360123141944865510131541271503923323682));\n        vk.beta2 = Pairing.G2Point([uint256(6239180212895393178546850750920190996056093402054451082005129941128085079187), uint256(17301992949360331036318878575644959074207264488949659114240493081425133397178)], [uint256(16539156095691094784639943097343104699556189635289367728560842646961363290918), uint256(15214607408287875092825799513130316247925499489757150696598870411281473418389)]);\n        vk.gamma2 = Pairing.G2Point([uint256(404677956868346352342490795961713012642753351366481838253261603567363542408), uint256(12944513524889889562405242523464643291395919030295709271252570497935938546252)], [uint256(12353193483699341975801800693571436276577651770337196906424076745928198007792), uint256(2852126334401920684850096805382369378674975572375000229028247640129633647493)]);\n        vk.delta2 = Pairing.G2Point([uint256(17480632337847793707973793473488426631679404488633024849754696444720067464924), uint256(3125249719417509324402689501479471022737501674492511483812537029667365192637)], [uint256(12903626037834059249928294001419671447097476018276414995718233629623818785594), uint256(1093207551791190190054787500086343628150589395508335902017529446988469583629)]);\n    }\n\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[6] calldata input\n    ) public view returns (bool r) {\n\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(21815618769225288782459362073901971711373671919389580061837668585846205734350); // vk.K[0].X\n        vk_x.Y = uint256(10265100904949794773751844829203077231028889226472878968393654235693725008958); // vk.K[0].Y\n        mul_input[0] = uint256(14482169495503872667862228326429040452423157330711030058573061479791628222505); // vk.K[1].X\n        mul_input[1] = uint256(3144799516176984200686921889894983631305948545282346096763993999767699077048); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(651626936445204439950749500798386553640100632509831457327492163323097010221); // vk.K[2].X\n        mul_input[1] = uint256(19106322510844554872881820769761207857613765159291812254821174661684130362881); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(5164152288109983089690067668481993955701210342073856259839398820403866585925); // vk.K[3].X\n        mul_input[1] = uint256(12326675048862197233085127475834860663436498892973048544477244427688951379136); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(4117419582507964202445114379822875603938924692362941639921516229747372682420); // vk.K[4].X\n        mul_input[1] = uint256(18433214303265631592778310115820936988484877929384502810296577371145491884606); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(455358870474467018829941436610213028882575664187300197957047899409147296984); // vk.K[5].X\n        mul_input[1] = uint256(2523624244999600967199343059096132969335990824721488390096061297497653749846); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(15398503582505278499028405637583453647180726986273061193008747986248973267878); // vk.K[6].X\n        mul_input[1] = uint256(2058266944403802492717209110842277579798368267040758163858877864986666932562); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return Pairing.pairing(\n            Pairing.negate(proof.A),\n            proof.B,\n            vk.alfa1,\n            vk.beta2,\n            vk_x,\n            vk.gamma2,\n            proof.C,\n            vk.delta2\n        );\n    }\n}\n"
    },
    "contracts/verifiers/zk-verifiers/TransactionProof37Verifier.sol": {
      "content": "\n// SPDX-License-Identifier: AML\n//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity ^0.8.0;\n\nlibrary Pairing {\n\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(\n        G1Point memory p1,\n        G1Point memory p2\n    ) internal view returns (G1Point memory r) {\n\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-add-failed\");\n    }\n\n\n    /*\n     * Same as plus but accepts raw input instead of struct\n     * @return The sum of two points of G1, one is represented as array\n     */\n    function plus_raw(uint256[4] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 {invalid()}\n        }\n\n        require(success, \"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n        require (success,\"pairing-mul-failed\");\n    }\n\n\n    /*\n     * Same as scalar_mul but accepts raw input instead of struct,\n     * Which avoid extra allocation. provided input can be allocated outside and re-used multiple times\n     */\n    function scalar_mul_raw(uint256[3] memory input, G1Point memory r) internal view {\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 {invalid()}\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n}\n\ncontract TransactionProof37Verifier {\n\n    using Pairing for *;\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    struct VerifyingKey {\n        Pairing.G1Point alfa1;\n        Pairing.G2Point beta2;\n        Pairing.G2Point gamma2;\n        Pairing.G2Point delta2;\n        // []G1Point IC (K in gnark) appears directly in verifyProof\n    }\n\n    struct Proof {\n        Pairing.G1Point A;\n        Pairing.G2Point B;\n        Pairing.G1Point C;\n        Pairing.G1Point Commit;\n    }\n\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n        vk.alfa1 = Pairing.G1Point(uint256(1910293729168649379012161399010872678831302053234593602614808340472164370206), uint256(9643849218941985500628811210639241885759112586935825682625728369860198403492));\n        vk.beta2 = Pairing.G2Point([uint256(16822847600360186257143639180949060024662799053061884020479400234059750346302), uint256(14108024397973799053794422411322469358388968339440224770176816628358656353295)], [uint256(8696445076678266244146599830181851748470759471419540772743755075641560579203), uint256(12137240365406224531084954296833955868032190277693014654526654532680695646121)]);\n        vk.gamma2 = Pairing.G2Point([uint256(3106477081800487684702197609336793578996599722738758416741894108250584952412), uint256(17769315574634517198959944866792285196528619991510833533647042528867740841497)], [uint256(17550976402938237477690329891427538913705970488483325143361818027802831969580), uint256(19564919261896948583062923173775725062171897993601375119831785459533152098560)]);\n        vk.delta2 = Pairing.G2Point([uint256(12892811443621733648975173907437618319776140089825570542949912397946888153254), uint256(4329993878235330304234158522137296465637295347745243858920373696586654891645)], [uint256(13919225177395245875350213490350160393023488096741711658832974485762210768745), uint256(15219587570363605524638651955941153453620758942698393737137577829587158276942)]);\n    }\n\n\n    // accumulate scalarMul(mul_input) into q\n    // that is computes sets q = (mul_input[0:2] * mul_input[3]) + q\n    function accumulate(\n        uint256[3] memory mul_input,\n        Pairing.G1Point memory p,\n        uint256[4] memory buffer,\n        Pairing.G1Point memory q\n    ) internal view {\n        // computes p = mul_input[0:2] * mul_input[3]\n        Pairing.scalar_mul_raw(mul_input, p);\n\n        // point addition inputs\n        buffer[0] = q.X;\n        buffer[1] = q.Y;\n        buffer[2] = p.X;\n        buffer[3] = p.Y;\n\n        // q = p + q\n        Pairing.plus_raw(buffer, q);\n    }\n\n    /*\n     * @returns Whether the proof is valid given the hardcoded verifying key\n     *          above and the public inputs\n     */\n    function verifyProof(\n        uint256[2] memory a,\n        uint256[2][2] memory b,\n        uint256[2] memory c,\n        uint256[2] memory commit,\n        uint256[6] calldata input\n    ) public view returns (bool r) {\n\n        Proof memory proof;\n        proof.A = Pairing.G1Point(a[0], a[1]);\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n        proof.C = Pairing.G1Point(c[0], c[1]);\n        proof.Commit = Pairing.G1Point(commit[0], commit[1]);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        // Make sure that every input is less than the snark scalar field\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\n        }\n\n        VerifyingKey memory vk = verifyingKey();\n\n        // Compute the linear combination vk_x\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\n\n        // Buffer reused for addition p1 + p2 to avoid memory allocations\n        // [0:2] -> p1.X, p1.Y ; [2:4] -> p2.X, p2.Y\n        uint256[4] memory add_input;\n\n        // Buffer reused for multiplication p1 * s\n        // [0:2] -> p1.X, p1.Y ; [3] -> s\n        uint256[3] memory mul_input;\n\n        // temporary point to avoid extra allocations in accumulate\n        Pairing.G1Point memory q = Pairing.G1Point(0, 0);\n\n        vk_x.X = uint256(11966620651374967254643410260589552442195768077678643408414034660856248063082); // vk.K[0].X\n        vk_x.Y = uint256(14201972430997316666699324027320825798497165005985605117136793951446085331090); // vk.K[0].Y\n        mul_input[0] = uint256(9600558441001135400505290048756646232880516973895317897389325670316519836157); // vk.K[1].X\n        mul_input[1] = uint256(16760364464242344172069241426179100713735802313271688691105188634950125317453); // vk.K[1].Y\n        mul_input[2] = input[0];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[1] * input[0]\n        mul_input[0] = uint256(3740034587536093064133894334154113883056085690271209650376798101138920054248); // vk.K[2].X\n        mul_input[1] = uint256(11246497375627702638239696598461496801899600113304086248719493779002935317755); // vk.K[2].Y\n        mul_input[2] = input[1];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[2] * input[1]\n        mul_input[0] = uint256(13030229328455313863332076106877975874541332406100355032047773418791826960353); // vk.K[3].X\n        mul_input[1] = uint256(9733066468969270460191473800945221923631880026974745671838901176243676185175); // vk.K[3].Y\n        mul_input[2] = input[2];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[3] * input[2]\n        mul_input[0] = uint256(6189471970846665438232841261308948563909763145001276487103946573140541149139); // vk.K[4].X\n        mul_input[1] = uint256(10715572537296481203145410189810035243350069028404350348388136012166304031571); // vk.K[4].Y\n        mul_input[2] = input[3];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[4] * input[3]\n        mul_input[0] = uint256(17523712979343547665011752293906977166261741147452247522372423266208174046122); // vk.K[5].X\n        mul_input[1] = uint256(3551271029987179661786623970827871391238564096356098036215143026253700157271); // vk.K[5].Y\n        mul_input[2] = input[4];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[5] * input[4]\n        mul_input[0] = uint256(12796423093885476905323875458445033293296377846238370196878216696080485113559); // vk.K[6].X\n        mul_input[1] = uint256(12127470002424275366470792560424768578355558242766007939973968221501051346300); // vk.K[6].Y\n        mul_input[2] = input[5];\n        accumulate(mul_input, q, add_input, vk_x); // vk_x += vk.K[6] * input[5]\n        if (commit[0] != 0 || commit[1] != 0) {\n            vk_x = Pairing.plus(vk_x, proof.Commit);\n        }\n\n        return Pairing.pairing(\n            Pairing.negate(proof.A),\n            proof.B,\n            vk.alfa1,\n            vk.beta2,\n            vk_x,\n            vk.gamma2,\n            proof.C,\n            vk.delta2\n        );\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "solidity-rlp/contracts/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\npragma solidity >=0.5.10 <=0.8.18;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @param the RLP item.\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        (, uint256 len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n     * @param the RLP item containing the encoded list.\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n        uint256 result;\n        assembly {\n            result := mload(memPtr)\n\n            // shift to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            itemLen = 1;\n        } else if (byte0 < STRING_LONG_START) {\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            return 0;\n        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {\n            return 1;\n        } else if (byte0 < LIST_SHORT_START) {\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        } else {\n            return byte0 - (LIST_LONG_START - 1) + 1;\n        }\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(uint256 src, uint256 dest, uint256 len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}