{
  "address": "0x0e38FDbDebB447B76568a57A71165fC0a669C9F8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ITxVerifier",
          "name": "_txVerifier",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "chainId",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "timestamp",
          "type": "uint64"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "usdcAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "enum UniswapVolume.TierName",
          "name": "tier",
          "type": "uint8"
        }
      ],
      "name": "VerifiedSwap",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum UniswapVolume.TierName[]",
          "name": "_names",
          "type": "uint8[]"
        },
        {
          "internalType": "address[]",
          "name": "_nfts",
          "type": "address[]"
        }
      ],
      "name": "setTierNFTs",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ITxVerifier",
          "name": "_txVerifier",
          "type": "address"
        }
      ],
      "name": "setTxVerifier",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_chainId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "_usdc",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "_decimal",
          "type": "uint8"
        }
      ],
      "name": "setUSDC",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_chainId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "setUniversalRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_chainId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "_weth",
          "type": "address"
        }
      ],
      "name": "setWETH",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_tx",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_auxiBlkVerifyInfo",
          "type": "bytes"
        }
      ],
      "name": "submitUniswapTxProof",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum UniswapVolume.TierName",
          "name": "",
          "type": "uint8"
        }
      ],
      "name": "tierNFTs",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "txVerifier",
      "outputs": [
        {
          "internalType": "contract ITxVerifier",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "name": "universalRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "name": "usdc",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_chainId",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "usdcSwapAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "enum UniswapVolume.TierName",
          "name": "tier",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "userTier",
      "outputs": [
        {
          "internalType": "enum UniswapVolume.TierName",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "name": "weth",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x9e835531813f935cc735ddaceb3a149f618a64c469e22e10b92551ce6bb6ec88",
  "receipt": {
    "to": null,
    "from": "0x9532f934EfcE6c4Bf5BA078b25fDd81a780FBdfB",
    "contractAddress": "0x0e38FDbDebB447B76568a57A71165fC0a669C9F8",
    "transactionIndex": 6,
    "gasUsed": "1406831",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000004000000000000000000000020000000000000000000800000000000000000000000008000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020040000000000000000000000000000000000000000000000000800000000000000",
    "blockHash": "0x075db6006fd84de9284623425f1a6064d26482467680fd38184f91f2c0da706c",
    "transactionHash": "0x9e835531813f935cc735ddaceb3a149f618a64c469e22e10b92551ce6bb6ec88",
    "logs": [
      {
        "transactionIndex": 6,
        "blockNumber": 30651566,
        "transactionHash": "0x9e835531813f935cc735ddaceb3a149f618a64c469e22e10b92551ce6bb6ec88",
        "address": "0x0e38FDbDebB447B76568a57A71165fC0a669C9F8",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000009532f934efce6c4bf5ba078b25fdd81a780fbdfb"
        ],
        "data": "0x",
        "logIndex": 10,
        "blockHash": "0x075db6006fd84de9284623425f1a6064d26482467680fd38184f91f2c0da706c"
      }
    ],
    "blockNumber": 30651566,
    "cumulativeGasUsed": "2683486",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xD9C0bC3BCe36F478c71746d51B833C99E99D568F"
  ],
  "numDeployments": 4,
  "solcInputHash": "88412c49ed27190cac976e00b987d18e",
  "metadata": "{\"compiler\":{\"version\":\"0.8.18+commit.87f61d96\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ITxVerifier\",\"name\":\"_txVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"chainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum UniswapVolume.TierName\",\"name\":\"tier\",\"type\":\"uint8\"}],\"name\":\"VerifiedSwap\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum UniswapVolume.TierName[]\",\"name\":\"_names\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"_nfts\",\"type\":\"address[]\"}],\"name\":\"setTierNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITxVerifier\",\"name\":\"_txVerifier\",\"type\":\"address\"}],\"name\":\"setTxVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_decimal\",\"type\":\"uint8\"}],\"name\":\"setUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setUniversalRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"setWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_tx\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_auxiBlkVerifyInfo\",\"type\":\"bytes\"}],\"name\":\"submitUniswapTxProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum UniswapVolume.TierName\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tierNFTs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txVerifier\",\"outputs\":[{\"internalType\":\"contract ITxVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"universalRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"usdcSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum UniswapVolume.TierName\",\"name\":\"tier\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTier\",\"outputs\":[{\"internalType\":\"enum UniswapVolume.TierName\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/apps/uniswap-volume/UniswapVolume.sol\":\"UniswapVolume\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/apps/uniswap-volume/UniswapVolume.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport {BytesLib} from \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./libraries/Commands.sol\\\";\\nimport \\\"./libraries/Path.sol\\\";\\nimport \\\"../../verifiers/interfaces/ITxVerifier.sol\\\";\\n\\ninterface IBrevisUniNFT {\\n    function mint(address to) external;\\n}\\n\\ncontract UniswapVolume is Ownable {\\n    ITxVerifier public txVerifier;\\n\\n    mapping(uint64 => address) public universalRouter; // chainId -> router address\\n    mapping(uint64 => address) public weth; // chainId -> WETH address\\n    mapping(uint64 => address) public usdc; // chainId -> USDC address\\n    mapping(uint64 => uint8) usdcDecimal; // chainId -> USDC decimal\\n\\n    bytes4 private executeSelector = bytes4(keccak256(bytes(\\\"execute(bytes,bytes[],uint256)\\\")));\\n    bytes4 private executeNoDealineSelector = bytes4(keccak256(bytes(\\\"execute(bytes,bytes[])\\\")));\\n\\n    enum TierName {\\n        Null,\\n        Stone,\\n        Bronze,\\n        Silver,\\n        Gold,\\n        Platinum,\\n        Diamond\\n    }\\n    mapping(TierName => address) public tierNFTs;\\n    mapping(address => TierName) public userTier; // user -> tier\\n\\n    event VerifiedSwap(uint64 chainId, address trader, uint64 timestamp, uint256 usdcAmount, TierName tier);\\n\\n    constructor(ITxVerifier _txVerifier) {\\n        txVerifier = _txVerifier;\\n    }\\n\\n    function submitUniswapTxProof(\\n        bytes calldata _tx,\\n        bytes calldata _proof,\\n        bytes calldata _auxiBlkVerifyInfo\\n    ) external {\\n        ITxVerifier.TxInfo memory txInfo = txVerifier.verifyTxAndLog(_tx, _proof, _auxiBlkVerifyInfo);\\n        require(txInfo.to == universalRouter[txInfo.chainId], \\\"invalid to address\\\");\\n        require(userTier[txInfo.from] == TierName.Null, \\\"swap already proved for this user\\\");\\n\\n        (uint256 amount, TierName tier) = usdcSwapAmount(txInfo.chainId, txInfo.data);\\n        userTier[txInfo.from] = tier;\\n        IBrevisUniNFT(tierNFTs[tier]).mint(txInfo.from);\\n\\n        emit VerifiedSwap(txInfo.chainId, txInfo.from, txInfo.blkTime, amount, tier);\\n    }\\n\\n    function setUniversalRouter(uint64 _chainId, address _router) external onlyOwner {\\n        universalRouter[_chainId] = _router;\\n    }\\n\\n    function setWETH(uint64 _chainId, address _weth) external onlyOwner {\\n        weth[_chainId] = _weth;\\n    }\\n\\n    function setUSDC(uint64 _chainId, address _usdc, uint8 _decimal) external onlyOwner {\\n        usdc[_chainId] = _usdc;\\n        usdcDecimal[_chainId] = _decimal;\\n    }\\n\\n    function setTierNFTs(TierName[] calldata _names, address[] calldata _nfts) external onlyOwner {\\n        require(_names.length == _nfts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _names.length; i++) {\\n            tierNFTs[_names[i]] = _nfts[i];\\n        }\\n    }\\n\\n    function setTxVerifier(ITxVerifier _txVerifier) external onlyOwner {\\n        txVerifier = _txVerifier;\\n    }\\n\\n    function usdcSwapAmount(uint64 _chainId, bytes memory _data) public view returns (uint256 amount, TierName tier) {\\n        bytes4 method;\\n        assembly {\\n            method := mload(add(_data, 32))\\n        }\\n        require(method == executeSelector || method == executeNoDealineSelector, \\\"wrong method\\\");\\n        bytes memory argdata = BytesLib.slice(_data, 4, _data.length - 4);\\n        (bytes memory commands, bytes[] memory inputs, ) = abi.decode(argdata, (bytes, bytes[], uint256));\\n        // assume tx succeeded, so no need to check deadline or command/input length match\\n\\n        uint256 command = uint8(commands[0] & Commands.COMMAND_TYPE_MASK);\\n        bytes memory input;\\n        if (command == Commands.WRAP_ETH || command == Commands.PERMIT2_PERMIT) {\\n            command = uint8(commands[1] & Commands.COMMAND_TYPE_MASK);\\n            input = inputs[1];\\n        } else {\\n            input = inputs[0];\\n        }\\n        require(command == Commands.V3_SWAP_EXACT_IN || command == Commands.V3_SWAP_EXACT_OUT, \\\"unsupported command\\\");\\n        (, uint256 amountA, uint256 amountB, bytes memory path, ) = abi.decode(\\n            input,\\n            (address, uint256, uint256, bytes, bool)\\n        );\\n        (address tokenA, address tokenB, ) = Path.decodeFirstPool(path);\\n        if (tokenA == weth[_chainId]) {\\n            require(tokenB == usdc[_chainId], \\\"unsupported pair\\\");\\n            amount = amountB;\\n        } else if (tokenA == usdc[_chainId]) {\\n            require(tokenB == weth[_chainId], \\\"unsupported pair\\\");\\n            amount = amountA;\\n        } else {\\n            revert(\\\"unsupported pair\\\");\\n        }\\n        require(amount > 0, \\\"zero usdc amount\\\");\\n        tier = getAmountTier(_chainId, amount);\\n    }\\n\\n    function getAmountTier(uint64 _chainId, uint256 _amount) private view returns (TierName tier) {\\n        uint256 decimal = 10 ** usdcDecimal[_chainId];\\n        if (_amount >= 1000000 * decimal) {\\n            return TierName.Diamond;\\n        } else if (_amount >= 100000 * decimal) {\\n            return TierName.Platinum;\\n        } else if (_amount >= 10000 * decimal) {\\n            return TierName.Gold;\\n        } else if (_amount >= 1000 * decimal) {\\n            return TierName.Silver;\\n        } else if (_amount >= 100 * decimal) {\\n            return TierName.Bronze;\\n        }\\n        return TierName.Stone;\\n    }\\n}\\n\",\"keccak256\":\"0xd318a30bb73128069661b8273af6432df661550dfb533e31d9135996741fc47b\",\"license\":\"MIT\"},\"contracts/apps/uniswap-volume/libraries/Commands.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// https://github.com/Uniswap/universal-router/blob/main/contracts/libraries/Commands.sol\\npragma solidity >=0.8.0;\\n\\n/// @title Commands\\n/// @notice Command Flags used to decode commands\\nlibrary Commands {\\n    // Masks to extract certain bits of commands\\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\\n\\n    // Command Types. Maximum supported command at this moment is 0x3f.\\n\\n    // Command Types where value<0x08, executed in the first nested-if block\\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\\n    uint256 constant SWEEP = 0x04;\\n    uint256 constant TRANSFER = 0x05;\\n    uint256 constant PAY_PORTION = 0x06;\\n    // COMMAND_PLACEHOLDER = 0x07;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant FIRST_IF_BOUNDARY = 0x08;\\n\\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\\n    uint256 constant PERMIT2_PERMIT = 0x0a;\\n    uint256 constant WRAP_ETH = 0x0b;\\n    uint256 constant UNWRAP_WETH = 0x0c;\\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\\n    // COMMAND_PLACEHOLDER = 0x0f;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant SECOND_IF_BOUNDARY = 0x10;\\n\\n    // Command Types where 0x10<=value<0x18, executed in the third nested-if block\\n    uint256 constant SEAPORT_V1_5 = 0x10;\\n    uint256 constant LOOKS_RARE_V2 = 0x11;\\n    uint256 constant NFTX = 0x12;\\n    uint256 constant CRYPTOPUNKS = 0x13;\\n    // 0x14;\\n    uint256 constant OWNER_CHECK_721 = 0x15;\\n    uint256 constant OWNER_CHECK_1155 = 0x16;\\n    uint256 constant SWEEP_ERC721 = 0x17;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant THIRD_IF_BOUNDARY = 0x18;\\n\\n    // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\\n    uint256 constant X2Y2_721 = 0x18;\\n    uint256 constant SUDOSWAP = 0x19;\\n    uint256 constant NFT20 = 0x1a;\\n    uint256 constant X2Y2_1155 = 0x1b;\\n    uint256 constant FOUNDATION = 0x1c;\\n    uint256 constant SWEEP_ERC1155 = 0x1d;\\n    uint256 constant ELEMENT_MARKET = 0x1e;\\n    // COMMAND_PLACEHOLDER = 0x1f;\\n\\n    // The commands are executed in nested if blocks to minimise gas consumption\\n    // The following constant defines one of the boundaries where the if blocks split commands\\n    uint256 constant FOURTH_IF_BOUNDARY = 0x20;\\n\\n    // Command Types where 0x20<=value\\n    uint256 constant SEAPORT_V1_4 = 0x20;\\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\\n    uint256 constant APPROVE_ERC20 = 0x22;\\n    // COMMAND_PLACEHOLDER for 0x23 to 0x3f (all unused)\\n}\\n\",\"keccak256\":\"0x68b90172c7b51f41ddd47ea2be30110dfa69a329ffb836f37ffff681551e83a4\",\"license\":\"GPL-3.0-or-later\"},\"contracts/apps/uniswap-volume/libraries/Path.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// from https://github.com/Uniswap/v3-periphery\\npragma solidity >=0.8.0;\\n\\nlibrary Path {\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n    /// @dev The length of the bytes encoded fee\\n    uint256 private constant FEE_SIZE = 3;\\n\\n    /// @dev The offset of a single token address and pool fee\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\\n    /// @dev The offset of an encoded pool key\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n\\n    /// @notice Decodes the first pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given pool\\n    /// @return tokenB The second token of the given pool\\n    /// @return fee The fee level of the pool\\n    function decodeFirstPool(bytes memory path) internal pure returns (address tokenA, address tokenB, uint24 fee) {\\n        tokenA = toAddress(path, 0);\\n        fee = toUint24(path, ADDR_SIZE);\\n        tokenB = toAddress(path, NEXT_OFFSET);\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3, \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\\n\",\"keccak256\":\"0xf4e8ced94ee6d6c002b75a7a46090e144f0ef150e7f70faaf70aa3ffe7b72c2e\",\"license\":\"GPL-2.0-or-later\"},\"contracts/verifiers/interfaces/ITxVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\ninterface ITxVerifier {\\n    struct TxInfo {\\n        uint64 chainId;\\n        uint64 nonce;\\n        uint256 gasTipCap;\\n        uint256 gasFeeCap;\\n        uint256 gas;\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        address from; // calculate from V R S\\n        uint32 blkNum;\\n        bytes32 blkHash;\\n        uint64 blkTime;\\n    }\\n\\n    // reverts if not verified\\n    // - txRaw: signed dynamic fee tx rlp encode data\\n    // - proofData: tx proof data\\n    // - auxiBlkVerifyInfo: auxiliary info for blk verify in chunk sync contract\\n    function verifyTx(\\n        bytes calldata txRaw,\\n        bytes calldata proofData,\\n        bytes calldata auxiBlkVerifyInfo\\n    ) external view returns (TxInfo memory txInfo);\\n\\n    // verifyTx and emit event\\n    function verifyTxAndLog(\\n        bytes calldata txRaw,\\n        bytes calldata proofData,\\n        bytes calldata auxiBlkVerifyInfo\\n    ) external returns (TxInfo memory info);\\n}\\n\",\"keccak256\":\"0xad6e03fef79d191a997fbd832859c2b64d34ba5a03525ccdff842e84519c9622\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x60803461013057601f6118ab38819003918201601f19168301916001600160401b038311848410176101355780849260209460405283398101031261013057516001600160a01b03808216918290036101305760005460018060a01b03199133838316176000553391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3601e602061009a61014b565b828152017f657865637574652862797465732c62797465735b5d2c75696e7432353629000081522060e01c6006549067ffffffff00000000601660206100de61014b565b828152017f657865637574652862797465732c62797465735b5d290000000000000000000081522060c01c169160018060401b03191617176006556001541617600155604051611740908161016b8239f35b600080fd5b634e487b7160e01b600052604160045260246000fd5b60408051919082016001600160401b038111838210176101355760405256fe6080604052600436101561001257600080fd5b60003560e01c80630f2ef5661461011757806321c7557c1461011257806323a45c931461010d57806327c5fc1314610108578063337ad58f14610103578063488c8719146100fe5780634cf88b22146100f95780634de359e8146100f4578063715018a6146100ef5780638da5cb5b146100ea57806395123685146100e5578063953cadad146100e05780639f38dbf9146100db578063a6806682146100d6578063e36fc1eb146100d15763f2fde38b146100cc57600080fd5b610af1565b610aa9565b610a75565b610a06565b6109ab565b61088d565b610835565b6107d4565b61078c565b6104bb565b6103f8565b6102f5565b610285565b61025e565b61020b565b610144565b67ffffffffffffffff81160361012e57565b600080fd5b6001600160a01b0381160361012e57565b3461012e57606036600319011261012e576004356101618161011c565b60243561016d81610133565b6044359060ff821680920361012e576101c89067ffffffffffffffff6000946101a16001600160a01b038754163314610ba0565b168452600460205260408420906001600160a01b03166001600160a01b0319825416179055565b6005602052604082209060ff1982541617905580f35b600711156101e857565b634e487b7160e01b600052602160045260246000fd5b9060078210156101e85752565b3461012e57602036600319011261012e576001600160a01b0360043561023081610133565b166000526008602052602060ff6040600020541661025160405180926101fe565bf35b600091031261012e57565b3461012e57600036600319011261012e5760206001600160a01b0360015416604051908152f35b3461012e57602036600319011261012e5767ffffffffffffffff6004356102ab8161011c565b16600052600460205260206001600160a01b0360406000205416604051908152f35b604090600319011261012e576004356102e58161011c565b906024356102f281610133565b90565b3461012e5761035067ffffffffffffffff61030f366102cd565b91906103276001600160a01b03600054163314610ba0565b1660005260026020526040600020906001600160a01b03166001600160a01b0319825416179055565b005b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161037c57604052565b610352565b90601f8019910116810190811067ffffffffffffffff82111761037c57604052565b60405190610180820182811067ffffffffffffffff82111761037c57604052565b67ffffffffffffffff811161037c57601f01601f191660200190565b9081526040810192916103f691602001906101fe565b565b3461012e57604036600319011261012e576004356104158161011c565b6024359067ffffffffffffffff821161012e573660238301121561012e57816004013590610442826103c4565b916104506040519384610381565b808352366024828601011161012e576020816000926024610479970183870137840101526111d3565b90610489604051928392836103e0565b0390f35b9181601f8401121561012e5782359167ffffffffffffffff831161012e576020838186019501011161012e57565b3461012e57606036600319011261012e5767ffffffffffffffff6004803582811161012e576104ed903690830161048d565b929060243582811161012e57610506903690850161048d565b909260443590811161012e5761051f903690860161048d565b939091856105446105386001546001600160a01b031690565b6001600160a01b031690565b9261056a60405197889687958694631b08846f60e11b865260009d8e9b8c988801610dc5565b03925af190811561076157839161076a575b506105e661059460a08301516001600160a01b031690565b6001600160a01b036105de6105386105d16105b7875167ffffffffffffffff1690565b67ffffffffffffffff166000526002602052604060002090565b546001600160a01b031690565b911614610e0b565b610100810161063461062561061e61060584516001600160a01b031690565b6001600160a01b03166000526008602052604060002090565b5460ff1690565b61062e816101de565b15610e57565b610654610649835167ffffffffffffffff1690565b60e0840151906111d3565b6106718161066c61060586516001600160a01b031690565b610ead565b856106846105386105386105d185610a5c565b84516001600160a01b031690803b15610766576106c69783604051809a819582946335313c2160e11b845283019190916001600160a01b036020820193169052565b03925af1918215610761577fbb5393be0f0ddf4fc1bad219916823c8ae4d5b88379239a2f761043b51a8a63b9561074293610748575b50610736610160610726610718885167ffffffffffffffff1690565b96516001600160a01b031690565b96015167ffffffffffffffff1690565b60405195869586610ec5565b0390a180f35b8061075561075b92610368565b80610253565b386106fc565b610dff565b8280fd5b61078691503d8085833e61077e8183610381565b810190610cbc565b3861057c565b3461012e57602036600319011261012e5767ffffffffffffffff6004356107b28161011c565b16600052600260205260206001600160a01b0360406000205416604051908152f35b3461012e57600080600319360112610832578080546001600160a01b03196001600160a01b03821691610808338414610ba0565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b3461012e57600036600319011261012e5760206001600160a01b0360005416604051908152f35b9181601f8401121561012e5782359167ffffffffffffffff831161012e576020808501948460051b01011161012e57565b3461012e57604036600319011261012e5767ffffffffffffffff60043581811161012e576108bf90369060040161085c565b9160243590811161012e576108d890369060040161085c565b6108f16001600160a01b03600094939454163314610ba0565b8084036109665760005b84811061090457005b61095061091a610915838588610f30565b610f45565b61093561093061092b858a89610f30565b610f4f565b610a5c565b906001600160a01b03166001600160a01b0319825416179055565b6000198114610961576001016108fb565b610f04565b60405162461bcd60e51b815260206004820152600f60248201527f6c656e677468206d69736d6174636800000000000000000000000000000000006044820152606490fd5b3461012e5761035067ffffffffffffffff6109c5366102cd565b91906109dd6001600160a01b03600054163314610ba0565b1660005260036020526040600020906001600160a01b03166001600160a01b0319825416179055565b3461012e57602036600319011261012e57600435610a2381610133565b6001600160a01b0390610a3b82600054163314610ba0565b166001600160a01b03196001541617600155600080f35b6007111561012e57565b60078110156101e8576000526007602052604060002090565b3461012e57602036600319011261012e5760206001600160a01b03610a9f60043561093081610a52565b5416604051908152f35b3461012e57602036600319011261012e5767ffffffffffffffff600435610acf8161011c565b16600052600360205260206001600160a01b0360406000205416604051908152f35b3461012e57602036600319011261012e57600435610b0e81610133565b6001600160a01b03610b2581600054163314610ba0565b811615610b355761035090610beb565b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b15610ba757565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600054906001600160a01b0380911691826001600160a01b0319821617600055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b51906103f68261011c565b51906103f682610133565b919080601f8401121561012e57825190610c62826103c4565b91610c706040519384610381565b80835260209182828701011161012e5760005b818110610c9857508260009394955001015290565b8581018301518482018401528201610c83565b519063ffffffff8216820361012e57565b60208183031261012e57805167ffffffffffffffff9182821161012e5701906101808284031261012e57610cee6103a3565b92610cf883610c33565b8452610d0660208401610c33565b6020850152604083015160408501526060830151606085015260808301516080850152610d3560a08401610c3e565b60a085015260c083015160c085015260e083015191821161012e57610d5b918301610c49565b60e0830152610100610d6e818301610c3e565b90830152610120610d80818301610cab565b908301526101408082015190830152610d9d610160809201610c33565b9082015290565b908060209392818452848401376000828201840152601f01601f1916010190565b94929093610de36102f29795610df194606089526060890191610da4565b918683036020880152610da4565b926040818503910152610da4565b6040513d6000823e3d90fd5b15610e1257565b60405162461bcd60e51b815260206004820152601260248201527f696e76616c696420746f206164647265737300000000000000000000000000006044820152606490fd5b15610e5e57565b60405162461bcd60e51b815260206004820152602160248201527f7377617020616c72656164792070726f76656420666f722074686973207573656044820152603960f91b6064820152608490fd5b9060078110156101e85760ff80198354169116179055565b90936103f6946080939796946001600160a01b0360a085019967ffffffffffffffff8094168652166020850152166040830152606082015201906101fe565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b9190811015610f405760051b0190565b610f1a565b356102f281610133565b356102f281610a52565b15610f6057565b60405162461bcd60e51b815260206004820152600c60248201527f77726f6e67206d6574686f6400000000000000000000000000000000000000006044820152606490fd5b60031981019190821161096157565b909160608284031261012e57815167ffffffffffffffff9081811161012e5784610fdf918501610c49565b936020908185015183811161012e57850181601f8201121561012e5780519380851161037c578460051b906040519561101a86840188610381565b865284808701928401019380851161012e57858401925b858410611048575050505050505060409092015190565b835183811161012e578791611062848480948a0101610c49565b815201930192611031565b805115610f405760200190565b805160011015610f405760210190565b805160011015610f405760400190565b156110a157565b60405162461bcd60e51b815260206004820152601360248201527f756e737570706f7274656420636f6d6d616e64000000000000000000000000006044820152606490fd5b919060a08382031261012e5782516110fd81610133565b92602081015192604082015192606083015167ffffffffffffffff811161012e5760809161112c918501610c49565b920151801515810361012e5790565b1561114257565b60405162461bcd60e51b815260206004820152601060248201527f756e737570706f727465642070616972000000000000000000000000000000006044820152606490fd5b1561118e57565b60405162461bcd60e51b815260206004820152601060248201527f7a65726f207573646320616d6f756e74000000000000000000000000000000006044820152606490fd5b91906112cf6112316112226112db9361121260208201516006549063ffffffff60e01b80911690808360e01b1682149283156113e6575b505050610f59565b61121c8151610fa5565b9061167f565b60208082518301019101610fb4565b5090603f6112676112418361106d565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c16600b811480156113dc575b156113c657506112ad6112a76112a16112c09361129a611241603f60f81b9261107a565b1660f81c90565b60ff1690565b9261108a565b51915b80159081156113bb575b5061109a565b602080825183010191016110e6565b50909250929092611517565b50926113016105386105d18867ffffffffffffffff166000526003602052604060002090565b6001600160a01b0392831690810361135c5750506102f292611349916113416105386105d18967ffffffffffffffff166000526004602052604060002090565b91161461113b565b80935b611357821515611187565b611461565b9092506113836105386105d18867ffffffffffffffff166000526004602052604060002090565b03611142576102f2926113b4916113416105386105d18967ffffffffffffffff166000526003602052604060002090565b809361134c565b6001915014386112ba565b916112c091506113d59061106d565b51916112b0565b50600a8114611276565b60c01b1614905038808061120a565b60ff16604d811161096157600a0a90565b90620f4240918083029283040361096157565b90620186a0918083029283040361096157565b90612710918083029283040361096157565b906103e8918083029283040361096157565b908160640291606483040361096157565b61148561061e61148a9267ffffffffffffffff166000526005602052604060002090565b6113f5565b61149381611406565b82106114a0575050600690565b6114a981611419565b82106114b6575050600590565b6114bf8161142c565b82106114cc575050600490565b6114d58161143e565b82106114e2575050600390565b6114eb90611450565b11156114f657600190565b600290565b90601f820180921161096157565b600401908160041161096157565b9061152660148351101561159b565b602082015160601c91601781511061155657603760178201519161154e602b8251101561159b565b015160601c91565b60405162461bcd60e51b815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e64730000000000000000000000006044820152606490fd5b156115a257565b60405162461bcd60e51b815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e647300000000000000000000006044820152606490fd5b156115ee57565b60405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f770000000000000000000000000000000000006044820152606490fd5b1561163a57565b60405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e64730000000000000000000000000000006044820152606490fd5b6116938261168c816114fb565b10156115e7565b6116a881516116a184611509565b1115611633565b816116c0575050604051600081526020810160405290565b60405191601f8116916004831560051b80858701019484860193010101905b8084106116f75750508252601f01601f191660405290565b90928351815260208091019301906116df56fea2646970667358221220466b8f4796875930dbebe6e9aafb5722cce089cff8602ffd196b91b991eca5cf64736f6c63430008120033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b60003560e01c80630f2ef5661461011757806321c7557c1461011257806323a45c931461010d57806327c5fc1314610108578063337ad58f14610103578063488c8719146100fe5780634cf88b22146100f95780634de359e8146100f4578063715018a6146100ef5780638da5cb5b146100ea57806395123685146100e5578063953cadad146100e05780639f38dbf9146100db578063a6806682146100d6578063e36fc1eb146100d15763f2fde38b146100cc57600080fd5b610af1565b610aa9565b610a75565b610a06565b6109ab565b61088d565b610835565b6107d4565b61078c565b6104bb565b6103f8565b6102f5565b610285565b61025e565b61020b565b610144565b67ffffffffffffffff81160361012e57565b600080fd5b6001600160a01b0381160361012e57565b3461012e57606036600319011261012e576004356101618161011c565b60243561016d81610133565b6044359060ff821680920361012e576101c89067ffffffffffffffff6000946101a16001600160a01b038754163314610ba0565b168452600460205260408420906001600160a01b03166001600160a01b0319825416179055565b6005602052604082209060ff1982541617905580f35b600711156101e857565b634e487b7160e01b600052602160045260246000fd5b9060078210156101e85752565b3461012e57602036600319011261012e576001600160a01b0360043561023081610133565b166000526008602052602060ff6040600020541661025160405180926101fe565bf35b600091031261012e57565b3461012e57600036600319011261012e5760206001600160a01b0360015416604051908152f35b3461012e57602036600319011261012e5767ffffffffffffffff6004356102ab8161011c565b16600052600460205260206001600160a01b0360406000205416604051908152f35b604090600319011261012e576004356102e58161011c565b906024356102f281610133565b90565b3461012e5761035067ffffffffffffffff61030f366102cd565b91906103276001600160a01b03600054163314610ba0565b1660005260026020526040600020906001600160a01b03166001600160a01b0319825416179055565b005b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff811161037c57604052565b610352565b90601f8019910116810190811067ffffffffffffffff82111761037c57604052565b60405190610180820182811067ffffffffffffffff82111761037c57604052565b67ffffffffffffffff811161037c57601f01601f191660200190565b9081526040810192916103f691602001906101fe565b565b3461012e57604036600319011261012e576004356104158161011c565b6024359067ffffffffffffffff821161012e573660238301121561012e57816004013590610442826103c4565b916104506040519384610381565b808352366024828601011161012e576020816000926024610479970183870137840101526111d3565b90610489604051928392836103e0565b0390f35b9181601f8401121561012e5782359167ffffffffffffffff831161012e576020838186019501011161012e57565b3461012e57606036600319011261012e5767ffffffffffffffff6004803582811161012e576104ed903690830161048d565b929060243582811161012e57610506903690850161048d565b909260443590811161012e5761051f903690860161048d565b939091856105446105386001546001600160a01b031690565b6001600160a01b031690565b9261056a60405197889687958694631b08846f60e11b865260009d8e9b8c988801610dc5565b03925af190811561076157839161076a575b506105e661059460a08301516001600160a01b031690565b6001600160a01b036105de6105386105d16105b7875167ffffffffffffffff1690565b67ffffffffffffffff166000526002602052604060002090565b546001600160a01b031690565b911614610e0b565b610100810161063461062561061e61060584516001600160a01b031690565b6001600160a01b03166000526008602052604060002090565b5460ff1690565b61062e816101de565b15610e57565b610654610649835167ffffffffffffffff1690565b60e0840151906111d3565b6106718161066c61060586516001600160a01b031690565b610ead565b856106846105386105386105d185610a5c565b84516001600160a01b031690803b15610766576106c69783604051809a819582946335313c2160e11b845283019190916001600160a01b036020820193169052565b03925af1918215610761577fbb5393be0f0ddf4fc1bad219916823c8ae4d5b88379239a2f761043b51a8a63b9561074293610748575b50610736610160610726610718885167ffffffffffffffff1690565b96516001600160a01b031690565b96015167ffffffffffffffff1690565b60405195869586610ec5565b0390a180f35b8061075561075b92610368565b80610253565b386106fc565b610dff565b8280fd5b61078691503d8085833e61077e8183610381565b810190610cbc565b3861057c565b3461012e57602036600319011261012e5767ffffffffffffffff6004356107b28161011c565b16600052600260205260206001600160a01b0360406000205416604051908152f35b3461012e57600080600319360112610832578080546001600160a01b03196001600160a01b03821691610808338414610ba0565b1682557f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b80fd5b3461012e57600036600319011261012e5760206001600160a01b0360005416604051908152f35b9181601f8401121561012e5782359167ffffffffffffffff831161012e576020808501948460051b01011161012e57565b3461012e57604036600319011261012e5767ffffffffffffffff60043581811161012e576108bf90369060040161085c565b9160243590811161012e576108d890369060040161085c565b6108f16001600160a01b03600094939454163314610ba0565b8084036109665760005b84811061090457005b61095061091a610915838588610f30565b610f45565b61093561093061092b858a89610f30565b610f4f565b610a5c565b906001600160a01b03166001600160a01b0319825416179055565b6000198114610961576001016108fb565b610f04565b60405162461bcd60e51b815260206004820152600f60248201527f6c656e677468206d69736d6174636800000000000000000000000000000000006044820152606490fd5b3461012e5761035067ffffffffffffffff6109c5366102cd565b91906109dd6001600160a01b03600054163314610ba0565b1660005260036020526040600020906001600160a01b03166001600160a01b0319825416179055565b3461012e57602036600319011261012e57600435610a2381610133565b6001600160a01b0390610a3b82600054163314610ba0565b166001600160a01b03196001541617600155600080f35b6007111561012e57565b60078110156101e8576000526007602052604060002090565b3461012e57602036600319011261012e5760206001600160a01b03610a9f60043561093081610a52565b5416604051908152f35b3461012e57602036600319011261012e5767ffffffffffffffff600435610acf8161011c565b16600052600360205260206001600160a01b0360406000205416604051908152f35b3461012e57602036600319011261012e57600435610b0e81610133565b6001600160a01b03610b2581600054163314610ba0565b811615610b355761035090610beb565b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608490fd5b15610ba757565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600054906001600160a01b0380911691826001600160a01b0319821617600055167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b51906103f68261011c565b51906103f682610133565b919080601f8401121561012e57825190610c62826103c4565b91610c706040519384610381565b80835260209182828701011161012e5760005b818110610c9857508260009394955001015290565b8581018301518482018401528201610c83565b519063ffffffff8216820361012e57565b60208183031261012e57805167ffffffffffffffff9182821161012e5701906101808284031261012e57610cee6103a3565b92610cf883610c33565b8452610d0660208401610c33565b6020850152604083015160408501526060830151606085015260808301516080850152610d3560a08401610c3e565b60a085015260c083015160c085015260e083015191821161012e57610d5b918301610c49565b60e0830152610100610d6e818301610c3e565b90830152610120610d80818301610cab565b908301526101408082015190830152610d9d610160809201610c33565b9082015290565b908060209392818452848401376000828201840152601f01601f1916010190565b94929093610de36102f29795610df194606089526060890191610da4565b918683036020880152610da4565b926040818503910152610da4565b6040513d6000823e3d90fd5b15610e1257565b60405162461bcd60e51b815260206004820152601260248201527f696e76616c696420746f206164647265737300000000000000000000000000006044820152606490fd5b15610e5e57565b60405162461bcd60e51b815260206004820152602160248201527f7377617020616c72656164792070726f76656420666f722074686973207573656044820152603960f91b6064820152608490fd5b9060078110156101e85760ff80198354169116179055565b90936103f6946080939796946001600160a01b0360a085019967ffffffffffffffff8094168652166020850152166040830152606082015201906101fe565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b9190811015610f405760051b0190565b610f1a565b356102f281610133565b356102f281610a52565b15610f6057565b60405162461bcd60e51b815260206004820152600c60248201527f77726f6e67206d6574686f6400000000000000000000000000000000000000006044820152606490fd5b60031981019190821161096157565b909160608284031261012e57815167ffffffffffffffff9081811161012e5784610fdf918501610c49565b936020908185015183811161012e57850181601f8201121561012e5780519380851161037c578460051b906040519561101a86840188610381565b865284808701928401019380851161012e57858401925b858410611048575050505050505060409092015190565b835183811161012e578791611062848480948a0101610c49565b815201930192611031565b805115610f405760200190565b805160011015610f405760210190565b805160011015610f405760400190565b156110a157565b60405162461bcd60e51b815260206004820152601360248201527f756e737570706f7274656420636f6d6d616e64000000000000000000000000006044820152606490fd5b919060a08382031261012e5782516110fd81610133565b92602081015192604082015192606083015167ffffffffffffffff811161012e5760809161112c918501610c49565b920151801515810361012e5790565b1561114257565b60405162461bcd60e51b815260206004820152601060248201527f756e737570706f727465642070616972000000000000000000000000000000006044820152606490fd5b1561118e57565b60405162461bcd60e51b815260206004820152601060248201527f7a65726f207573646320616d6f756e74000000000000000000000000000000006044820152606490fd5b91906112cf6112316112226112db9361121260208201516006549063ffffffff60e01b80911690808360e01b1682149283156113e6575b505050610f59565b61121c8151610fa5565b9061167f565b60208082518301019101610fb4565b5090603f6112676112418361106d565b517fff000000000000000000000000000000000000000000000000000000000000001690565b60f81c16600b811480156113dc575b156113c657506112ad6112a76112a16112c09361129a611241603f60f81b9261107a565b1660f81c90565b60ff1690565b9261108a565b51915b80159081156113bb575b5061109a565b602080825183010191016110e6565b50909250929092611517565b50926113016105386105d18867ffffffffffffffff166000526003602052604060002090565b6001600160a01b0392831690810361135c5750506102f292611349916113416105386105d18967ffffffffffffffff166000526004602052604060002090565b91161461113b565b80935b611357821515611187565b611461565b9092506113836105386105d18867ffffffffffffffff166000526004602052604060002090565b03611142576102f2926113b4916113416105386105d18967ffffffffffffffff166000526003602052604060002090565b809361134c565b6001915014386112ba565b916112c091506113d59061106d565b51916112b0565b50600a8114611276565b60c01b1614905038808061120a565b60ff16604d811161096157600a0a90565b90620f4240918083029283040361096157565b90620186a0918083029283040361096157565b90612710918083029283040361096157565b906103e8918083029283040361096157565b908160640291606483040361096157565b61148561061e61148a9267ffffffffffffffff166000526005602052604060002090565b6113f5565b61149381611406565b82106114a0575050600690565b6114a981611419565b82106114b6575050600590565b6114bf8161142c565b82106114cc575050600490565b6114d58161143e565b82106114e2575050600390565b6114eb90611450565b11156114f657600190565b600290565b90601f820180921161096157565b600401908160041161096157565b9061152660148351101561159b565b602082015160601c91601781511061155657603760178201519161154e602b8251101561159b565b015160601c91565b60405162461bcd60e51b815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e64730000000000000000000000006044820152606490fd5b156115a257565b60405162461bcd60e51b815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e647300000000000000000000006044820152606490fd5b156115ee57565b60405162461bcd60e51b815260206004820152600e60248201527f736c6963655f6f766572666c6f770000000000000000000000000000000000006044820152606490fd5b1561163a57565b60405162461bcd60e51b815260206004820152601160248201527f736c6963655f6f75744f66426f756e64730000000000000000000000000000006044820152606490fd5b6116938261168c816114fb565b10156115e7565b6116a881516116a184611509565b1115611633565b816116c0575050604051600081526020810160405290565b60405191601f8116916004831560051b80858701019484860193010101905b8084106116f75750508252601f01601f191660405290565b90928351815260208091019301906116df56fea2646970667358221220466b8f4796875930dbebe6e9aafb5722cce089cff8602ffd196b91b991eca5cf64736f6c63430008120033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3593,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "txVerifier",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(ITxVerifier)70362"
      },
      {
        "astId": 3597,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "universalRouter",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint64,t_address)"
      },
      {
        "astId": 3601,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "weth",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint64,t_address)"
      },
      {
        "astId": 3605,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "usdc",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint64,t_address)"
      },
      {
        "astId": 3609,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "usdcDecimal",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint64,t_uint8)"
      },
      {
        "astId": 3620,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "executeSelector",
        "offset": 0,
        "slot": "6",
        "type": "t_bytes4"
      },
      {
        "astId": 3631,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "executeNoDealineSelector",
        "offset": 4,
        "slot": "6",
        "type": "t_bytes4"
      },
      {
        "astId": 3644,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "tierNFTs",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_enum(TierName)3639,t_address)"
      },
      {
        "astId": 3649,
        "contract": "contracts/apps/uniswap-volume/UniswapVolume.sol:UniswapVolume",
        "label": "userTier",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_enum(TierName)3639)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_contract(ITxVerifier)70362": {
        "encoding": "inplace",
        "label": "contract ITxVerifier",
        "numberOfBytes": "20"
      },
      "t_enum(TierName)3639": {
        "encoding": "inplace",
        "label": "enum UniswapVolume.TierName",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_enum(TierName)3639)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => enum UniswapVolume.TierName)",
        "numberOfBytes": "32",
        "value": "t_enum(TierName)3639"
      },
      "t_mapping(t_enum(TierName)3639,t_address)": {
        "encoding": "mapping",
        "key": "t_enum(TierName)3639",
        "label": "mapping(enum UniswapVolume.TierName => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint64,t_address)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint64,t_uint8)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => uint8)",
        "numberOfBytes": "32",
        "value": "t_uint8"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}